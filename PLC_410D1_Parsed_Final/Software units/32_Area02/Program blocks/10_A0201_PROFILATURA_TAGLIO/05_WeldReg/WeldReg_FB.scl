FUNCTION_BLOCK "WeldReg_FB"
{ S7_Optimized_Access := 'TRUE' ; Published := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      AreaInterface : "AreaInterface";
      CIn : Struct
         StraightnerMaterialPresence : Bool;
         PinchrollMaterialPresence : Bool;
         PrePunchingMaterialPresence : Bool;
         CoilHandling_CounterValue : LReal;
         CoilHandling_CounterInOperation : Bool;
         PhaseCounterValue : LReal;
         PhaseCounterInOperation : Bool;
         WeldDone : Bool;
         Carriage_CounterValue : LReal;
         PostPunching_CounterData : "MatCountData";
         Manager : Struct
            ActTarget_P_ID : DInt;
            ActTarget_XStart : LReal;
            ActTarget_XEnd : LReal;
            NextTarget_P_ID : DInt;
            NextTarget_XStart : LReal;
            NextTarget_XEnd : LReal;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT 
      MachineInterface : "MachineInterface";
      COut : Struct
         WeldDoneAck : Bool;
         Manager : Struct
            ActTarget_P_ID : DInt;
            ActTarget_WeldPresence : Bool;
            ActTarget_WeldEndPos : LReal;
            NextTarget_P_ID : DInt;
            NextTarget_WeldPresence : Bool;
            NextTarget_WeldEndPos : LReal;
            WeldMIssingToFinalCut : LReal;
            WeldPresence : Bool;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT 
      PersistentValues : "udt_WeldReg_Pers";
      TO_WeldMeasInput {InstructionName := 'TO_MeasuringInput'; LibVersion := '8.0'} : TO_MeasuringInput;
   END_VAR

   VAR 
      Ctrl : Struct
         SetScrapCaseThreading : Bool;
         SetScrapCaseEndOfCoil : Bool;
         SetScrapCaseFullEmptying : Bool;
         WelderWriteRegExe : Bool;
         MeasInp_Enable : Bool;
      END_STRUCT;
      Sts : Struct
         InitDone : Bool;
         AlarmsPresence : Bool;
         WarningsPresence : Bool;
         WelderInitDone : Bool;
         WelderMWCounter : LReal;
         WelderPhaseCounter : LReal;
         WelderBegin_PhaseCounter : LReal;
         WelderEnd_PhaseCounter : LReal;
         WelderBegin_MWCounter : LReal;
         WelderEnd_MWCounter : LReal;
         WelderWriteRegDone : Bool;
         WelderEnableReg : Bool;
         WelderOffsetConvPhaseCounter : LReal;
         WelderNextScrapBegin_MWCounter : LReal;
         LimitOlderItem : LReal;
         WeldMeasInp : Struct
            LastID : UInt;
            SavedPosAxValue2 : LReal;
            SavedPosAxValue1 : LReal;
            SavedPosMatValue1 : LReal;
            SavedPosMatValue2 : LReal;
            PosBegin : LReal;
            PosEnd : LReal;
         END_STRUCT;
      END_STRUCT;
      HMI : Struct
         DeleteWeldRegBuffer : Bool;
      END_STRUCT;
      Alarms : Struct
         WeldMeasInput { S7_SetPoint := 'False'} : "TMeasuring_Alarms";
      END_STRUCT;
      Diag : Struct
         WelMeasInput { S7_SetPoint := 'False'} : "TO_Diagnostic";
      END_STRUCT;
      Warnings : Struct
         NoAutReady : Bool;
      END_STRUCT;
      WeldMesInp { S7_SetPoint := 'False'} : "MeasuringInput";
      WeldReg_Empty { S7_SetPoint := 'False'} : "udt_WeldReg_Item";
      TP_Status { S7_SetPoint := 'True'} : Int;
   END_VAR

   VAR_TEMP 
      i : Int;
   END_VAR

   VAR CONSTANT 
      LIMIT_DELETE_OLD_DATA : LReal := 20000.0;
   END_VAR


BEGIN
	//============================================================================
	// INIZIALIZZA VARIABILI
	//============================================================================
	IF NOT #Sts.InitDone
	THEN
	    #Sts.InitDone := TRUE;
	    
	    #WeldReg_Empty.PosBegin := -1.0;
	    #WeldReg_Empty.PosEnd := -1.0;
	    #WeldReg_Empty.MW_PosBegin := -1.0;
	    #WeldReg_Empty.MW_PosEnd := -1.0;
	END_IF;
	
	
	REGION Init Buffer
	//======================================================================================
	// Cancellazione totale registrazioni : Vuotamento linea o pulsante inizializza su HMI
	//======================================================================================
	
	IF NOT #CIn.StraightnerMaterialPresence AND NOT #CIn.PinchrollMaterialPresence AND NOT #CIn.PrePunchingMaterialPresence
	THEN
	    IF #PersistentValues.CoilThreadingDone
	    THEN
	        #Ctrl.SetScrapCaseFullEmptying := TRUE;
	    END_IF;
	    #PersistentValues.CoilThreadingDone := FALSE;
	    
	ELSIF #CIn.StraightnerMaterialPresence AND #CIn.PinchrollMaterialPresence AND #CIn.PrePunchingMaterialPresence
	THEN
	    #PersistentValues.CoilThreadingDone := TRUE;
	END_IF;
	
	
	 IF #HMI.DeleteWeldRegBuffer OR #Ctrl.SetScrapCaseFullEmptying 
	THEN
	    FOR #i := 1 TO "WELDER_ITEMS_QTY" DO
	        #PersistentValues.WelderReg[#i] := #WeldReg_Empty;
	    END_FOR;
	    #Sts.WelderInitDone := FALSE;
	    #HMI.DeleteWeldRegBuffer := FALSE;
	END_IF;
	
	#Ctrl.SetScrapCaseFullEmptying := FALSE;
	
	END_REGION
	
	
	REGION Weld Counters
	    //============================================================================
	    // SALDATURA
	    //============================================================================
	    
	    #Sts.WelderMWCounter := -1;
	    IF #CIn.CoilHandling_CounterInOperation
	    THEN
	        #Sts.WelderMWCounter := #CIn.CoilHandling_CounterValue;
	    END_IF;
	    
	    #Sts.WelderPhaseCounter := -1;
	    IF #CIn.PhaseCounterInOperation
	    THEN
	        #Sts.WelderPhaseCounter := "M_PosAPlusCostB"(PosA := #CIn.PhaseCounterValue, CostB := "WELDER_PHASE_OFFSET", MODULE := "MATERIAL_COUNTERS_MODULE");
	        
	        IF #CIn.CoilHandling_CounterInOperation
	        THEN
	            #Sts.WelderOffsetConvPhaseCounter := "M_PosAMinusPosB"(PosA := #Sts.WelderPhaseCounter, PosB := #Sts.WelderMWCounter, MODULE := "MATERIAL_COUNTERS_MODULE");
	        END_IF;
	    END_IF;
	    
	    // Valore prossima registrazione di inizio
	    #Sts.WelderNextScrapBegin_MWCounter := "M_PosAMinusCostB"(PosA := #Sts.WelderMWCounter, CostB := "WELDER_SCRAP_AREA", MODULE := "MATERIAL_COUNTERS_MODULE");
	    
	    // Abilitazione registrazione quando la posizione è > della registrazione fine precedente oppure la registrazione precedente è nulla    
	    #Sts.WelderEnableReg := #PersistentValues.CoilThreadingDone //AND NOT #PersistentValues.CoilThreadingDone.END_OF_COIL
	    AND
	    (#Sts.WelderMWCounter >= 0 AND #Sts.WelderMWCounter <= "MATERIAL_COUNTERS_MODULE")
	    AND
	    (
	    (
	    (#PersistentValues.WelderReg[1].MW_PosEnd >= 0.0 AND #PersistentValues.WelderReg[1].MW_PosEnd <= "MATERIAL_COUNTERS_MODULE")
	    AND
	    ("M_CmpGT"(Xa := #Sts.WelderNextScrapBegin_MWCounter, Xb := #PersistentValues.WelderReg[1].MW_PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE"))
	    )
	    OR
	    (#PersistentValues.WelderReg[1].MW_PosEnd < 0.0 OR #PersistentValues.WelderReg[1].MW_PosEnd > "MATERIAL_COUNTERS_MODULE")
	    );
	    
	END_REGION
	
	
	REGION Weld Reg from JB
	    // Reset memorie                        
	    IF (NOT #CIn.WeldDone AND #Ctrl.WelderWriteRegExe AND #Sts.WelderWriteRegDone)
	        OR
	        NOT #CIn.CoilHandling_CounterInOperation
	        OR
	        NOT #Sts.WelderInitDone
	        OR
	        NOT #PersistentValues.CoilThreadingDone
	    THEN
	        #Sts.WelderInitDone := TRUE;
	        
	        #Sts.WelderBegin_PhaseCounter := -1.0;
	        #Sts.WelderEnd_PhaseCounter := -1.0;
	        #Sts.WelderBegin_MWCounter := -1.0;
	        #Sts.WelderEnd_MWCounter := -1.0;
	        #Sts.WelderWriteRegDone := FALSE;
	        #Ctrl.WelderWriteRegExe := FALSE;
	        
	        // Attesa conclusione scrittura precedente  
	    ELSIF #Ctrl.WelderWriteRegExe OR #Sts.WelderWriteRegDone
	    THEN
	        ;
	        
	        // Abilitazione registrazione posizione scarto
	    ELSIF NOT #Sts.WelderEnableReg
	    THEN
	        ;
	        // Salvataggio posizione inizio + fine registrazione    
	    ELSIF #CIn.WeldDone AND NOT #Ctrl.WelderWriteRegExe
	    THEN
	        
	        #Sts.WelderBegin_MWCounter := "M_PosAMinusCostB"(PosA := #Sts.WelderMWCounter, CostB := "WELDER_SCRAP_AREA" / 2, MODULE := "MATERIAL_COUNTERS_MODULE");
	        #Sts.WelderEnd_MWCounter := "M_PosAPlusCostB"(PosA := #Sts.WelderMWCounter, CostB := "WELDER_SCRAP_AREA" / 2, MODULE := "MATERIAL_COUNTERS_MODULE");
	        
	        #Sts.WelderBegin_PhaseCounter := -1;
	        #Sts.WelderEnd_PhaseCounter := -1;
	        IF #CIn.PhaseCounterInOperation
	        THEN
	            #Sts.WelderBegin_PhaseCounter := "M_PosAMinusCostB"(PosA := #Sts.WelderPhaseCounter, CostB := "WELDER_SCRAP_AREA" / 2, MODULE := "MATERIAL_COUNTERS_MODULE");
	            #Sts.WelderEnd_PhaseCounter := "M_PosAPlusCostB"(PosA := #Sts.WelderPhaseCounter, CostB := "WELDER_SCRAP_AREA" / 2, MODULE := "MATERIAL_COUNTERS_MODULE");
	        END_IF;
	        #Ctrl.WelderWriteRegExe := TRUE;
	    END_IF;
	    
	    // Saldatura Scrittura Registrazione
	    IF #Ctrl.WelderWriteRegExe AND NOT #Sts.WelderWriteRegDone
	    THEN
	        FOR #i := "WELDER_ITEMS_QTY" TO 2 BY -1 DO
	            #PersistentValues.WelderReg[#i] := #PersistentValues.WelderReg[#i - 1];
	        END_FOR;
	        
	        #PersistentValues.WelderReg[1].PosBegin := #Sts.WelderBegin_PhaseCounter;
	        #PersistentValues.WelderReg[1].PosEnd := #Sts.WelderEnd_PhaseCounter;
	        #PersistentValues.WelderReg[1].MW_PosBegin := #Sts.WelderBegin_MWCounter;
	        #PersistentValues.WelderReg[1].MW_PosEnd := #Sts.WelderEnd_MWCounter;
	        
	        #Sts.WelderWriteRegDone := TRUE;
	    END_IF;
	    
	END_REGION
	
	
	// Saldatrice cancellazione registrazioni vecchie
	IF #CIn.PhaseCounterInOperation
	THEN
	   FOR #i := 1 TO "WELDER_ITEMS_QTY" DO
	 
	        #Sts.LimitOlderItem := "M_PosAMinusPosB"(PosA := #CIn.PostPunching_CounterData.CounterValue, PosB := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE");
	        IF #Sts.LimitOlderItem > #LIMIT_DELETE_OLD_DATA
	        THEN
	            #PersistentValues.WelderReg[#i] := #WeldReg_Empty;
	        END_IF;
	   END_FOR;
	END_IF;
	
	
	
	// Welder aggiornamento registrazioni senza valorin in phase
	IF #CIn.PhaseCounterInOperation
	THEN
	   FOR #i := 1 TO "WELDER_ITEMS_QTY" DO
	  
	        IF #PersistentValues.WelderReg[#i].MW_PosBegin >= 0 AND #PersistentValues.WelderReg[#i].MW_PosBegin <= "MATERIAL_COUNTERS_MODULE"
	            AND
	            #PersistentValues.WelderReg[#i].MW_PosEnd >= 0 AND #PersistentValues.WelderReg[#i].MW_PosEnd <= "MATERIAL_COUNTERS_MODULE"
	        THEN
	            
	            // Se la reg.inizio non è valida..calcolo con offset rispetto alla posizione MW di inzio
	            IF #PersistentValues.WelderReg[#i].PosBegin < 0.0
	            THEN
	                #PersistentValues.WelderReg[#i].PosBegin := "M_PosAPlusCostB"(PosA := #PersistentValues.WelderReg[#i].MW_PosBegin, CostB := #Sts.WelderOffsetConvPhaseCounter, MODULE := "MATERIAL_COUNTERS_MODULE");
	            END_IF;
	            
	            // Se la reg.fine non è valida..calcolo con offset rispetto alla posizione MW di fine
	            IF #PersistentValues.WelderReg[#i].PosEnd < 0.0
	            THEN
	                #PersistentValues.WelderReg[#i].PosEnd := "M_PosAPlusCostB"(PosA := #PersistentValues.WelderReg[#i].MW_PosEnd, CostB := #Sts.WelderOffsetConvPhaseCounter, MODULE := "MATERIAL_COUNTERS_MODULE");
	            END_IF;
	            
	        END_IF;
	   END_FOR;
	END_IF;
	
	
	REGION Weld Reg with TP
	
	    #Ctrl.MeasInp_Enable := #CIn.PostPunching_CounterData.CounterValid;
	   
	
	    CASE #TP_Status OF
	            
	            //INIT 
	        0:
	            IF #Ctrl.MeasInp_Enable AND 
	                #WeldMesInp.MeasuringSts.InOperation
	            THEN
	                #Sts.WeldMeasInp.LastID := #PersistentValues.WeldMeasInpID;
	                #TP_Status += 1;
	            END_IF;
	            
	        1:  //MEasuring
	            
	            IF NOT #Ctrl.MeasInp_Enable THEN
	                #TP_Status := 0;
	            ELSIF #WeldMesInp.MeasuringSts.MeasuringDone_ID <> #Sts.WeldMeasInp.LastID THEN
	                #Sts.WeldMeasInp.LastID := #WeldMesInp.MeasuringSts.MeasuringDone_ID;
	                #Sts.WeldMeasInp.SavedPosAxValue1 := #WeldMesInp.MeasuringSts.MeasuringValue1;
	                #Sts.WeldMeasInp.SavedPosAxValue2 := #WeldMesInp.MeasuringSts.MeasuringValue2;
	                
	                #Sts.WeldMeasInp.SavedPosMatValue1 := "PosAxisToPosMat_Wheel"(PosAxis := #Sts.WeldMeasInp.SavedPosAxValue1, Data := #CIn.PostPunching_CounterData);
	                #Sts.WeldMeasInp.SavedPosMatValue2 := "PosAxisToPosMat_Wheel"(PosAxis := #Sts.WeldMeasInp.SavedPosAxValue2, Data := #CIn.PostPunching_CounterData);
	                
	                #TP_Status += 1;
	            END_IF;
	                
	            
	        2: //Save result
	            
	            #Sts.WeldMeasInp.PosBegin := "M_PosAPlusCostB"(PosA := #Sts.WeldMeasInp.SavedPosMatValue1, CostB := #PersistentValues.Par.TP_OffsetFromCut, MODULE := "MATERIAL_COUNTERS_MODULE");
	            #Sts.WeldMeasInp.PosEnd := "M_PosAPlusCostB"(PosA := #Sts.WeldMeasInp.SavedPosMatValue2, CostB := #PersistentValues.Par.TP_OffsetFromCut, MODULE := "MATERIAL_COUNTERS_MODULE");
	            
	            FOR #i := "WELDER_ITEMS_QTY" TO 2 BY -1 DO
	                #PersistentValues.WelderReg[#i] := #PersistentValues.WelderReg[#i - 1];
	            END_FOR;
	            
	            #PersistentValues.WelderReg[1].PosBegin := #Sts.WeldMeasInp.PosBegin;
	            #PersistentValues.WelderReg[1].PosEnd := #Sts.WeldMeasInp.PosEnd;
	            #PersistentValues.WelderReg[1].MW_PosBegin := -1.0;
	            #PersistentValues.WelderReg[1].MW_PosEnd := -1.0;
	            
	            #TP_Status := 1;
	            
	    END_CASE;
	
	    #WeldMesInp.MeasuringCtrl.Rst := #AreaInterface.RstAlarms;
	    #WeldMesInp.MeasuringCtrl.MeasureEnable := #Ctrl.MeasInp_Enable;
	    IF #PersistentValues.Par.TP_On_InsideHole THEN
	        #WeldMesInp.MeasuringCtrl.Mode := 3;
	    ELSE
	        #WeldMesInp.MeasuringCtrl.Mode := 4;
	    END_IF;
	
	    #WeldMesInp(TO_Measuring := #TO_WeldMeasInput,
	                Alarm := #Alarms.WeldMeasInput,
	                Diag := #Diag.WelMeasInput,
	                Trigger_ID := #PersistentValues.WeldMeasInpID);
	
	
	END_REGION
	
	REGION Registration valid
	    
	#COut.Manager.WeldPresence := FALSE;
	#COut.Manager.WeldMIssingToFinalCut := -1;
	
	IF #CIn.PostPunching_CounterData.CounterValid THEN
	    FOR #i := 1 TO "WELDER_ITEMS_QTY" DO
	        
	        #PersistentValues.WelderReg[#i].Valid :=
	        #PersistentValues.WelderReg[#i].PosBegin >= 0 AND #PersistentValues.WelderReg[#i].PosBegin <= "MATERIAL_COUNTERS_MODULE"
	        AND
	        #PersistentValues.WelderReg[#i].PosEnd >= 0 AND #PersistentValues.WelderReg[#i].PosEnd <= "MATERIAL_COUNTERS_MODULE"
	        AND
	        ("M_PosAMinusPosB"(PosA := #PersistentValues.WelderReg[#i].PosEnd, PosB := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") > ("WELDER_SCRAP_AREA" / 2))
	        AND
	        ("M_PosAMinusPosB"(PosA := #PersistentValues.WelderReg[#i].PosEnd, PosB := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") < ("WELDER_SCRAP_AREA" * 2));
	        
	        IF #PersistentValues.WelderReg[#i].Valid THEN
	            #COut.Manager.WeldMIssingToFinalCut := "M_PosAMinusPosB"(PosA := #PersistentValues.WelderReg[#i].PosEnd, PosB := #CIn.Carriage_CounterValue, MODULE := "MATERIAL_COUNTERS_MODULE");
	            #COut.Manager.WeldPresence := #COut.Manager.WeldMIssingToFinalCut > 0.0;
	        END_IF;
	        
	    END_FOR;
	END_IF;
	
	END_REGION
	
	
	    
	REGION Actual Target Weld Presence   
	    
	    #COut.Manager.ActTarget_P_ID := -1;
	    #COut.Manager.ActTarget_WeldPresence := FALSE;
	    #COut.Manager.ActTarget_WeldEndPos := -1.0;
	    
	    IF #CIn.Manager.ActTarget_P_ID > 0
	    THEN
	        
	        //Errore di saldatura
	        FOR #i := 1 TO "WELDER_ITEMS_QTY" DO
	  
	            IF (
	                ("M_CmpGTE"(Xa := #CIn.Manager.ActTarget_XEnd, Xb := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") // Caso 1 = Coda pezzo dentro a area saldatura
	                AND
	                "M_CmpLTE"(Xa := #CIn.Manager.ActTarget_XEnd, Xb := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE")
	                )
	                OR (
	                "M_CmpLTE"(Xa := #CIn.Manager.ActTarget_XStart, Xb := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") // Caso 2 = Area saldatura dentro al pezzo
	                AND
	                "M_CmpGTE"(Xa := #CIn.Manager.ActTarget_XEnd, Xb := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE")
	                )
	                OR (
	                "M_CmpGTE"(Xa := #CIn.Manager.ActTarget_XStart, Xb := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") // Caso 3 = Testa pezzo dentro area saldatura
	                AND
	                "M_CmpLTE"(Xa := #CIn.Manager.ActTarget_XStart, Xb := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE")
	                )
	                )
	                AND
	                #PersistentValues.WelderReg[#i].Valid
	            THEN
	                #COut.Manager.ActTarget_P_ID := #CIn.Manager.ActTarget_P_ID;
	                #COut.Manager.ActTarget_WeldPresence := TRUE;
	                
	                IF "M_CmpGTE"(Xa := #PersistentValues.WelderReg[#i].PosEnd, Xb := #COut.Manager.ActTarget_WeldEndPos, MODULE := "MATERIAL_COUNTERS_MODULE") OR
	                    #COut.Manager.ActTarget_WeldEndPos = -1
	                THEN
	                    #COut.Manager.ActTarget_WeldEndPos := #PersistentValues.WelderReg[#i].PosEnd;
	                END_IF;
	            END_IF;
	       END_FOR;
	        
	    END_IF;
	    
	END_REGION
	    
	    
	    
	REGION Next Target Weld Presence   
	
	    #COut.Manager.NextTarget_P_ID := -1;
	    #COut.Manager.NextTarget_WeldPresence := FALSE;
	    #COut.Manager.NextTarget_WeldEndPos := -1.0;
	    
	    IF #CIn.Manager.NextTarget_P_ID > 0
	    THEN
	        
	        //Errore di saldatura
	        FOR #i := 1 TO "WELDER_ITEMS_QTY" DO
	    
	            IF (
	                ("M_CmpGTE"(Xa := #CIn.Manager.NextTarget_XEnd, Xb := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") // Caso 1 = Coda pezzo dentro a area saldatura
	                AND
	                "M_CmpLTE"(Xa := #CIn.Manager.NextTarget_XEnd, Xb := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE")
	                )
	                OR (
	                "M_CmpLTE"(Xa := #CIn.Manager.NextTarget_XStart, Xb := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") // Caso 2 = Area saldatura dentro al pezzo
	                AND
	                "M_CmpGTE"(Xa := #CIn.Manager.NextTarget_XEnd, Xb := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE")
	                )
	                OR (
	                "M_CmpGTE"(Xa :=#CIn.Manager.NextTarget_XStart, Xb := #PersistentValues.WelderReg[#i].PosBegin, MODULE := "MATERIAL_COUNTERS_MODULE") // Caso 3 = Testa pezzo dentro area saldatura
	                AND
	                "M_CmpLTE"(Xa := #CIn.Manager.NextTarget_XStart, Xb := #PersistentValues.WelderReg[#i].PosEnd, MODULE := "MATERIAL_COUNTERS_MODULE")
	                )
	                )
	                AND
	                #PersistentValues.WelderReg[#i].Valid
	            THEN
	                #COut.Manager.NextTarget_P_ID := #CIn.Manager.NextTarget_P_ID;
	                #COut.Manager.NextTarget_WeldPresence := TRUE;
	                
	                IF "M_CmpGTE"(Xa := #PersistentValues.WelderReg[#i].PosEnd, Xb := #COut.Manager.NextTarget_WeldEndPos, MODULE := "MATERIAL_COUNTERS_MODULE") OR
	                    #COut.Manager.NextTarget_WeldEndPos = -1.0
	                THEN
	                    #COut.Manager.NextTarget_WeldEndPos := #PersistentValues.WelderReg[#i].PosEnd;
	                END_IF;
	                
	            END_IF;
	        END_FOR;
	        
	    END_IF;
	    
	END_REGION
	    
	//Presenza allarmi
	#Sts.AlarmsPresence := #WeldMesInp.MeasuringSts.AlarmPresence;
	//Presenza warning
	#Sts.WarningsPresence := #Warnings.NoAutReady;
	
	//Aggiorna stato macchina per zona
	#MachineInterface.Aborting := #Sts.AlarmsPresence;
	#MachineInterface.AutReady := #AreaInterface.Aut AND NOT #Sts.AlarmsPresence;
	#MachineInterface.MotionsStandStill := TRUE;
	#MachineInterface.AckStopInPhase := #AreaInterface.StopInPhase;
	#MachineInterface.AckStopProgrammed := #AreaInterface.StopProgrammed;
	#MachineInterface.AlarmsPresence := #Sts.AlarmsPresence;
	#MachineInterface.WarningPresence := #Sts.WarningsPresence;
	
	// Warning not Aut ready
	IF #AreaInterface.CheckAutReady AND NOT #MachineInterface.AutReady
	THEN
	    #Warnings.NoAutReady := TRUE;
	END_IF;
	
	
	
	//Coordination Out
	#COut.WeldDoneAck := #CIn.WeldDone;
	    
	
	    
END_FUNCTION_BLOCK

