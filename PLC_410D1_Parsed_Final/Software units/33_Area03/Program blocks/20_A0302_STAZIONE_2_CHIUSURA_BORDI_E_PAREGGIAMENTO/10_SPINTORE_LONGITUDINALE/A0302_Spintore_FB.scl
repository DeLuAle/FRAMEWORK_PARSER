// Block: A0302_Spintore_FB
// Title: Reset allarmi 

FUNCTION_BLOCK "A0302_Spintore_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Reset allarmi 
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI_Feed : udt_DeviceSafetyInterface;
      DSI_Valve : udt_DeviceSafetyInterface;
      Drive : TAx_DriveInterface;
      DataIn : Struct
         OP : OP_PB;
         P5 : Struct
            Orz_AnalSens : Int;
            FTC_FuoriIngombro_A0301 : Bool;
         END_STRUCT;
      END_STRUCT;
      Cin : Struct
         Manager : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            REST_Req : Bool;
            WORK_Req : Bool;
            Rest : Bool;
            Work : Bool;
         END_STRUCT;
         SemiAut_Pb : Bool;
         P4 : Struct
            Fermi : ValveMachine_COut;
         END_STRUCT;
         P5 : Struct
            "En/Dis_SpinLat_2" : Bool;
            QuotaIngombro_SpinLat2 : Real;
            QuotaIngombro_SpinLat1 : Real;
            Spintore_Lat : Struct
               Spin_Lat1 : Struct
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Rest : Bool;
                  Work : Bool;
               END_STRUCT;
               Spin_Lat2 : Struct
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Rest : Bool;
                  Work : Bool;
               END_STRUCT;
               Vrt_1 : ValveMachine_COut;
               Orz_1 : ValveMachine_COut;
               Vrt_2 : ValveMachine_COut;
               Orz_2 : ValveMachine_COut;
               Sollevatori : ValveMachine_COut;
            END_STRUCT;
         END_STRUCT;
         Trasporto : SpeedMachine_COut;
         Bordatrice : Struct
            Ax : Positioning_EPOS_Machine_COut;
            TargetVel : LReal;
            Perc_Vel : LReal;
            Sens : Struct
               FTC_Uscita : Bool;
            END_STRUCT;
         END_STRUCT;
      END_STRUCT;
      Config : Struct
         Ax : Positioning_EPOS_Machine_Config_NEW;
         Vrt : ValveMachine_Config;
         Orz : ValveMachine_Config;
         SpintoreLat : Struct
            QuotaIngombro_SpinLat2 : Real;
            QuotaIngombro_SpinLat1 : Real;
         END_STRUCT;
         Bordatrice : Struct
            QuotaIngresso : Real;
         END_STRUCT;
         DelayMissingCondition : Time;
      END_STRUCT;
      HWID_Ax_TEL111 : HW_SUBMODULE;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      DataOut : Positioning_EPOS_Machine_DataOut;
      COut : Struct
         Ax_Sts : Struct
            PosAttesa_Reached : Bool;
            PosFineSpinta_Reached : Bool;
         END_STRUCT;
         Ax : Positioning_EPOS_Machine_COut;
         Spintore : ValveMachine_COut;
         Vrt : ValveMachine_COut;
         Orz : ValveMachine_COut;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         Sens : Analogic_SensorManagement_Par;
      END_STRUCT;
      Data : Struct
         Sens : Analogic_SensorManagement_Data;
         HMI : HMI_Preset;
         Ax_Pos : A0301_Mach_Ax_Pos_Data;
      END_STRUCT;
      Par_Mach : A0301_Mach_Sens_Par;
      Par_Ax_Manu : Positioning_EPOS_Machine_Par;
      Pers_Data : Struct
         EncoderAbsolute_Preset_OK : Bool;
         Persistent_ActualPosition : LReal;
      END_STRUCT;
      Par_Ax_Auto : A0301_Mach_Speed_Par;
   END_VAR

   VAR
      Alarm : Struct
         Ax : Positioning_EPOS_Machine_Alr;
         Ax_NeedPreset : Bool;
         Vrt : ValveAlr;
         Orz : ValveAlr;
         Orz_AnalSens_Issue : Bool;
         Orz_AnalSens_Compressed : Bool;
      END_STRUCT;
      Warning : Struct
         Ax : Positioning_EPOS_Machine_Wng;
         Vrt : ValveMachine_Wng;
         Orz : ValveMachine_Wng;
         Orz_AnalSens : Analogic_SensorManagement_Warning;
         OP_REST_MissingCnd : Bool;
         OP_WORK_MissingCnd : Bool;
      END_STRUCT;
      Sts : Struct
         ReadyForMove : Bool;
         OP_CanMoveFreely : Bool;
         OP_Ax_Rest_Cnd : Bool;
         OP_Ax_Work_Cnd : Bool;
         OP_Spin_Rest_Cnd : Bool;
         OP_Spin_Work_Cnd : Bool;
         A0301_Beam_BLean : Real;
         A0302_Beam_BLean : Real;
         Vrt_Work_ExtEnable : Bool;
         Orz_Work_ExtEnable : Bool;
      END_STRUCT;
      Ctrl : Struct
         SpinVrtOrz : Struct
            OP_Rest_Man : Bool;
            OP_Work_Man : Bool;
            OP_Rest_Aut : Bool;
            OP_Work_Aut : Bool;
            OP_Rest : Bool;
            OP_Work : Bool;
         END_STRUCT;
         Ax : Struct
            OP_Rest_Man : Bool;
            OP_Work_Man : Bool;
            OP_Rest_Aut : Bool;
            OP_Work_Aut : Bool;
            OP_Rest : Bool;
            OP_Work : Bool;
            Vel : LReal;
            VelMax : Real;
            Dec : LReal;
         END_STRUCT;
      END_STRUCT;
      HMI : Struct
         Ax : AnalogSens_HmiData;
         Orz_AnalSens_PB_Preset : Bool;
         Orz_AnalSens_Preset_Value : LReal;
      END_STRUCT;
      Ax : Positioning_EPOS_Machine_FB_NEW;
      Vrt : ValveMachine_FB;
      Orz : ValveMachine_FB;
      Orz_AnalSens : Analogic_SensorManagement;
      ValueBLeanOvr : Array[1..15] of Real;
      IEC : Struct
         TON_DelayFTC_Ingombro_A0301 : IEC_TIMER;
         TOF_DelayFTC_Ingombro_A0301 : IEC_TIMER;
         FTC_On : Bool;
      END_STRUCT;
      AUX : Struct
         OP_Rest_PB : Bool;
         OP_Work_PB : Bool;
      END_STRUCT;
      TON_OP_REST_MissingCnd : TON_TIME;
      TON_OP_WORK_MissingCnd : TON_TIME;
      BTrk_Item : Struct
         BLean : Real;
         O_ID : DInt;
      END_STRUCT;
   END_VAR

   VAR_TEMP
      i : Int;
      DecMax : LReal;
      Orz_SpazioSafe : LReal;
      Calcoli : Struct
         SUB_SpinLat2 : LReal;
         SUB_SpinLat1 : LReal;
         Pos_Target_2 : LReal;
         Pos_Target_1 : LReal;
         Ax_Target : LReal;
      END_STRUCT;
      PE : Struct
         OP_Rest_PB : Bool;
         OP_Work_PB : Bool;
      END_STRUCT;
      BTrk_GetData_A0302 : Struct
         indx : Int;
         Sts : Int;
         Item : Prod_Item_small;
      END_STRUCT;
      BTrk_GetData_A0301 : Struct
         indx : Int;
         Sts : Int;
         Item : Prod_Item_small;
      END_STRUCT;
      Stop_Ax_SpinLong : Bool;
      GetData_A0301_B : Bool;
      GetData_A0302_In : Bool;
   END_VAR

   VAR CONSTANT
      Offset_SpinLong_To_SpinLat2 : Real;
      Offset_SpinLong_To_SpinLat1 : Real;
   END_VAR


BEGIN
   REGION "Reset allarmi"
      IF AreaInterface.RstAlarms THEN
          Alarm.Orz_AnalSens_Issue := FALSE;
          Warning.Orz_AnalSens.SignalError := FALSE;
      END_IF;

   END_REGION

   REGION "CONTROLLO MES lunghezza Beams"
      "Find_O_ID"(
         en := GetData_A0302_In,
         NumStazione := #STATION_A0302_ENTRY,
         O_ID => BTrk_Item.O_ID
      );

      "Prod_item_GetData_By_O_ID"(
         en := TRUE,
         O_ID := BTrk_Item.O_ID,
         Beams_Data := Areas_ITF.Prod.A03_A04.Beams_Data,
         Ret_Val => BTrk_GetData_A0302.Sts,
         Item => BTrk_GetData_A0302.Item,
         indx => BTrk_GetData_A0302.indx
      );

      "Find_O_ID"(
         en := TRUE,
         NumStazione := #STATION_A0301_B,
         O_ID => BTrk_Item.O_ID
      );

      "Prod_item_GetData_By_O_ID"(
         en := TRUE,
         O_ID := BTrk_Item.O_ID,
         Beams_Data := Areas_ITF.Prod.A03_A04.Beams_Data,
         Ret_Val => BTrk_GetData_A0301.Sts,
         Item => BTrk_GetData_A0301.Item,
         indx => BTrk_GetData_A0301.indx
      );

      GetData_A0302_In := ((BTrk.A0302_ENTRY.B.B_ID <> 0) OR (BTrk.A0302_ENTRY.B.B_ID <> 0) OR (BTrk.A0302_ENTRY.B.B_ID <> 0));
      IF GetData_A0302_In THEN
         "Find_O_ID"(NumStazione := #STATION_A0302_ENTRY);
      END_IF;
      BTrk_GetData_A0302.Sts := "Prod_item_GetData_By_O_ID"(O_ID := BTrk_Item.O_ID, Beams_Data := Areas_ITF.Prod.A03_A04.Beams_Data);
      IF (GetData_A0302_In AND (BTrk_GetData_A0302.Sts >= 0)) THEN
         Sts.A0302_Beam_BLean := BTrk_GetData_A0302.Item.Beams_Len;
      END_IF;
      "Find_O_ID"(NumStazione := #STATION_A0301_B);
      BTrk_GetData_A0301.Sts := "Prod_item_GetData_By_O_ID"(O_ID := BTrk_Item.O_ID, Beams_Data := Areas_ITF.Prod.A03_A04.Beams_Data);
   END_REGION

   REGION "CALCOLI - Posizioni Attesa / Spinta per lavoro Spintore"

      BTrk_GetData_A0302.Item.O_ID := BTrk_GetData_A0302.Item.O_ID;
      BTrk_Item.BLean:=BTrk_GetData_A0302.Item.Beams_Len;
      // ***********************************************************************************************************
      // 
      REGION POSIZIONE ATTESA PEZZO IN ENTRATA
          
          // Se ho una misura traking vado in posizionamento calcolando la misura del Beams più alta + Offset sennò vado indietro fino a pos. minima
          IF Sts.A0301_Beam_BLean <> 0 THEN
              Data.Ax_Pos.PosAttesa := (Ax.COut.MaxPosition -Sts.A0301_Beam_BLean) - (Data.Ax_Pos.OffsetPosAttesa - Config.Bordatrice.QuotaIngresso);
          ELSIF Sts.OP_CanMoveFreely THEN
              BTrk_Item.BLean := 0;
              Data.Ax_Pos.PosAttesa := ( Ax.COut.MinPosition) + Data.Ax_Pos.OffsetPosAttesa;
          END_IF;
          
      END_REGION ;
      //
      // ***********************************************************************************************************
      // 
      REGION POSIZIONE FINE SPINTA PEZZO IN USCITA
          
          // CALCOLO Pos.Fine Spinta Target finale
          IF Sts.A0302_Beam_BLean <> 0 THEN
              Data.Ax_Pos.PosFineSpinta := (Ax.COut.MaxPosition - Sts.A0302_Beam_BLean) + (Config.Bordatrice.QuotaIngresso);
          ELSIF BTrk_Item.BLean = 0 THEN
              Data.Ax_Pos.PosFineSpinta := (Ax.COut.MaxPosition - Data.Ax_Pos.OffsetPosAttesa);
          END_IF;
          
          //
          // CALCOLO differenza tra Pos.Attesa e Quota ingombro Spintore laterale 2 SE incluso 
          IF #Cin.P5."En/Dis_SpinLat_2"
              AND #Ax.COut.ActualPosition < (#Config.SpintoreLat.QuotaIngombro_SpinLat2 +  #Config.SpintoreLat.OffsetPosAttesa) THEN
              #Calcoli.SUB_SpinLat2 :=((#Data.Ax_Pos.PosAttesa) + (#Config.SpintoreLat.QuotaIngombro_SpinLat2));
          END_IF;
          
          // CALCOLO differenza tra Pos.Attesa e Quota ingombro Spintore laterale 1 
          IF #Ax.COut.ActualPosition > #Config.SpintoreLat.QuotaIngombro_SpinLat1 THEN
              #Calcoli.SUB_SpinLat1 :=((#Data.Ax_Pos.PosAttesa) + (#Config.SpintoreLat.QuotaIngombro_SpinLat1));
          END_IF;
          
          // CALCOLI Posizioni Target SPINTORI LATERALI
          #Calcoli.Pos_Target_2 := (#Data.Ax_Pos.PosAttesa) + (#Calcoli.SUB_SpinLat2);
          #Calcoli.Pos_Target_1 := (#Data.Ax_Pos.PosAttesa) + (#Calcoli.SUB_SpinLat1);
          
          // SPINTORE LATERALE 1&2 - AX - POS. Target
          IF #Cin.P5."En/Dis_SpinLat_2"
              AND #Data.Ax_Pos.PosFineSpinta >= #Calcoli.Pos_Target_2 THEN
              #Calcoli.Ax_Target := #Calcoli.Pos_Target_2;
          ELSIF #Data.Ax_Pos.PosFineSpinta >= #Calcoli.Pos_Target_1
              AND #Ax.COut.ActualPosition < (-#Config.SpintoreLat.QuotaIngombro_SpinLat2) THEN
              #Calcoli.Ax_Target := #Calcoli.Pos_Target_1;
          ELSIF #Ax.#COut.ActualPosition < (-#Config.SpintoreLat.QuotaIngombro_SpinLat1) THEN
              #Calcoli.Ax_Target := #Data.Ax_Pos.PosFineSpinta;
          END_IF;
          
          
      END_REGION ;
      //
      // ***********************************************************************************************************   

   END_REGION

   REGION "[Spintore] DataIn - FTC Fuori ingombro Spintore"
      #IEC.TON_DelayFTC_Ingombro_A0301(
         IN := DataIn.P5.FTC_FuoriIngombro_A0301,
         PT := T#700MS
      );

      #IEC.TOF_DelayFTC_Ingombro_A0301(
         IN := IEC.TON_DelayFTC_Ingombro_A0301.Q,
         PT := T#1S
      );

      #IEC.TON_DelayFTC_Ingombro_A0301.Q;
      #IEC.TOF_DelayFTC_Ingombro_A0301.Q;
      IEC.FTC_On := #IEC.TOF_DelayFTC_Ingombro_A0301.Q;
   END_REGION

   REGION "Operazione può muoversi liberamente perchè non sposta nessun BEAM"
      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0301.B
      );

      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0301.B
      );

      "BTrk_Absence"(
         en := (TRUE OR (((Cin.P4.Fermi.Work AND Cin.P5.Spintore_Lat.Spin_Lat1.Rest) AND Cin.P5.Spintore_Lat.Spin_Lat2.Rest) AND Cin.P5.Spintore_Lat.Sollevatori.Rest)),
         Item := BTrk.A0301.B
      );

      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0301.B
      );

      "BTrk_Absence"(
         en := Sts.OP_CanMoveFreely,
         Item := BTrk.A0301.B
      );

      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0301.B
      );

      "BTrk_Absence"(Item := BTrk.A0301.B);
      Sts.OP_CanMoveFreely := TRUE;
      Sts.OP_CanMoveFreely := NOT (IEC.FTC_On);
   END_REGION

   REGION "Ax  - Comando Operazione Lavoro / Riposo (AUT)"
      Ctrl.Ax.OP_Rest_Aut := (Cin.Manager.Control_ON AND Cin.Manager.Rest);
      Ctrl.Ax.OP_Work_Aut := (Cin.Manager.Control_ON AND Cin.Manager.Work);
   END_REGION

   REGION "Ax  - Comando Operazione Lavoro / Riposo (MAN)"
      PE.OP_Rest_PB := PosEdge(DataIn.OP.Rest);
      PE.OP_Work_PB := PosEdge(DataIn.OP.Work);
      Ctrl.Ax.OP_Rest_Man := (((((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND PE.OP_Rest_PB) OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Ctrl.Ax.OP_Rest_Man)) AND DataIn.OP.Rest) AND NOT (DataIn.OP.Work));
      Ctrl.Ax.OP_Work_Man := (((((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND PE.OP_Work_PB) OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Ctrl.Ax.OP_Work_Man)) AND DataIn.OP.Work) AND NOT (DataIn.OP.Rest));
   END_REGION

   REGION "Ax - Cumulativo Operazione Lavoro / Riposo (ALL)"
      Ctrl.Ax.OP_Rest := NOT ((NOT (Ctrl.Ax.OP_Rest_Man) AND NOT (Ctrl.Ax.OP_Rest_Aut)));
      Ctrl.Ax.OP_Work := NOT ((NOT (Ctrl.Ax.OP_Work_Man) AND NOT (Ctrl.Ax.OP_Work_Aut)));
   END_REGION

   REGION "Ax - Condizioni movimento Operazione a Lavoro / Riposo"
      Sts.OP_Ax_Rest_Cnd := (Cin.Manager.Rest OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Sts.OP_Ax_Work_Cnd := (Cin.Manager.Work OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "SpinVrtOrz  - Comando Operazione Lavoro / Riposo (AUT)"
      Ctrl.SpinVrtOrz.OP_Rest_Aut := (Cin.Manager.Control_ON AND Cin.Manager.REST_Req);
      Ctrl.SpinVrtOrz.OP_Work_Aut := (Cin.Manager.Control_ON AND Cin.Manager.WORK_Req);
   END_REGION

   REGION "SpinVrtOrz  - Comando Operazione Lavoro / Riposo (MAN)"
      PE.OP_Rest_PB := PosEdge(DataIn.OP.Rest);
      PE.OP_Work_PB := PosEdge(DataIn.OP.Work);
      Ctrl.SpinVrtOrz.OP_Rest_Man := (((((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND PE.OP_Rest_PB) OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Ctrl.SpinVrtOrz.OP_Rest_Man)) AND DataIn.OP.Rest) AND NOT (DataIn.OP.Work));
      Ctrl.SpinVrtOrz.OP_Work_Man := (((((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND PE.OP_Work_PB) OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Ctrl.SpinVrtOrz.OP_Work_Man)) AND DataIn.OP.Work) AND NOT (DataIn.OP.Rest));
   END_REGION

   REGION "SpinVrtOrz - Cumulativo Operazione Lavoro / Riposo (ALL)"
      Ctrl.SpinVrtOrz.OP_Rest := NOT ((NOT (Ctrl.SpinVrtOrz.OP_Rest_Man) AND NOT (Ctrl.SpinVrtOrz.OP_Rest_Aut)));
      Ctrl.SpinVrtOrz.OP_Work := NOT ((NOT (Ctrl.SpinVrtOrz.OP_Work_Man) AND NOT (Ctrl.SpinVrtOrz.OP_Work_Aut)));
   END_REGION

   REGION "SpinVrtOrz - Condizioni movimento Operazione a Lavoro / Riposo"
      Sts.OP_Spin_Rest_Cnd := (Cin.Manager.REST_Req OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Sts.OP_Spin_Work_Cnd := (Cin.Manager.WORK_Req OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Verticale + Orizzontale + Ax -  Cin Manager (Esecuzione sequenza comandi)"
      Ax.CIn.Manager.Control_ON:= Cin.Manager.Control_ON;
      Orz.Cin.Manager.Control_ON := Vrt.Cin.Manager.Control_ON := Cin.Manager.Control_ON;
       
       
      Vrt.Cin.Manager.Rest := FALSE;
      Vrt.Cin.Manager.Work := FALSE;
      Orz.Cin.Manager.Rest := FALSE;
      Orz.Cin.Manager.Work := FALSE;
      Ax.CIn.Manager.MoveToPos := FALSE;
          

      // Operazione riposo del cilindro verticale ed orizzontale sullo spintore
      IF (Ctrl.SpinVrtOrz.OP_Rest OR Cin.Manager.REST_Req) AND Sts.OP_Spin_Rest_Cnd THEN
          
          Orz.Cin.Manager.Rest := Orz.COut.Rest := TRUE;
          Vrt.Cin.Manager.Rest := Vrt.COut.Rest := Orz.COut.Rest;
          
          // Operazione lavoro del cilindro verticale ed orizzontale sullo spintore   
      ELSIF (Ctrl.SpinVrtOrz.OP_Work OR Cin.Manager.WORK_Req) AND Sts.OP_Spin_Work_Cnd THEN
          
          Vrt.Cin.Manager.Work := Vrt.COut.Work := TRUE;
          Orz.Cin.Manager.Work := Vrt.Cin.Manager.Work;
          
      END_IF;

      // Operazione arresto dell' asse spintore quando i 2 ciclindri sono in riposo
      IF Ctrl.Ax.OP_Rest AND Sts.OP_Ax_Rest_Cnd THEN
          Ax.CIn.Manager.Pos := Data.Ax_Pos.PosAttesa;
          Ax.CIn.Manager.Vel := Par_Ax_Auto.Aut_Vel;
          Ax.CIn.Manager.Acc := Par_Ax_Auto.Aut_Acc;
          Ax.CIn.Manager.Dec := Par_Ax_Auto.Aut_Dec;
          Ax.CIn.Manager.MoveToPos := TRUE;
          
          // Se raggiungo la pos.attesa spengo il comando
      ELSIF Ctrl.Ax.OP_Rest AND Sts.OP_Ax_Rest_Cnd AND COut.Ax_Sts.PosAttesa_Reached THEN
          Ax.CIn.Manager.MoveToPos := Ax.CIn.Manager.Control_ON := FALSE;
          
      END_IF;

      // Operazione lavoro dell' asse spintore quando i 2 ciclindri sono in lavoro
      IF Ctrl.Ax.OP_Work AND Sts.OP_Ax_Work_Cnd AND Vrt.COut.Work AND Orz.COut.Work
           AND NOT Alarm.Orz_AnalSens_Compressed THEN
          Ax.CIn.Manager.Pos := Data.Ax_Pos.PosFineSpinta;
          Ax.CIn.Manager.Vel := Par_Ax_Auto.Aut_Vel;
          Ax.CIn.Manager.Acc := Par_Ax_Auto.Aut_Acc;
          Ax.CIn.Manager.Dec := Par_Ax_Auto.Aut_Dec;
          Ax.CIn.Manager.MoveToPos := TRUE;
          
         // Se raggiungo la pos. o il sensore viene compresso disabilito la spinta 
      ELSIF (Ctrl.Ax.OP_Work AND Sts.OP_Ax_Work_Cnd) AND COut.Ax_Sts.PosFineSpinta_Reached THEN
          Ax.CIn.Manager.MoveToPos := FALSE;
          
      ELSIF (Ctrl.Ax.OP_Work AND Sts.OP_Ax_Work_Cnd) AND Alarm.Orz_AnalSens_Compressed THEN
          Ax.CIn.Manager.MoveToPos := FALSE;
          
      END_IF;
          

   END_REGION

   REGION "Verticale + Orizzontale + Ax - CIn Abilitazioni Stop Manager"
      Vrt.Cin.Manager.EnableStopDoorOpeningReq := Orz.Cin.Manager.EnableStopDoorOpeningReq
      := Ax.CIn.Manager.EnableStopDoorOpeningReq := Cin.Manager.EnableStopDoorOpeningReq;

      Vrt.Cin.Manager.EnableStopInPhase := Orz.Cin.Manager.EnableStopInPhase
      := Ax.CIn.Manager.EnableStopInPhase := Cin.Manager.EnableStopInPhase;

      Vrt.Cin.Manager.EnableStopProgrammed := Orz.Cin.Manager.EnableStopProgrammed
      := Ax.CIn.Manager.EnableStopProgrammed := Cin.Manager.EnableStopProgrammed;

   END_REGION

   REGION "Warning manacanza condizioni esecuzione Operazione RIPOSO / LAVORO"
      #TON_OP_REST_MissingCnd(
         IN := Ctrl.Ax.OP_Rest,
         PT := Config.DelayMissingCondition
      );

      #TON_OP_WORK_MissingCnd(
         IN := Ctrl.Ax.OP_Work,
         PT := Config.DelayMissingCondition
      );

      #TON_OP_REST_MissingCnd.Q;
      IF (Sts.OP_Ax_Rest_Cnd OR Ctrl.Ax.OP_Work OR AreaInterface.RstAlarms) THEN
         Warning.OP_REST_MissingCnd := FALSE;
      ELSIF #TON_OP_REST_MissingCnd.Q THEN
         Warning.OP_REST_MissingCnd := TRUE;
      END_IF;
      #TON_OP_WORK_MissingCnd.Q;
      IF (Sts.OP_Ax_Work_Cnd OR Ctrl.Ax.OP_Rest OR AreaInterface.RstAlarms) THEN
         Warning.OP_WORK_MissingCnd := FALSE;
      ELSIF #TON_OP_WORK_MissingCnd.Q THEN
         Warning.OP_WORK_MissingCnd := TRUE;
      END_IF;
   END_REGION

   REGION "<< RIFERIMENTI [Spintore Ax] - Positioning Manager >>"
      // ******************************************************************************************
      REGION // TRASFERIMENTO DELLE RAMPE
          
          // Rampe in Automatico o Semi-Automatico
          IF AreaInterface.Aut AND NOT Cin.SemiAut_Pb THEN
              Ax.CIn.Manager.Acc := Par_Ax_Auto.Aut_Acc;
              Ax.CIn.Manager.Dec := Par_Ax_Auto.Aut_Dec;
          ELSIF Cin.SemiAut_Pb THEN
              Ax.CIn.Manager.Acc := Par_Ax_Auto.Aut_Acc;
              Ax.CIn.Manager.Dec := Par_Ax_Auto.Aut_Dec;
          END_IF;
          
          // Rampe in Manuale
          IF AreaInterface.Man AND NOT Cin.SemiAut_Pb THEN
              Ax.CIn.Manager.Acc := Par_Ax_Manu.Man_Acc;
              Ax.CIn.Manager.Dec := Par_Ax_Manu.Man_Dec;
          END_IF;
      END_REGION

      // ******************************************************************************************
      REGION // // CALCOLO DELLA VELOCITA' TRASFERITA AL DRIVE IN BASE AL CALCOLO DEL CICLINDRO COMPENSATORE
          //
      #Sts.ResiduoCilindro := #CorsaCilindro - #Sts.PosCilindro;

      #Sts.spazio_frenata := ((#Ctrl.Vel / 60.0) ** 2.0) /(2.0 * #Ctrl.Dec);

      #SpazioSafe := #Sts.spazio_frenata + #Par.CylComp_SafeResidual;

      #Ctrl.StopSicurezza := (#Sts.ResiduoCilindro - #SpazioSafe) < 0.0;

      // bisogna calcolare la decelerazione massima per rispettare frenata
      // 
      #Sts.DecMassima := ((#Ctrl.Vel / 60.0) ** 2.0) / (2 * (#Sts.ResiduoCilindro - #Par.CylComp_SafeResidual));

          
          // Velocità asse in base alla velocità della chiudi bordi..
          Ctrl.Ax.Vel := Cin.Bordatrice.TargetVel * Cin.Bordatrice.Perc_Vel / 100.0;
          
          // Limite decellerazione dell'asse
          DecMax := (Ax.Config.Ax.MaxDec_S120_P2573 / 1000.0);
          
      //// Spazio di frenata da raggiungere
      // 
      #SpazioSafe := #CorsaCilindroCompensatore - #Par.Spintore.Compensatore_SpazioResiduoExtra;

          
          // Nuovo valore di velocità per limitare e rispettare spazio di arresto con massima decelerazione possibile
          // 
          Ctrl.Ax.VelMax := (IN:= (60.0 * ((2.0 * DecMax * Orz_SpazioSafe))));
          
          // Limitazione della velocità per rispettare lo spazio di frenata   
          Ctrl.Ax.Vel := (IN1 := Ctrl.Ax.Vel, IN2 := Ctrl.Ax.VelMax);
          
      END_REGION ;

      // *****************************************************************************************
      REGION // CALCOLO DELLA VELOCITA' E TRASFERIMENTO IN BASE ALLO STATO IMPIANTO
          //
          IF NOT Ax.CIn.Manager.Control_ON THEN
              // CALCOLO VELOCITA' IN BASE ALL'OVERIDE
              IF Ax.AreaInterface.Aut THEN
                  Ax.CIn.Manager.Vel := Ctrl.Ax.Vel;
              ELSIF Cin.SemiAut_Pb THEN
                  Ax.CIn.Manager.Vel := (Par_Ax_Auto.SemiAut_Vel * Ctrl.Ax.Vel);
              END_IF;
          END_IF;
      END_REGION ;

   END_REGION

   REGION "[Ax] -  Cin External alarm"
      Ax.CIn.ExternalAlarms := FALSE;
   END_REGION

   REGION "[Ax] -  Cin Ext Enable"
      Ax.CIn.Minus_ExtEnable := TRUE;
      Stop_Ax_SpinLong := ((((COut.Vrt.Work AND (COut.Ax.ActualPosition > Cin.P5.QuotaIngombro_SpinLat2)) AND A0301_Spintore_Lat.Sts.En/Dis_SpinLat_2) AND NOT (Cin.P5.Spintore_Lat.Orz_2.Rest)) OR ((COut.Vrt.Work AND (COut.Ax.ActualPosition > Cin.P5.QuotaIngombro_SpinLat1)) AND NOT (Cin.P5.Spintore_Lat.Orz_1.Rest)));
      Ax.CIn.Plus_ExtEnable := ((((COut.Vrt.Work AND NOT (Alarm.Orz_AnalSens_Compressed)) AND NOT (Cin.Bordatrice.Ax.Standstill)) AND NOT (Stop_Ax_SpinLong)) OR NOT (COut.Vrt.Work) OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "[Ax] HMI preset position"
      Ax.HMI.B_Preset := HMI.Ax.PbPreset;
      Ax.HMI.PresetPosition := HMI.Ax.PresetValue;
   END_REGION

   REGION "[Ax] Spintore - Positioning Manager"
      #Ax(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Feed,
         Drive := Drive,
         Config := Config.Ax,
         HW_ID_TEL111 := HWID_Ax_TEL111,
         Par := Par_Ax_Manu,
         Pers_Data := Pers_Data,
         Warning := Warning.Ax,
         Alarm := Alarm.Ax,
         DataOut => DataOut,
         COut => COut.Ax
      );

      #Ax.Q;
   END_REGION

   REGION "[Ax] Spintore - Status / Control - Pos. Attesa"
      "TolWindow"(
         en := TRUE,
         ActPos := A0302_Spintore.COut.Ax.ActualPosition,
         Target := Data.Ax_Pos.PosAttesa,
         PosWin := 1.0,
         Ret_Val => COut.Ax_Sts.PosAttesa_Reached
      );

      COut.Ax_Sts.PosAttesa_Reached := "TolWindow"(ActPos := A0302_Spintore.COut.Ax.ActualPosition, Target := Data.Ax_Pos.PosAttesa, PosWin := 1.0);
   END_REGION

   REGION "[Ax] Spintore - Status / Control - Pos. Spinta"
      "TolWindow"(
         en := TRUE,
         ActPos := A0302_Spintore.COut.Ax.ActualPosition,
         Target := Data.Ax_Pos.PosFineSpinta,
         PosWin := 1.0,
         Ret_Val => COut.Ax_Sts.PosFineSpinta_Reached
      );

      COut.Ax_Sts.PosFineSpinta_Reached := "TolWindow"(ActPos := A0302_Spintore.COut.Ax.ActualPosition, Target := Data.Ax_Pos.PosFineSpinta, PosWin := 1.0);
   END_REGION

   REGION "[VRT] - CIn External alarm"
      Vrt.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "[VRT] - Cin Ext Enable"
      Vrt.Cin.Rest_ExtEnable := (TRUE OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Vrt.Cin.Work_ExtEnable := (TRUE OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "[VRT] - Valve Manager"
      #Vrt(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Vrt,
         Alarm := Alarm.Vrt,
         Warning := Warning.Vrt,
         COut => COut.Vrt
      );

      #Vrt.Q;
   END_REGION

   REGION "[ORZ] - Scalatura sensore"
      #Orz_AnalSens(
         en := TRUE,
         Preset_Conditions := AreaInterface.Man,
         AnalogSensor := DataIn.P5.Orz_AnalSens,
         Standstill_Delay := T#10MS,
         Filter_Tau := T#10MS,
         Par := Par.Sens,
         Data := Data.Sens,
         HMI := Data.HMI,
         Warning := Warning.Orz_AnalSens
      );

      #Orz_AnalSens.Q;
   END_REGION

   REGION "[ORZ] - Allarme problemi sul sensore analogico"
      IF (((NOT ((NOT (Warning.Orz_AnalSens.PresetNeed) AND NOT (Warning.Orz_AnalSens.SignalError))) AND Cin.Manager.Control_ON) OR (NOT ((NOT (Warning.Orz_AnalSens.PresetNeed) AND NOT (Warning.Orz_AnalSens.SignalError))) AND AreaInterface.Aut) OR ((NOT ((NOT (Warning.Orz_AnalSens.PresetNeed) AND NOT (Warning.Orz_AnalSens.SignalError))) AND NOT (Sts.OP_CanMoveFreely)) AND COut.Ax.MinusCheckNext) OR ((NOT ((NOT (Warning.Orz_AnalSens.PresetNeed) AND NOT (Warning.Orz_AnalSens.SignalError))) AND NOT (Sts.OP_CanMoveFreely)) AND COut.Ax.PlusCheckNext)) AND Sys.ByPass) THEN
         Alarm.Orz_AnalSens_Issue := TRUE;
      END_IF;
      IF TRUE THEN
         Alarm.Orz_AnalSens_Issue := FALSE;
      END_IF;
   END_REGION

   REGION "[ORZ] - Calcolo range lavoro sensore"
          // ********************************************************************************************************************************************
          // Calcolo lo spazio di sicurezza se ho eseguito il preset del sensore
          // Spazio di frenata da raggiungere
          
          IF Par.Sens.Enable THEN
              IF Data.Sens.OffsetValid THEN
                  Orz_SpazioSafe := Par.Sens.RangeHigh - Par_Mach.Tol_Work  ;
              END_IF;
              
              // Controllo finestra di lavoro del sensore, dato il valore di lavoro sicuro,se è inferiore sino in compressione sul pezzo.  
              IF  Data.Sens.OffsetValid AND Orz_SpazioSafe <> 0 AND 
                  (Orz_AnalSens.ScaleValue < (Par.Sens.RangeHigh - Orz_SpazioSafe)) THEN
                  Alarm.Orz_AnalSens_Compressed := 1;
              ELSE
                  Alarm.Orz_AnalSens_Compressed := 0;
              END_IF;
          END_IF;
          

   END_REGION

   REGION "[ORZ] - CIn External alarm"
      Orz.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "[ORZ] - Cin Ext Enable"
      Orz.Cin.Rest_ExtEnable := (TRUE OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Orz.Cin.Work_ExtEnable := (TRUE OR ((AreaInterface.Man AND NOT (Cin.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "[ORZ] - Valve Manager"
      #Orz(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Orz,
         Alarm := Alarm.Orz,
         Warning := Warning.Orz,
         COut => COut.Orz
      );

      #Orz.Q;
   END_REGION

   REGION "Stazione COut"
      // VALVOLE SPINTORE
      COut.Spintore.Standstill := Vrt.COut.Standstill AND Orz.COut.Standstill;
      COut.Spintore.Rest_CheckNext := Ctrl.Ax.OP_Rest AND Ctrl.SpinVrtOrz.OP_Rest;
      COut.Spintore.Work_CheckNext := Ctrl.Ax.OP_Work AND Ctrl.SpinVrtOrz.OP_Work ;
      COut.Spintore.Rest := Vrt.COut.Rest AND Orz.COut.Rest;
      COut.Spintore.Work := Vrt.COut.Work AND Orz.COut.Work;

      // SPINTORE LONGITUDINALE
      COut.Ax := Ax.COut;
      COut.Vrt := Vrt.COut;
      COut.Orz := Orz.COut;

   END_REGION

   REGION "Machine interface"
      "MachineInterface_2_To_1"(
         en := TRUE,
         MachineInterface_1 := Ax.MachineInterface,
         MachineInterface_2 := Vrt.MachineInterface,
         AdditionalAlarms := FALSE,
         AdditionalWarnings := FALSE,
         Ret_Val => MachineInterface
      );

      "MachineInterface_2_To_1"(
         en := TRUE,
         AdditionalWarnings := NOT ((NOT (Warning.OP_REST_MissingCnd) AND NOT (Warning.OP_WORK_MissingCnd))),
         MachineInterface_1 := MachineInterface,
         MachineInterface_2 := Orz.MachineInterface,
         AdditionalAlarms := FALSE,
         Ret_Val => MachineInterface
      );

      MachineInterface := "MachineInterface_2_To_1"(MachineInterface_1 := Ax.MachineInterface, MachineInterface_2 := Vrt.MachineInterface, AdditionalAlarms := FALSE, AdditionalWarnings := FALSE);
      MachineInterface := "MachineInterface_2_To_1"(AdditionalWarnings := NOT ((NOT (Warning.OP_REST_MissingCnd) AND NOT (Warning.OP_WORK_MissingCnd))), MachineInterface_1 := MachineInterface, MachineInterface_2 := Orz.MachineInterface, AdditionalAlarms := FALSE);
   END_REGION


END_FUNCTION_BLOCK
