FUNCTION_BLOCK "TIA_PN_FcP5020"
{ S7_Optimized_Access := 'TRUE' ; Published := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Enable : Bool := false;   // Enable the function block
      EnableDrive : Bool := false;   // Enable the drive
      ClearError : Bool := false;   // Reset drive and FB errors
      PressureCmd : Real := 0.0;   // Pressure command value in bar
      MaxSpeedLimit : Real := 0.0;   // Maximum speed limit value in rpm
      InputADDR : HW_IO := 16#0;   // Input address of the drive in hardware configuration
      OutputADDR : HW_IO := 16#0;   // Output address of the drive in hardware configuration
   END_VAR

   VAR_OUTPUT 
      InOperation : Bool := false;   // Function block is in operation
      MotorStarted : Bool := false;   // Motor status
      Error : Bool := false;   // Error active on the EFC / FcP function / function block
      Warning : Bool := false;   // Warning active on the EFC / FcP function
      DiagnosisCode : Word := 16#0;   // Error and warning codes for the EFC / FcP function / function block
      Status : Word := 16#0;   // Status word for the EFC / FcP function / function block
      PressureAct : Real := 0.0;   // Actual pressure value in bar
      SpeedAct : Real := 0.0;   // Actual speed value in rpm
   END_VAR

   VAR 
      fbTON_TIME {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;   // On delay timer
      bMbit0 : Bool := false;   // Internal memory bit
      bMbit1 : Bool := false;   // Internal memory bit
      bMbit2 : Bool := false;   // Internal memory bit
      bMbit3 : Bool := false;   // Internal memory bit
      bEnableRise : Bool := false;   // Internal flag
      bErrorResetFall : Bool := false;   // Internal flag
      bFBErrorFall : Bool := false;   // Internal flag
      bClearErrorRise : Bool := false;   // Internal flag
      stInputData : "FCP_IN";   // Input data structure
      stOutputData : "FCP_OUT";   // Output data structure
      hwInputADDR : HW_IO := 16#0;   // Input copy variable
      hwOutputADDR : HW_IO := 16#0;   // Input copy variable
      iStep : Int := #iIDLE_STEP;   // Current function block step
      iErrorStep : Int := 0;   // Step where last error occurred
      iReturnVal : Int := 0;   // Return value variable
      wReturnVal : Word;   // Copy variable
      bFBErrorPressureCmd : Bool := false;   // Internal flag
      bFBErrorMaxSpeedLimit : Bool := false;   // Internal flag
      bFBErrorDPRD_DPWR : Bool := false;   // Internal flag
      bFcPError : Bool := false;   // Internal flag
      bEFCError : Bool := false;   // Internal flag
      bFcPWarning : Bool := false;   // Internal flag
      bEFCWarning : Bool := false;   // Internal flag
      rPressureCmdInternal : Real := 0.0;   // Internal variable
      rMaxSpeedLimtInternal : Real := 0.0;   // Internal variable
      bInternalRunTrigger : Bool := false;   // Internal flag
      bInternalRun : Bool := false;   // Internal flag
   END_VAR

   VAR CONSTANT 
      iEXIT_STEP : Int := -1;   // Function block step variable
      iIDLE_STEP : Int := 1;   // Function block step variable
      iINIT_STEP : Int := 2;   // Function block step variable
      iOPERATION_STEP : Int := 3;   // Function block step variable
      rPRESSURECMD_MIN : Real := 0.0;   // Minimum value of PressureCmd input
      rPRESSURECMD_MAX : Real := 350.0;   // Maximum value of PressureCmd input
      rPRESSURECMD_DEFAULT : Real := 0.0;   // Default value of PressureCmd input
      rPRESSURECMD_FACTOR : Real := 10.0;   // Multiplication factor for PressureCmd input
      rMAXSPEEDLIMIT_MIN : Real := 0.0;   // Minimum value of MaxSpeedLimit input
      rMAXSPEEDLIMIT_MAX : Real := 4000.0;   // Maximum value of MaxSpeedLimit input
      rMAXSPEEDLIMIT_DEFAULT : Real := 0.0;   // Default value of MaxSpeedLimit input
      tTIME_DELAY : Time := T#50ms;   // Trigger time delay
      wNO_ERROR : Word := 16#0000;   // Error code for no error
      wFB_ERR_PRESSURECMD : Word := 16#FC01;   // PressureCmd input is not in range
      wFB_ERR_MAXSPEEDLIMIT : Word := 16#FC02;   // MaxSpeedLimit input is not in range
      uiFB_ERR_INTERNAL : Word := 16#FCFF;   // Internal state machine error
      WEFC_WARNING_CODE : Word := 16#EA00;   // Internal mask
      wFCP_ERROR_PREFIX : Word := 16#FB00;   // Internal prefix
      wFCP_ERROR_MIN : Word := 1;   // Minimum value for FcP error code
      wFCP_ERROR_MAX : Word := 9;   // Maximum value for FcP error code
      wEFC_ERROR_PREFIX : Word := 16#FA00;   // Internal prefix
      wFCP_WARNING_PREFIX : Word := 16#EB00;   // Internal prefix
      wFCP_WARNING_MIN : Word := 1;   // Minimum value for FcP warning code
      wFCP_WARNING_MAX : Word := 12;   // Maximum value for FcP warning code
      wEFC_WARNING_PREFIX : Word := 16#EA00;   // Internal prefix
   END_VAR


BEGIN
	REGION AlwaysActive
	    // The code inside this region is always active, as long as the FB instance is called in an OB
	    
	    // Detect rising edge of Enable input
	    "FcP_R_Trig"(CLK := #Enable,
	             M := #bMbit0,
	             Q => #bEnableRise);
	    
	    // On rising edge of Enable input
	    IF (#bEnableRise = TRUE) THEN 
	        // Switch to Init step
	        #iStep := #iINIT_STEP; 
	    END_IF;
	    
	    // Detect rising edge of ClearError input
	    "FcP_R_Trig"(CLK := #ClearError,
	             M := #bMbit3,
	             Q => #bClearErrorRise);
	    
	    // When Enable input goes low
	    IF (#Enable = FALSE) AND (#iStep <> #iIDLE_STEP) THEN 
	        // Switch to Exit step
	        #iStep := #iEXIT_STEP; 
	    END_IF;
	    
	END_REGION
	
	REGION FcP5020
	    // Execution of FcP5020 function
	    
	    // Function block state machine
	    CASE #iStep OF
	            
	        #iIDLE_STEP:
	            ; // No operation
	            
	        #iINIT_STEP:
	            // Reset outputs and actual values
	            #InOperation := TRUE;
	            #MotorStarted := FALSE;
	            #Error := FALSE;
	            #Warning := FALSE;
	            #DiagnosisCode := 0;
	            #Status := 0;
	            #PressureAct := 0;
	            #SpeedAct := 0;
	            
	            // Copy inputs to local variables
	            #hwInputADDR := #InputADDR;
	            #hwOutputADDR := #OutputADDR;
	            
	            // Reset internal variables and flags
	            #iErrorStep := 0;
	            #iReturnVal := 0;
	            #bFBErrorPressureCmd := FALSE;
	            #bFBErrorMaxSpeedLimit := FALSE;
	            #bFBErrorDPRD_DPWR := FALSE;
	            #bFcPError := FALSE;
	            #bEFCError := FALSE;
	            #bFcPWarning := FALSE;
	            #bEFCWarning := FALSE;
	            #rPressureCmdInternal := 0;
	            #rMaxSpeedLimtInternal := 0;
	            #bInternalRunTrigger := FALSE;
	            #bInternalRun := FALSE;
	            
	            
	            // Rest internal function blocks
	            #fbTON_TIME(IN := FALSE,
	                        PT := #tTIME_DELAY);
	            
	            // Switch to operation step
	            #iStep := #iOPERATION_STEP;
	            
	            
	        #iOPERATION_STEP:
	            
	            // Check if PressureCmd input is valid
	            IF (#PressureCmd < #rPRESSURECMD_MIN) OR (#PressureCmd > #rPRESSURECMD_MAX) THEN
	                #bFBErrorPressureCmd := TRUE;
	                #rPressureCmdInternal := #rPRESSURECMD_DEFAULT;
	            ELSE
	                #bFBErrorPressureCmd := FALSE;
	                #rPressureCmdInternal := #PressureCmd;
	            END_IF;
	            
	            // Check if MaxSpeedLimit input is valid
	            IF (#MaxSpeedLimit < #rMAXSPEEDLIMIT_MIN) OR (#MaxSpeedLimit > #rMAXSPEEDLIMIT_MAX) THEN
	                #bFBErrorMaxSpeedLimit := TRUE;
	                #rMaxSpeedLimtInternal := #rMAXSPEEDLIMIT_DEFAULT;
	            ELSE
	                #bFBErrorMaxSpeedLimit := FALSE;
	                #rMaxSpeedLimtInternal := #MaxSpeedLimit;
	            END_IF;
	            
	            // Reset the error flags on ClearError input
	            IF (#bClearErrorRise = TRUE) THEN
	                #bFBErrorPressureCmd := FALSE;
	                #bFBErrorMaxSpeedLimit := FALSE;
	            END_IF;
	            
	            // Read data from EFC's PROFINET input area
	            #iReturnVal := DPRD_DAT(LADDR := #hwInputADDR, RECORD => #stInputData);
	            // Read data failed
	            IF (#iReturnVal <> 0) THEN
	                #Error := TRUE;
	                #bFBErrorDPRD_DPWR := TRUE;
	                #DiagnosisCode := #wReturnVal;
	                #iStep := #iEXIT_STEP;
	                RETURN;
	            END_IF;
	            
	            // Statuses from status words
	            #bFcPError := #stInputData.FcPStatusWord.Error;
	            #bEFCError := #stInputData.EFCStatusWord.Error;
	            #bFcPWarning := #stInputData.FcPStatusWord.Warning;
	            #bEFCWarning := #stInputData.EFCExStatusWord.Warning;
	            
	            // FB outputs
	            #MotorStarted := #stInputData.EFCStatusWord.Running;
	            #Error := #bFcPError OR #bEFCError OR #bFBErrorPressureCmd OR #bFBErrorMaxSpeedLimit;
	            #Warning := #bFcPWarning OR #bEFCWarning;
	            #PressureAct := DINT_TO_REAL(WORD_TO_DINT(#stInputData.PressureAct)) / #rPRESSURECMD_FACTOR;
	            #SpeedAct := DINT_TO_REAL(WORD_TO_DINT(#stInputData.SpeedAct));
	            
	            
	            // Status output handling
	            #Status := "F_StatusOut"(FB_Run := #InOperation,
	                                     Mode_24V := #stInputData.EFCExStatusWord.Mode24V,
	                                     Sleep_Mode := #stInputData.EFCExStatusWord.SleepMode,
	                                     Converter_OK := #stInputData.EFCExStatusWord.ConverterOk,
	                                     Warning := #stInputData.EFCExStatusWord.Warning,
	                                     Slave := #stInputData.FcPStatusWord.Slave,
	                                     ParameterGroup1 := #stInputData.FcPStatusWord.ParGroup1,
	                                     Vgmin := #stInputData.FcPStatusWord.DoublePumpVgMin);
	
	            #bInternalRunTrigger := #ClearError; (* falling edge of clear error + enable drive = 1 + active error *)
	            
	            // Control word 
	            #stOutputData.EFCControlWord.StopParameter := NOT #EnableDrive;
	            #stOutputData.EFCControlWord.ErrorReset := (#bEFCError = TRUE OR #bFcPError = TRUE OR #stOutputData.EFCControlWord.ErrorReset) AND #ClearError;
	            
	            // Identify triggers to pulse Run bit in control word
	            "FcP_F_Trig"(CLK := #stOutputData.EFCControlWord.ErrorReset,
	                     M := #bMbit1,
	                     Q => #bErrorResetFall);
	        
	            // Identify triggers to pulse Run bit in control word
	            "FcP_F_Trig"(CLK := #bFBErrorPressureCmd OR #bFBErrorMaxSpeedLimit,
	                     M := #bMbit2,
	                     Q => #bFBErrorFall);
	            
	            #bInternalRunTrigger := #EnableDrive AND (NOT #bErrorResetFall) AND (NOT #bFBErrorFall);
	            
	            // Switch on H0.00 bit 0 / EFC control word run
	            #fbTON_TIME(IN := #bInternalRunTrigger,
	                        PT := #tTIME_DELAY,
	                        Q => #bInternalRun);
	            
	            // Enable the EFC control word when in operation
	            #stOutputData.EFCControlWord.ControlWord := TRUE;
	            
	            // Set the EFC run command
	            #stOutputData.EFCControlWord.Run := #bInternalRun;
	            
	            
	            // Command values
	            #stOutputData.PressureCmd := DINT_TO_WORD(REAL_TO_DINT(#rPressureCmdInternal * #rPRESSURECMD_FACTOR));
	            #stOutputData.FlowCmd := DINT_TO_WORD(REAL_TO_DINT(#rMaxSpeedLimtInternal));
	            
	            // Write data to EFC's PROFINET output area
	            #iReturnVal := DPWR_DAT(LADDR := #hwOutputADDR, RECORD := #stOutputData);
	            // Write data failed
	            IF (#iReturnVal <> 0) THEN
	                #Error := TRUE;
	                #bFBErrorDPRD_DPWR := TRUE;
	                #wReturnVal := INT_TO_WORD(#iReturnVal);
	                #DiagnosisCode := #wReturnVal;
	                #iStep := #iEXIT_STEP;
	                RETURN;
	            END_IF;
	            
	            // Error handling + Priority handling (setting DiagnosisCode output)
	            #DiagnosisCode := #wNO_ERROR;
	            IF (#bFcPError = TRUE) THEN // Set FcP function error code
	                #DiagnosisCode := "GetFcPCode"(Value := #stInputData.ASFErrorCode,
	                                               Prefix := #wFCP_ERROR_PREFIX,
	                                               Min := #wFCP_ERROR_MIN,
	                                               Max := #wFCP_ERROR_MAX,
	                                               ValueIsDecimal := TRUE);
	                RETURN;
	            ELSIF (#bEFCError = true) THEN // Set EFC error code
	                #DiagnosisCode := "GetEFCErrorCode"(EFCStatusWord := #stInputData.EFCStatusWord,
	                                                    Prefix := #wEFC_ERROR_PREFIX);
	                RETURN;
	            ELSIF (#bFBErrorPressureCmd = TRUE) THEN // Set pressure command error code
	                #DiagnosisCode := #wFB_ERR_PRESSURECMD;
	                RETURN;
	            ELSIF (#bFBErrorMaxSpeedLimit = TRUE) THEN // Set max speed limit error code
	                #DiagnosisCode := #wFB_ERR_MAXSPEEDLIMIT;
	                RETURN;
	            ELSIF (#bFcPWarning = TRUE) THEN // Set FcP function warning code
	                #DiagnosisCode := "GetFcPCode"(Value := #stInputData.ASFErrorCode,
	                                               Prefix := #wFCP_WARNING_PREFIX,
	                                               Min := #wFCP_WARNING_MIN,
	                                               Max := #wFCP_WARNING_MAX,
	                                               ValueIsDecimal := TRUE);
	                RETURN;
	            ELSIF (#bEFCWarning = TRUE) THEN // Set EFC warning code
	                #DiagnosisCode := #WEFC_WARNING_CODE;
	                RETURN;
	            END_IF;
	                
	            
	        #iEXIT_STEP:
	            // Reset outputs and actual values
	            #InOperation := FALSE;
	            #MotorStarted := FALSE;
	            #Warning := FALSE;
	            #Status := 0;
	            #PressureAct := 0;
	            #SpeedAct := 0;
	            
	            // Stop the drive
	            //#stOutputData.EFCControlWord.ControlWord := FALSE;
	            #stOutputData.EFCControlWord.Run := FALSE;
	            #stOutputData.EFCControlWord.StopParameter := TRUE;
	            
	            // Update control values to drive
	            #iReturnVal := DPWR_DAT(LADDR := #hwOutputADDR, RECORD := #stOutputData);
	            
	            // Switch to idle step
	            #iStep := #iIDLE_STEP; 
	            
	        ELSE // Unknown state of the function block state machine
	            #iStep := #iINIT_STEP; // Switch to Init step
	            RETURN;
	    END_CASE;
	END_REGION
	
	
END_FUNCTION_BLOCK

