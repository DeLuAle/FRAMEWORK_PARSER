// Block: Positioning_EPOS_Machine_FB_NEW
// Title: Init

FUNCTION_BLOCK "Positioning_EPOS_Machine_FB_NEW"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Init
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI : udt_DeviceSafetyInterface;
      Drive : TAx_DriveInterface;
      DataIn : Positioning_EPOS_Machine_DataIn;
      CIn : Positioning_EPOS_Machine_CIn;
      Config : Positioning_EPOS_Machine_Config_NEW;
      HW_ID_TEL111 : HW_SUBMODULE;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      DataOut : Positioning_EPOS_Machine_DataOut;
      COut : Positioning_EPOS_Machine_COut;
   END_VAR

   VAR_IN_OUT
      Par : Positioning_EPOS_Machine_Par;
      Pers_Data : Struct
         EncoderAbsolute_Preset_OK : Bool;
         Persistent_ActualPosition : LReal;
      END_STRUCT;
      Warning : Positioning_EPOS_Machine_Wng;
      Alarm : Positioning_EPOS_Machine_Alr;
   END_VAR

   VAR
      InitDone : Bool;
      Status : Int;
      Status_Home : Int;
      Diag : Struct
         S120 : TO_Diagnostic;
      END_STRUCT;
      HMI : Struct
         Sts : "UDT_HMI-Sts_PosEPOS-MchFB";
         B_Preset : Bool;
         PresetPosition : LReal;
         TargetPosition : LReal;
      END_STRUCT;
      Sts : Struct
         Standstill : Bool;
         AlarmPresence : Bool;
         WarningPresence : Bool;
         Gen_Cnd : Bool;
         Minus_Cnd : Bool;
         Plus_Cnd : Bool;
         Pos_Cnd : Bool;
         Preset_Cnd : Bool;
         InTargetPosition : Bool;
         Limits_SW_Active : Bool;
         Limits_EXT_Active : Bool;
         AxisModulo : LReal;
         ActualPosition : LReal;
         MissingToTarget : LReal;
         ActualVelocityRPM : LReal;
         ReductionRatio : LReal;
         ActualVelocity : LReal;
         EncIncremental_Preset_OK : Bool;
         S120 : Struct
            FaultActive : Bool;
            AlarmPresence : Bool;
            Standstill : Bool;
            IsRunningNegative : Bool;
            IsRunningPositive : Bool;
            MinusSWLim : Bool;
            PlusSWLim : Bool;
            MinusHWLim : Bool;
            PlusHWLim : Bool;
            TargetApply : Bool;
         END_STRUCT;
      END_STRUCT;
      Ctrl : Struct
         StopDueDoorOpeningRequest : Bool;
         StopAborting : Bool;
         SafeMotionEnable : Bool;
         StopInPhase : Bool;
         StopProgrammed : Bool;
         Preset : Bool;
         ReloadPosition : Bool;
         Minus_Man : Bool;
         Plus_Man : Bool;
         MoveToPos_Man : Bool;
         Minus_Aut : Bool;
         Plus_Aut : Bool;
         MoveToPos_Aut : Bool;
         MoveToPos : Bool;
         Minus_Vel : Bool;
         Plus_Vel : Bool;
         Fan : Bool;
         Pos : LReal;
         Vel : LReal;
         Acc : LReal;
         Dec : LReal;
         S120 : Struct
            Preset : Bool;
            Jog_Plus : Bool;
            Jog_Minus : Bool;
            Positioining : Bool;
            TargetPos : DInt;
         END_STRUCT;
      END_STRUCT;
      S120_SinaPos : SinaPos;
      Fan_M : Motor;
      WriteRefPos : RW_SINAMICS_Par;
      Write_P2507 : RW_SINAMICS_Par;
      Read_P2507 : RW_SINAMICS_Par;
      Write_P0971 : RW_SINAMICS_Par;
      Read_P0971 : RW_SINAMICS_Par;
      TON_DelayOFF : TON_TIME;
      TON_ModeTimeOut : TON_TIME;
      TON_NoPendingCmd : TON_TIME;
      TON_MinusCnd : TON_TIME;
      TON_PlusCnd : TON_TIME;
      TON_Fan_DelayOff : TON_TIME;
      TON_Brake_TimeOut : TON_TIME;
      TON_InTargetPosition : TON_TIME;
      TON_TimeOutInit : TON_TIME;
      AUX : Struct
         PB_Minus : Bool;
         PB_Plus : Bool;
         PB_MoveToPos : Bool;
         B_Preset : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP
      PE : Struct
         PB_Minus : Bool;
         PB_Plus : Bool;
         PB_MoveToPos : Bool;
         B_Preset : Bool;
      END_STRUCT;
      RETVAL : Int;
      Req : Bool;
      RemainingDistanceABS : LReal;
      LimitExceeds : Bool;
      UsePositionLimits : Bool;
      DriveSwitchOnInhibit : Bool;
      ReferencePosition : LReal;
   END_VAR

   VAR CONSTANT
      MODE_1_RELATIVE_POSITIONING : Int;
      MODE_2_ABSOLUTE_POSITIONING : Int;
      MODE_3_POS_AS_SETUP : Int;
      MODE_4_HOMING_PROCEDURE : Int;
      MODE_5_SET_HOME_POSITION : Int;
      MODE_6_TRAVERSING_BLOCK : Int;
      MODE_7_JOG : Int;
      MODE_8_JOG_INCREMENTAL : Int;
      STS_0_IDLE : Int;
      STS_DIRECT_HOME : Int;
      STS_DIRECT_HOME_Write_P2507 : Int;
      STS_DIRECT_HOME_Read_P2507 : Int;
      STS_DIRECT_HOME_Write_P0971 : Int;
      STS_DIRECT_HOME_Read_P0971 : Int;
      STS_DIRECT_HOME_END : Int;
      STS_MOVE_VEL : Int;
      STS_POSITIONING_START : Int;
      STS_STOP : Int;
   END_VAR


BEGIN
   REGION "Init"

      IF NOT InitDone THEN
          
          InitDone := TRUE;
          Sts.EncIncremental_Preset_OK := FALSE;
      END_IF;



   END_REGION

   REGION "Reset"
      IF AreaInterface.RstAlarms THEN
          
          
          Alarm.Ax_NotHomed := FALSE;
          Alarm.HwLimitMinus := FALSE;
          Alarm.HwLimitPlus := FALSE;
          Alarm.BrakeTimeOut := FALSE;
          
          
          Warning.NotAutReady := FALSE;
          Warning.Minus_CndMissing := FALSE;
          Warning.Plus_CndMissing := FALSE;
          
          
          Alarm.S120_WriteParErr := FALSE;
          
          
      END_IF;



   END_REGION

   REGION "Reduction ratio calculation - Motor revolution -> position Eng Unit"
      "Calc_RedutionRatio"(
         en := TRUE,
         LoadRevolution := Config.Ax.LoadRevolution,
         MotorRevolution := Config.Ax.MotorRevolution,
         LeadScrewPitchValue := Config.Ax.LeadScrewPitchVal,
         ReductionRatio => Sts.ReductionRatio
      );

      "Calc_RedutionRatio"(LoadRevolution := Config.Ax.LoadRevolution, MotorRevolution := Config.Ax.MotorRevolution, LeadScrewPitchValue := Config.Ax.LeadScrewPitchVal);
   END_REGION

   REGION "Machine stop movements due door open request"
      Ctrl.StopDueDoorOpeningRequest := (((((TON_NoPendingCmd.Q AND Sts.Standstill) OR Ctrl.StopDueDoorOpeningRequest) AND CIn.Manager.EnableStopDoorOpeningReq) AND ZSI.Door_NormalStop) AND NOT (ZSI.Door_Opened));
   END_REGION

   REGION "Stop in phase"
      IF NOT (AreaInterface.StopInPhase) THEN
         Ctrl.StopInPhase := FALSE;
      ELSIF AreaInterface.StopInPhase THEN
         Ctrl.StopInPhase := TRUE;
      END_IF;
   END_REGION

   REGION "Stop programmed"
      IF NOT (AreaInterface.StopProgrammed) THEN
         Ctrl.StopProgrammed := FALSE;
      ELSIF AreaInterface.StopProgrammed THEN
         Ctrl.StopProgrammed := TRUE;
      END_IF;
   END_REGION

   REGION "Several status from FB"
      // Axis modulo in Eng.Unit of position
      // 
      Sts.AxisModulo := Config.Ax.Modulo_S120_P2566 / 1000.0;


      // Position in Eng.Unit = Position in LU X 1000.
      //
      Sts.ActualPosition := (S120_SinaPos.ActPosition) / 1000.0;

      // S120_SinaPos.ActVelocity = Current velocity (standardized 40000000h = 1073741824.0 dec = 100% = p2000)
      // Velocity in RPM
      // 
      Sts.ActualVelocityRPM := (S120_SinaPos.ActVelocity) / 1073741824.0 * Config.Ax.MaxRPM_S120_P2000;

      // Velocity in Eng.Unit / min
      Sts.ActualVelocity := Sts.ActualVelocityRPM * Sts.ReductionRatio;


      Sts.S120.IsRunningPositive := S120_SinaPos.EPosZSW2.%X4;
      Sts.S120.IsRunningNegative := S120_SinaPos.EPosZSW2.%X5;

      Sts.S120.MinusSWLim := S120_SinaPos.EPosZSW2.%X6;
      Sts.S120.PlusSWLim := S120_SinaPos.EPosZSW2.%X7;

      Sts.S120.MinusHWLim := S120_SinaPos.EPosZSW1.%X8;
      Sts.S120.PlusHWLim :=  S120_SinaPos.EPosZSW1.%X9;


      Sts.S120.FaultActive := S120_SinaPos.ZSW1.%X3;
      Sts.S120.AlarmPresence := S120_SinaPos.ZSW1.%X7;
      Sts.S120.Standstill := NOT S120_SinaPos.EPosZSW1.%X4 AND NOT S120_SinaPos.EPosZSW1.%X5 AND NOT S120_SinaPos.EPosZSW2.%X4 AND NOT S120_SinaPos.EPosZSW2.%X5;


   END_REGION

   REGION "Drive Diagnostic"
      Diag.S120.DeviceType := 6;


      Diag.S120.Drive_Message := 0;
      Diag.S120.MessageType := 0;


      IF Sts.S120.FaultActive THEN
          Diag.S120.Drive_Message := S120_SinaPos.ActFault;
          Diag.S120.MessageType := 2;
          
      ELSIF Sts.S120.AlarmPresence THEN
          Diag.S120.Drive_Message := S120_SinaPos.ActWarn;
          Diag.S120.MessageType := 1;
      END_IF;

   END_REGION

   REGION "Mask warning 1699 = Test stop STO required"
      IF (Sts.S120.AlarmPresence AND (S120_SinaPos.ActWarn <> 1699)) THEN
         Sts.S120.AlarmPresence := FALSE;
      END_IF;
   END_REGION

   REGION "Drive / Axis Warnings"
      Warning.S120_Warning := Sts.S120.AlarmPresence;
      DriveSwitchOnInhibit := (((S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8402)) AND Warning.Minus_CndMissing) OR ((S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8402)) AND Warning.Plus_CndMissing));
      Alarm.Ax_ErrSelMode := (S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8202));
      Alarm.Ax_ErrOverride := (S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8203));
      Alarm.Ax_InvalidTraversingBlockNr := (S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8204));
      Warning.Ax_FlyingHome := (S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8403));
   END_REGION

   REGION "Drive / Axis Alarms"
      Alarm.S120_Fault := (Sts.S120.FaultActive OR (S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8401)));
      Alarm.S120_ComErr := ((S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8600)) OR (S120_SinaPos.AxisError AND (S120_SinaPos.Status = 16#8601)));
      IF NOT ((((((NOT (WriteRefPos.Error) AND NOT (Write_P2507.Error)) OR (NOT (WriteRefPos.Error) AND Write_P2507.Error) OR (NOT (WriteRefPos.Error) AND Sys.ByPass)) AND NOT (Read_P2507.Error)) AND NOT (Write_P0971.Error)) AND NOT (Read_P0971.Error))) THEN
         Alarm.S120_WriteParErr := TRUE;
      END_IF;
      IF ((Alarm.S120_WriteParErr AND NOT (Sys.ByPass)) AND Write_P2507.Error) THEN
         DEBUG.Alr[1] := TRUE;
      END_IF;
      IF ((Alarm.S120_WriteParErr AND NOT (Sys.ByPass)) AND Read_P2507.Error) THEN
         DEBUG.Alr[2] := TRUE;
      END_IF;
      IF ((Alarm.S120_WriteParErr AND NOT (Sys.ByPass)) AND Write_P0971.Error) THEN
         DEBUG.Alr[3] := TRUE;
      END_IF;
      IF ((Alarm.S120_WriteParErr AND NOT (Sys.ByPass)) AND Read_P0971.Error) THEN
         DEBUG.Alr[4] := TRUE;
      END_IF;
   END_REGION

   REGION "Alarm Hardware Limit - / + Exceedes"
      IF NOT ((NOT (Sts.S120.MinusHWLim) AND NOT (DataIn.LS_Minus))) THEN
         Alarm.HwLimitMinus := TRUE;
      END_IF;
      IF NOT ((NOT (Sts.S120.PlusHWLim) AND NOT (DataIn.LS_Plus))) THEN
         Alarm.HwLimitPlus := TRUE;
      END_IF;
   END_REGION

   REGION "Warning software limit - / + Exceedes"
      Warning.Ax_SwLimitMinus := Sts.S120.MinusSWLim;
      Warning.Ax_SwLimitPlus := Sts.S120.PlusSWLim;
   END_REGION

   REGION "Alarm / Warning axis not homed"
      Warning.Ax_NotHomed := (NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK)));
      IF ((((NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK))) AND AreaInterface.Aut) OR ((NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK))) AND Ctrl.MoveToPos_Aut) OR ((NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK))) AND Ctrl.MoveToPos_Man)) AND NOT (S120_SinaPos.AxisRef)) THEN
         Alarm.Ax_NotHomed := TRUE;
      END_IF;
      IF ((((NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK))) AND AreaInterface.Aut) OR ((NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK))) AND Ctrl.MoveToPos_Aut) OR ((NOT (S120_SinaPos.AxisRef) OR (Config.Ax.Encoder_Inc_AutoReloadPosition AND NOT (Sts.EncIncremental_Preset_OK)) OR (Config.Ax.Encoder_is_Absolute AND NOT (Pers_Data.EncoderAbsolute_Preset_OK))) AND Ctrl.MoveToPos_Man)) AND NOT (S120_SinaPos.AxisRef)) THEN
         Warning.Ax_NotHomed := FALSE;
      END_IF;
   END_REGION

   REGION "Alarm motor brake timeout"
      #TON_Brake_TimeOut(
         IN := (((Config.Brake_Presence AND DataIn.Brake_M_Q) AND NOT (DataIn.Brake_M_Feedback)) OR ((Config.Brake_Presence AND NOT (DataIn.Brake_M_Q)) AND DataIn.Brake_M_Feedback)),
         PT := t#1s
      );

      #TON_Brake_TimeOut.Q;
      IF #TON_Brake_TimeOut.Q THEN
         Alarm.BrakeTimeOut := TRUE;
      END_IF;
   END_REGION

   REGION "Buttons"
      PE.PB_Minus := PosEdge(DataIn.PB.Bwd_Minus);
      PE.PB_Plus := PosEdge(DataIn.PB.Fwd_Plus);
      PE.PB_MoveToPos := PosEdge(DataIn.PB.MoveToPos);
      PE.B_Preset := PosEdge(HMI.B_Preset);
   END_REGION

   REGION "Preset condition"
      Sts.Preset_Cnd := ((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND (Status = #STS_0_IDLE)) OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND (Status >= #STS_DIRECT_HOME)) AND (Status < #STS_DIRECT_HOME_END))) AND NOT (Alarm.S120_WriteParErr));
   END_REGION

   REGION "Reload position"
      IF NOT Config.Ax.Encoder_Inc_AutoReloadPosition THEN
          Status_Home := 0;
      END_IF;
          


      CASE Status_Home OF
          0:
              IF NOT S120_SinaPos.AxisRef THEN
                  Sts.EncIncremental_Preset_OK := FALSE;
              END_IF;
              
              TON_TimeOutInit(IN := FALSE,
                               PT := T#10s);
             
             
              Ctrl.ReloadPosition := FALSE;
              
              IF AreaInterface.RstAlarms
                  AND
                  Sts.Preset_Cnd
                  AND
                  NOT Sts.EncIncremental_Preset_OK
                  AND
                  Config.Ax.Encoder_Inc_AutoReloadPosition
              THEN
                  Status_Home += 1;
              END_IF;
              
          1:
              TON_TimeOutInit(IN := NOT S120_SinaPos.AxisRef,
                               PT := T#10s);
              
              Ctrl.ReloadPosition := TRUE;
              
              
              IF S120_SinaPos.AxisRef
                  AND
                  Sts.EncIncremental_Preset_OK
              THEN
                  Status_Home += 1;
                  
              ELSIF TON_TimeOutInit.Q THEN
                  
                  Status_Home := 0;
                  
              END_IF;
              
          2:
              Ctrl.ReloadPosition := FALSE;
              Status_Home := 0;
              
          ELSE
              Status_Home := 0;
              
      END_CASE;

   END_REGION

   REGION "Manual preset"
      Ctrl.Preset := ((((PE.B_Preset AND NOT (Ctrl.Preset)) OR (HMI.B_Preset AND Ctrl.Preset)) AND Sts.Preset_Cnd) AND NOT (Ctrl.ReloadPosition));
   END_REGION

   REGION "Man"
      Ctrl.MoveToPos_Man := (((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND PE.PB_MoveToPos) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Ctrl.MoveToPos_Man)) AND DataIn.PB.MoveToPos) AND S120_SinaPos.AxisRef);
      Ctrl.Minus_Man := ((((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND NOT (DataIn.PB.MoveToPos)) AND PE.PB_Minus) OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND NOT (DataIn.PB.MoveToPos)) AND Ctrl.Minus_Man)) AND DataIn.PB.Bwd_Minus) AND NOT (DataIn.PB.Fwd_Plus));
      Ctrl.Plus_Man := ((((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND NOT (DataIn.PB.MoveToPos)) AND PE.PB_Plus) OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND NOT (DataIn.PB.MoveToPos)) AND Ctrl.Plus_Man)) AND DataIn.PB.Fwd_Plus) AND NOT (DataIn.PB.Bwd_Minus));
   END_REGION

   REGION "Aut"
      Ctrl.MoveToPos_Aut := ((CIn.Manager.Control_ON AND CIn.Manager.MoveToPos) AND S120_SinaPos.AxisRef);
      Ctrl.Minus_Aut := (((CIn.Manager.Control_ON AND NOT (CIn.Manager.MoveToPos)) AND CIn.Manager.Minus) AND NOT (CIn.Manager.Plus));
      Ctrl.Plus_Aut := (((CIn.Manager.Control_ON AND NOT (CIn.Manager.MoveToPos)) AND CIn.Manager.Plus) AND NOT (CIn.Manager.Minus));
   END_REGION

   REGION "Position Limits"
      COut.MinPosition := -999999999.99;
      COut.MaxPosition := +999999999.99;

      COut.MinusLsSwReached := FALSE;
      COut.PlusLsSwReached := FALSE;
      COut.MinusLimitReached := FALSE;
      COut.PlusLimitReached := FALSE;

      Sts.Limits_SW_Active := FALSE;
      Sts.Limits_EXT_Active := FALSE;


      IF S120_SinaPos.AxisRef
      THEN
          
          Sts.Limits_SW_Active := Config.Ax.SwLimMinus_S120_P2580 < Config.Ax.SwLimPlus_S120_P2581;
          
          //.. If software limits are enabled...
          //
          IF Sts.Limits_SW_Active
          THEN
              
              
              // Software limit Minus reached or exceeds
              // 
              RemainingDistanceABS := (M_PosAMinusPosB(PosA := Sts.ActualPosition, PosB := Config.Ax.SwLimMinus_S120_P2580, MODULE := Sts.AxisModulo));
              
              LimitExceeds := M_CmpLT(Xa := Sts.ActualPosition, Xb := Config.Ax.SwLimMinus_S120_P2580, MODULE := Sts.AxisModulo);
              
              COut.MinusLsSwReached := (RemainingDistanceABS <= Par.PosTolerance) OR LimitExceeds;
              
              
              // Software limit Plus reached or exceeds
              // 
              RemainingDistanceABS := (M_PosAMinusPosB(PosA := Sts.ActualPosition, PosB := Config.Ax.SwLimPlus_S120_P2581, MODULE := Sts.AxisModulo));
              
              LimitExceeds := M_CmpGT(Xa := Sts.ActualPosition, Xb :=Config.Ax.SwLimPlus_S120_P2581, MODULE := Sts.AxisModulo);
              
              COut.PlusLsSwReached := (RemainingDistanceABS <= Par.PosTolerance) OR LimitExceeds;
              
              
              // Set general Min / Max position limit
              // 
              COut.MinPosition := M_PosAPlusCostB(PosA := Config.Ax.SwLimMinus_S120_P2580, CostB := (Par.PosTolerance / 2), MODULE := Sts.AxisModulo);
              COut.MaxPosition := M_PosAMinusCostB(PosA := Config.Ax.SwLimPlus_S120_P2581, CostB := (Par.PosTolerance / 2), MODULE := Sts.AxisModulo);
              
              
          END_IF;
          
          //.. IF External MIN limit set..
          //
          IF CIn.PositionLimits.EnableMin
          THEN
              Sts.Limits_EXT_Active := TRUE;
              
              RemainingDistanceABS := (M_PosAMinusPosB(PosA := Sts.ActualPosition, PosB := CIn.PositionLimits.PosMin, MODULE := Sts.AxisModulo));
              
              LimitExceeds := M_CmpLT(Xa := Sts.ActualPosition, Xb := CIn.PositionLimits.PosMin, MODULE := Sts.AxisModulo);
              
              COut.MinusLimitReached := (RemainingDistanceABS <= Par.PosTolerance) OR LimitExceeds;
              
              // Update general MIN limit
              // 
              IF M_CmpGT(Xa := CIn.PositionLimits.PosMin, Xb := COut.MinPosition, MODULE := Sts.AxisModulo)
              THEN
                  COut.MinPosition := CIn.PositionLimits.PosMin;
              END_IF;
          END_IF;
          
          
          //.. IF External MAX limit set..
          //
          IF CIn.PositionLimits.EnableMax
          THEN
              Sts.Limits_EXT_Active := TRUE;
              
              RemainingDistanceABS := (M_PosAMinusPosB(PosA := Sts.ActualPosition, PosB := CIn.PositionLimits.PosMax, MODULE := Sts.AxisModulo));
              
              LimitExceeds := M_CmpGT(Xa := Sts.ActualPosition, Xb := CIn.PositionLimits.PosMax, MODULE := Sts.AxisModulo);
              
              COut.PlusLimitReached := (RemainingDistanceABS <= Par.PosTolerance) OR LimitExceeds;
              
              
              // Update general MAX limit
              // 
              IF M_CmpLT(Xa := CIn.PositionLimits.PosMax, Xb := COut.MaxPosition, MODULE := Sts.AxisModulo)
              THEN
                  COut.MaxPosition := CIn.PositionLimits.PosMax;
              END_IF;
              
          END_IF;
          
      END_IF;


      UsePositionLimits := Sts.Limits_SW_Active OR Sts.Limits_EXT_Active;

   END_REGION

   REGION "Target Position"
      // Target position choose
      //


      IF CIn.Manager.Control_ON
      THEN
          
          Ctrl.Pos := CIn.Manager.Pos;
        
          
          IF Ctrl.Minus_Aut AND UsePositionLimits
          THEN
              Ctrl.Pos := COut.MinPosition;
              
              
          ELSIF Ctrl.Plus_Aut AND UsePositionLimits
          THEN
              Ctrl.Pos := COut.MaxPosition;
          END_IF;
          
          
          HMI.TargetPosition := Ctrl.Pos;
          
          
          
      ELSIF Ctrl.MoveToPos_Man
      THEN
          
          Ctrl.Pos := HMI.TargetPosition;
          
          
      ELSIF Ctrl.Minus_Man AND UsePositionLimits
      THEN
          Ctrl.Pos := COut.MinPosition;
          HMI.TargetPosition := Ctrl.Pos;
          
      ELSIF Ctrl.Plus_Man AND UsePositionLimits
      THEN
          
          Ctrl.Pos := COut.MaxPosition;
          HMI.TargetPosition := Ctrl.Pos;
          
      END_IF;
          
          
          
      // Check Target position within limits
      // 
        
      IF UsePositionLimits THEN
         
          
          // Target position exceeds MIN limit
          // 
          LimitExceeds := M_CmpLT(Xa := Ctrl.Pos, Xb := COut.MinPosition, MODULE := Sts.AxisModulo);
          IF LimitExceeds THEN
              Ctrl.Pos := COut.MinPosition;
          END_IF;
          
          
          // Target position exceeds MAX limit
          //  
          LimitExceeds := M_CmpGT(Xa := Ctrl.Pos, Xb := COut.MaxPosition, MODULE := Sts.AxisModulo);
          IF LimitExceeds THEN
              Ctrl.Pos := COut.MaxPosition;
          END_IF;
          
      END_IF;



   END_REGION

   REGION "Check missing position to reach the target"
      Sts.MissingToTarget := M_PosAMinusPosB(PosA := Ctrl.Pos, PosB := Sts.ActualPosition, MODULE := Sts.AxisModulo);

   END_REGION

   REGION "Status axis in target position"

      TON_InTargetPosition(IN := (Sts.MissingToTarget) <= Par.PosTolerance, PT := Par.DelayInPosition);

      Sts.InTargetPosition := TON_InTargetPosition.Q AND S120_SinaPos.AxisRef AND (S120_SinaPos.AxisPosOk OR NOT Ctrl.S120.Positioining);

   END_REGION

   REGION "Target Velocity / Acc / Dec"
      Ctrl.Vel := 0.0;

      IF CIn.Manager.Control_ON THEN
          
          Ctrl.Vel := CIn.Manager.Vel;
          Ctrl.Acc := CIn.Manager.Acc;
          Ctrl.Dec := CIn.Manager.Dec;
          
          
      ELSIF Ctrl.Minus_Man OR Ctrl.Plus_Man OR Ctrl.MoveToPos_Man THEN
          
          Ctrl.Vel := Par.Man_Vel;
          Ctrl.Acc := Par.Man_Acc;
          Ctrl.Dec := Par.Man_Dec;
          
      END_IF;


      //---   

      // Dynamics limiting
      // 
      Ctrl.Vel := (IN1 := Ctrl.Vel, IN2 := Config.Ax.MaxVel_S120_P2571);
      Ctrl.Acc := (IN1 := Ctrl.Acc, IN2 := Config.Ax.MaxAcc_S120_P2572);
      Ctrl.Dec := (IN1 := Ctrl.Dec, IN2 := Config.Ax.MaxDec_S120_P2573);

      //---

      // SLS velocity limit
      //  
      IF ZSI.Door_Opened AND Ctrl.Vel > Config.SLS_Vel THEN
          Ctrl.Vel := Config.SLS_Vel;
      END_IF;

      // Brake not open... Velocity  = 0.0
      // 
      IF Config.Brake_Presence AND NOT DataIn.Brake_M_Feedback THEN
          Ctrl.Vel := 0.0;
      END_IF;


      COut.MaxVelocity := Config.Ax.MaxVel_S120_P2571;

   END_REGION

   REGION "Conditions"
      Sts.Gen_Cnd := (((((NOT (Ctrl.StopDueDoorOpeningRequest) AND NOT (DSI.SafeStop)) AND NOT (DSI.DevicesInSafeState)) AND NOT (Ctrl.StopAborting)) AND NOT (Ctrl.StopInPhase)) AND NOT (Ctrl.StopProgrammed));
      Sts.Gen_Cnd := ((((Sts.Gen_Cnd AND NOT (Alarm.BrakeTimeOut)) AND Drive.Infeed_ON) AND NOT (Alarm.S120_Fault)) AND NOT (S120_SinaPos.Lockout));
      Sts.Minus_Cnd := ((((((((Sts.Gen_Cnd AND Sts.EncIncremental_Preset_OK) OR (Sts.Gen_Cnd AND NOT (Config.Ax.Encoder_Inc_AutoReloadPosition))) AND Pers_Data.EncoderAbsolute_Preset_OK) OR (((Sts.Gen_Cnd AND Sts.EncIncremental_Preset_OK) OR (Sts.Gen_Cnd AND NOT (Config.Ax.Encoder_Inc_AutoReloadPosition))) AND NOT (Config.Ax.Encoder_is_Absolute))) AND CIn.Minus_ExtEnable) AND NOT (Warning.Ax_SwLimitMinus)) AND NOT (Alarm.HwLimitMinus)) AND NOT (COut.MinusLimitReached));
      Sts.Plus_Cnd := ((((((((Sts.Gen_Cnd AND Sts.EncIncremental_Preset_OK) OR (Sts.Gen_Cnd AND NOT (Config.Ax.Encoder_Inc_AutoReloadPosition))) AND Pers_Data.EncoderAbsolute_Preset_OK) OR (((Sts.Gen_Cnd AND Sts.EncIncremental_Preset_OK) OR (Sts.Gen_Cnd AND NOT (Config.Ax.Encoder_Inc_AutoReloadPosition))) AND NOT (Config.Ax.Encoder_is_Absolute))) AND CIn.Plus_ExtEnable) AND NOT (Warning.Ax_SwLimitPlus)) AND NOT (Alarm.HwLimitPlus)) AND NOT (COut.PlusLimitReached));
      Sts.Pos_Cnd := ((((Sts.MissingToTarget < 0.0) AND Sts.Minus_Cnd) OR ((Sts.MissingToTarget >= 0.0) AND Sts.Plus_Cnd)) AND S120_SinaPos.AxisRef);
   END_REGION

   REGION "S120 EPOS - Controls"
      Ctrl.Minus_Vel := (((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Minus_Man) OR ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Minus_Aut));
      Ctrl.S120.Jog_Minus := ((((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Minus_Man) OR ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Minus_Aut)) AND Sts.Minus_Cnd);
      Ctrl.Plus_Vel := (((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Plus_Man) OR ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Plus_Aut));
      Ctrl.S120.Jog_Plus := ((((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Plus_Man) OR ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active)) AND Ctrl.Plus_Aut)) AND Sts.Plus_Cnd);
      Ctrl.MoveToPos := ((NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Minus_Man) OR (NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Minus_Aut) OR (NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Plus_Man) OR (NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Plus_Aut) OR NOT ((NOT (Ctrl.MoveToPos_Aut) AND NOT (Ctrl.MoveToPos_Man))));
      Ctrl.S120.Positioining := (((NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Minus_Man) OR (NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Minus_Aut) OR (NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Plus_Man) OR (NOT ((NOT (Sts.Limits_SW_Active) AND NOT (Sts.Limits_EXT_Active))) AND Ctrl.Plus_Aut) OR NOT ((NOT (Ctrl.MoveToPos_Aut) AND NOT (Ctrl.MoveToPos_Man)))) AND Sts.Pos_Cnd);
      Ctrl.S120.Preset := NOT ((NOT (Ctrl.Preset) AND NOT (Ctrl.ReloadPosition)));
   END_REGION

   REGION "S120 EPOS - Force STATUS = STOP (End of movemet)"
      #TON_DelayOFF(
         IN := ((((Status = #STS_MOVE_VEL) AND NOT (Ctrl.S120.Jog_Minus)) AND NOT (Ctrl.S120.Jog_Plus)) OR (((Status = #STS_POSITIONING_START) AND NOT (Ctrl.S120.Positioining)) AND NOT (CIn.Manager.Control_ON))),
         PT := Config.Ax.PowerOffDelay
      );

      #TON_DelayOFF.Q;
      IF ((((Status >= #STS_DIRECT_HOME) AND (Status <= #STS_DIRECT_HOME_END)) AND NOT (Ctrl.S120.Preset)) OR #TON_DelayOFF.Q) THEN
         Status := #STS_STOP;
      END_IF;
   END_REGION

   REGION "S120 EPOS - Force STATUS = STOP (Timeout SinaPos Mode not reached)"
      #TON_ModeTimeOut(
         IN := ((((S120_SinaPos.ActMode <> #MODE_5_SET_HOME_POSITION) AND (Status >= #STS_DIRECT_HOME)) AND (Status <= #STS_DIRECT_HOME_END)) OR ((S120_SinaPos.ActMode <> #MODE_7_JOG) AND (Status = #STS_MOVE_VEL)) OR ((S120_SinaPos.ActMode <> #MODE_2_ABSOLUTE_POSITIONING) AND (Status = #STS_POSITIONING_START))),
         PT := t#1500ms
      );

      #TON_ModeTimeOut.Q;
      IF #TON_ModeTimeOut.Q THEN
         Status := #STS_STOP;
      END_IF;
   END_REGION

   REGION "S120 EPOS - Control State Machine"
      CASE Status OF
              
              // 
              //  ###############################################################################################
              //  STATUS = STOP
              // ###############################################################################################
              
          STS_STOP:
              
              S120_SinaPos.Jog1 := FALSE;
              S120_SinaPos.Jog2 := FALSE;
              S120_SinaPos.AxisRef := FALSE;
              S120_SinaPos.ExecuteMode := FALSE;
              S120_SinaPos.CancelTraversing := TRUE;
              S120_SinaPos.IntermediateStop := FALSE;
              
              WriteRefPos.Enable := FALSE;
              Write_P2507.Enable := FALSE;
              Read_P2507.Enable := FALSE;
              Write_P0971.Enable := FALSE;
              Read_P0971.Enable := FALSE;
             
              
              
              
              IF NOT S120_SinaPos.AxisEnabled AND NOT S120_SinaPos.AxisError
              THEN
                  Status := STS_0_IDLE;
              END_IF;
              
              //    
              //  ###############################################################################################
              //  STATUS = IDLE
              // ###############################################################################################
              
          STS_0_IDLE:
              
              
              S120_SinaPos.Jog1 := FALSE;
              S120_SinaPos.Jog2 := FALSE;
              S120_SinaPos.AxisRef := FALSE;
              S120_SinaPos.ExecuteMode := FALSE;
              S120_SinaPos.CancelTraversing := TRUE;
              S120_SinaPos.IntermediateStop := FALSE;
              
              WriteRefPos.Enable := FALSE;
              Write_P2507.Enable := FALSE;
              Read_P2507.Enable := FALSE;
              Write_P0971.Enable := FALSE;
              Read_P0971.Enable := FALSE;
             
              
              
              Sts.S120.TargetApply := FALSE;
              
              
              IF Ctrl.S120.Preset
              THEN
                  Status := STS_DIRECT_HOME;
                  
              ELSIF Ctrl.S120.Jog_Minus OR Ctrl.S120.Jog_Plus
              THEN
                  Status := STS_MOVE_VEL;
                  
              ELSIF (Ctrl.S120.Positioining OR CIn.Manager.Control_ON) 
              THEN
                  
                  Status := STS_POSITIONING_START;
                  
              END_IF;
              
              
              // Mode pos must have a valid value.Default is Mode 2
              // 
              IF S120_SinaPos.ModePos < MODE_1_RELATIVE_POSITIONING OR S120_SinaPos.ModePos > MODE_8_JOG_INCREMENTAL
              THEN
                  S120_SinaPos.ModePos := MODE_2_ABSOLUTE_POSITIONING;
              END_IF;
              
              //    
              //  ###############################################################################################
              //  STATUS = DIRECT HOME
              // ###############################################################################################
              
              
          STS_DIRECT_HOME:
              
              S120_SinaPos.ModePos := MODE_5_SET_HOME_POSITION;
              S120_SinaPos.EnableAxis := TRUE;
              
              WriteRefPos.Enable := TRUE;
              
              
              S120_SinaPos.ExecuteMode := FALSE;
              
              IF (S120_SinaPos.ActMode = MODE_5_SET_HOME_POSITION)
                  AND
                  WriteRefPos.Done
                  AND 
                  Sts.Standstill
              THEN
                  WriteRefPos.Enable := FALSE;
                  
                  //#S120_SinaPos.AxisRef := TRUE;
                  
                  S120_SinaPos.ExecuteMode := TRUE;
                  
                  IF S120_SinaPos.AxisRef THEN
                      
                      IF Config.Ax.Encoder_is_Absolute
                      THEN
                          Status += 1;
                        
                      ELSE
                          Sts.EncIncremental_Preset_OK := TRUE;
                      END_IF;
                  END_IF;
                  
              END_IF;
              
              
          STS_DIRECT_HOME_Write_P2507:
              
              Write_P2507.Enable := TRUE;;
              
              IF Write_P2507.Done  THEN
                  Write_P2507.Enable := FALSE;
                  Status += 1;
              END_IF;
              
          STS_DIRECT_HOME_Read_P2507:
              
              Read_P2507.Enable := TRUE;
              
              IF Read_P2507.Done THEN
                  Read_P2507.Enable := FALSE;
                  IF Read_P2507.ValueReadReal = 3.0 OR Read_P2507.ValueReadDint = 3  THEN
                      Status += 1;
                  END_IF;
                  
              END_IF;
              
          STS_DIRECT_HOME_Write_P0971:
              
              Write_P0971.Enable := TRUE;
              
              IF Write_P0971.Done THEN
                  Write_P0971.Enable := FALSE;
                  Status += 1;
              END_IF;
              
          STS_DIRECT_HOME_Read_P0971:
              
              Read_P0971.Enable := TRUE;
              
              IF Read_P0971.Done THEN
                  Read_P0971.Enable := FALSE;
                  IF Read_P0971.ValueReadDint = 0 AND Read_P0971.ValueReadReal = 0.0  THEN
                      Status += 1;
                  END_IF;
              END_IF;
              
          STS_DIRECT_HOME_END:
              
              Pers_Data.EncoderAbsolute_Preset_OK := TRUE;
              
              
              
              
              //    
              //  ###############################################################################################
              //  STATUS = MOVE VELOCITY
              // ###############################################################################################
              
              
          STS_MOVE_VEL:
              
              S120_SinaPos.ModePos := MODE_7_JOG;
              S120_SinaPos.EnableAxis := TRUE;
              S120_SinaPos.CancelTraversing := TRUE;
              S120_SinaPos.Jog1 := FALSE;
              S120_SinaPos.Jog2 := FALSE;
              
              
              IF NOT S120_SinaPos.AxisEnabled OR (S120_SinaPos.ActMode <> MODE_7_JOG)
              THEN
                  ;
              ELSE
                  S120_SinaPos.Jog1 := Ctrl.S120.Jog_Minus;
                  S120_SinaPos.Jog2 := Ctrl.S120.Jog_Plus;
              END_IF;
              
              
              
              
              //    
              //  ###############################################################################################
              //  STATUS = MOVE TO POSIITION
              // ###############################################################################################
              
              
          STS_POSITIONING_START:
              
              S120_SinaPos.ModePos := MODE_2_ABSOLUTE_POSITIONING;
              S120_SinaPos.EnableAxis := TRUE;
              S120_SinaPos.CancelTraversing := TRUE;
              S120_SinaPos.IntermediateStop := Ctrl.S120.Positioining;
              
              
              // Convert target position from Eng.Unit To LU
              // 
              Ctrl.S120.TargetPos := (Ctrl.Pos * 1000);
              
              //
              IF #S120_SinaPos.ExecuteMode AND NOT #S120_SinaPos.EPosZSW2.%X15
              THEN
                  #S120_SinaPos.ExecuteMode := FALSE;
              END_IF;
              
              
              
              IF NOT #Sts.S120.TargetApply
                  AND
                  #S120_SinaPos.AxisEnabled
                  AND
                  (#S120_SinaPos.ActMode = #MODE_2_ABSOLUTE_POSITIONING)
                  AND #Ctrl.S120.Positioining
              THEN
                  
                  #S120_SinaPos.ExecuteMode := TRUE;
                  #S120_SinaPos.Position := #Ctrl.S120.TargetPos;
                  #Sts.S120.TargetApply := TRUE;
                  
              END_IF;
              
              
              
              IF (#Ctrl.S120.TargetPos <> #S120_SinaPos.Position)
                  OR
                  NOT #S120_SinaPos.AxisEnabled
                  OR
                  (#S120_SinaPos.ActMode <> #MODE_2_ABSOLUTE_POSITIONING)
                 // OR
                 // (#Sts.S120.TargetApply AND #S120_SinaPos.AxisPosOk AND NOT #Sts.InTargetPosition)
                  OR
                  NOT #Ctrl.S120.Positioining
                
              THEN
                  #Sts.S120.TargetApply := FALSE;
                  #S120_SinaPos.ExecuteMode := FALSE;
              END_IF;
              
              IF #Sts.S120.TargetApply AND NOT #S120_SinaPos.EPosZSW2.%X15
              THEN
                  #Sts.S120.TargetApply := FALSE;
              END_IF;
             
              
              S120_SinaPos.ExecuteMode := Sys.Clock_250MS AND  S120_SinaPos.AxisEnabled
              AND
              (S120_SinaPos.ActMode = MODE_2_ABSOLUTE_POSITIONING);
             
              
              
          ELSE
              Status := STS_STOP;
              
      END_CASE;














   END_REGION

   REGION "Reset enable Drive"
      IF (NOT (DSI.PowerEnable) OR NOT (Drive.Infeed_ON) OR S120_SinaPos.Lockout OR S120_SinaPos.AxisError OR (((Status = #STS_STOP) OR (Status = #STS_0_IDLE)) AND Sts.Standstill)) THEN
         S120_SinaPos.EnableAxis := FALSE;
      END_IF;
   END_REGION

   REGION "S120 EPOS - Vel / Acc / Dec for MDI positioning"
      // Coversione velocità in LU/min
      //
      S120_SinaPos.Velocity := ((IN1 := Ctrl.Vel, IN2 := Config.Ax.MaxVel_S120_P2571));
      S120_SinaPos.Velocity := (IN1 := S120_SinaPos.Velocity, IN2 := 0);


      // Conversione acc/dec in %

      S120_SinaPos.OverAcc := (IN1 := 100,IN2 :=  (Ctrl.Acc / Config.Ax.MaxAcc_S120_P2572 * 100.0));
      S120_SinaPos.OverAcc := (IN1 := S120_SinaPos.OverAcc, IN2 := 1);


      S120_SinaPos.OverDec := (IN1 := 100, IN2 := (Ctrl.Dec / Config.Ax.MaxDec_S120_P2573 * 100.0));
      S120_SinaPos.OverDec := (IN1 := S120_SinaPos.OverDec, IN2 := 1);


      // Velocity override
      // 

      S120_SinaPos.OverV := 100;

      IF CIn.VelocityOverride.Enable THEN
          S120_SinaPos.OverV := (CIn.VelocityOverride.Value);
      END_IF;


      // Reference position P2599
      //
      IF Ctrl.ReloadPosition THEN
          ReferencePosition := Pers_Data.Persistent_ActualPosition;
          
      END_IF;

      IF Ctrl.Preset THEN
          ReferencePosition := HMI.PresetPosition;
      END_IF;


      // P2599 = EPOS reference point coordinate value
      //
      WriteRefPos(ReadWrite := 1,
                      ParNo := 2599,
                    Index := 0,
                    AxisNo := Drive.AxisID,
                    HW_ID := Drive.AccessPoint,
                    TokenChain := Drive.TokenChain,
                    ValueWriteDint := (ReferencePosition * 1000.0));


      // P2507 = LR absolute encoder adjustment status = 2
      // 
       Write_P2507(ReadWrite      := 1,
                    ParNo          := 2507,
                    Index          := 0,
                    AxisNo         := Drive.AxisID,
                    HW_ID          := Drive.AccessPoint,
                    TokenChain     := Drive.TokenChain,
                    ValueWriteReal := 2.0,
                    ValueWriteDint := 2);
       
       // P2507 = LR absolute encoder adjustment status = 3 = Endcoder  
       //
       Read_P2507(ReadWrite      := 0,
                    ParNo          := 2507,
                    Index          := 0,
                    AxisNo         := Drive.AxisID,
                    HW_ID          := Drive.AccessPoint,
                    TokenChain     := Drive.TokenChain);

      // P971 = Save drive object parameters = 1 = Exe
      // 
        Write_P0971(ReadWrite := 1,
                     ParNo := 971,
                     Index := 0,
                     AxisNo := Drive.AxisID,
                     HW_ID := Drive.AccessPoint,
                     TokenChain := Drive.TokenChain,
                     ValueWriteDint := 1,
                     ValueWriteReal := 1.0
        );


        // P971 = Save drive object parameters = 0 = Done
        // 
        Read_P0971(ReadWrite  := 0,
                    ParNo      := 971,
                    Index      := 0,
                    AxisNo     := Drive.AxisID,
                    HW_ID      := Drive.AccessPoint,
                    TokenChain := Drive.TokenChain);
        
       
        

   END_REGION

   REGION "S120 EPOS - Function CALL"
      #S120_SinaPos(
         en := TRUE,
         Positive := FALSE,
         Negative := FALSE,
         AckError := AreaInterface.RstAlarms,
         Position := Ctrl.S120.TargetPos,
         HWIDSTW := HW_ID_TEL111,
         HWIDZSW := HW_ID_TEL111
      );

      #S120_SinaPos.Q;
   END_REGION

   REGION "Save actual position for reloading pourpose"
      IF S120_SinaPos.AxisRef THEN
          Pers_Data.Persistent_ActualPosition := (S120_SinaPos.ActPosition) / 1000.0;
      END_IF;

   END_REGION

   REGION "Run"
      #TON_Fan_DelayOff(
         IN := (NOT (Req) AND Ctrl.Fan),
         PT := Config.Fan.DelayOff
      );

      Ctrl.Fan := (((S120_SinaPos.AxisEnabled OR Ctrl.Fan) AND Fan_M.MotorSts.RunPermitted) AND Config.Fan.Presence);
      #TON_Fan_DelayOff.Q;
      IF #TON_Fan_DelayOff.Q THEN
         Ctrl.Fan := FALSE;
      END_IF;
   END_REGION

   REGION "Device"
      #Fan_M(
         en := Config.Fan.Presence,
         ThermalProtection := DataIn.Fan_M_ThermalProtection,
         FdbkRunning := DataIn.Fan_M_Feedback,
         FeedbackTimeout := T#1S,
         Alarm := Alarm.Fan_M,
         Contactor => DataOut.Fan_M_Contactor
      );

      Fan_M.MotorCtrl.SafeStop := AreaInterface.EStop;
      Fan_M.MotorCtrl.Rst := AreaInterface.RstAlarms;
      Fan_M.MotorCtrl.Run := Ctrl.Fan;
      IF Config.Fan.Presence THEN
         #Fan_M.Q;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         DataOut.Fan_M_Contactor := FALSE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Alarm.Fan_M.ThermalProtection := FALSE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Alarm.Fan_M.Feedback := FALSE;
      END_IF;
   END_REGION

   REGION "Coordination Out"
      COut.Infeed_ReqON := NOT ((((NOT (Ctrl.Minus_Vel) AND NOT (Ctrl.Plus_Vel)) AND NOT (Ctrl.MoveToPos)) AND NOT (S120_SinaPos.AxisEnabled)));
      COut.CtrlSafe := (NOT (TON_NoPendingCmd.IN) OR (CIn.Manager.Control_ON AND NOT (Ctrl.StopDueDoorOpeningRequest)));
      COut.Homed := S120_SinaPos.AxisRef;
      COut.Standstill := Sts.S120.Standstill;
      COut.Enabled := S120_SinaPos.AxisEnabled;
      COut.InPosition := Sts.InTargetPosition;
      COut.MinusCheckNext := (Ctrl.Minus_Vel OR (Ctrl.MoveToPos AND (Sts.MissingToTarget < 0.0)));
      COut.PlusCheckNext := (Ctrl.Plus_Vel OR (Ctrl.MoveToPos AND (Sts.MissingToTarget = 0.0)));
      COut.MinusRunning := (NOT (Sts.S120.Standstill) AND Sts.S120.IsRunningNegative);
      COut.PlusRunning := (NOT (Sts.S120.Standstill) AND Sts.S120.IsRunningPositive);
      COut.ActualPosition := Sts.ActualPosition;
   END_REGION

   REGION "Warning Missing conditions"
      #TON_MinusCnd(
         IN := (COut.MinusCheckNext AND NOT (Sts.Minus_Cnd)),
         PT := Config.DelayMissingCondition
      );

      #TON_PlusCnd(
         IN := (COut.PlusCheckNext AND NOT (Sts.Plus_Cnd)),
         PT := Config.DelayMissingCondition
      );

      #TON_MinusCnd.Q;
      IF (COut.MinusCheckNext AND Sts.Minus_Cnd) THEN
         Warning.Minus_CndMissing := FALSE;
      ELSIF #TON_MinusCnd.Q THEN
         Warning.Minus_CndMissing := TRUE;
      END_IF;
      #TON_PlusCnd.Q;
      IF (COut.PlusCheckNext AND Sts.Plus_Cnd) THEN
         Warning.Plus_CndMissing := FALSE;
      ELSIF #TON_PlusCnd.Q THEN
         Warning.Plus_CndMissing := TRUE;
      END_IF;
   END_REGION

   REGION "Standstill"
      Sts.Standstill := (COut.Standstill OR DSI.DevicesInSafeState);
   END_REGION

   REGION "No pending commands"
      #TON_NoPendingCmd(
         IN := ((((NOT (Sys.FirstPLCCycle) AND NOT (Ctrl.Preset)) AND NOT (Ctrl.Minus_Vel)) AND NOT (Ctrl.Plus_Vel)) AND NOT (Ctrl.MoveToPos)),
         PT := t#1s
      );

      #TON_NoPendingCmd.Q;
   END_REGION

   REGION "Warning presence"
      Sts.WarningPresence := NOT ((((((((NOT (Warning.NotAutReady) AND NOT (Warning.Minus_CndMissing)) AND NOT (Warning.Plus_CndMissing)) AND NOT (Warning.S120_Warning)) AND NOT (Warning.Ax_NotHomed)) AND NOT (Warning.Ax_FlyingHome)) AND NOT (Warning.Ax_SwLimitMinus)) AND NOT (Warning.Ax_SwLimitPlus)));
   END_REGION

   REGION "Alarm presence"
      Sts.AlarmPresence := (NOT (((((((((NOT (Alarm.S120_Fault) AND NOT (Alarm.S120_ComErr)) AND NOT (Alarm.S120_WriteParErr)) AND NOT (Alarm.Ax_NotHomed)) AND NOT (Alarm.Ax_ErrSelMode)) AND NOT (Alarm.Ax_ErrOverride)) AND NOT (Alarm.Ax_InvalidTraversingBlockNr)) AND NOT (Alarm.HwLimitMinus)) AND NOT (Alarm.HwLimitPlus))) OR NOT (((NOT (Alarm.BrakeTimeOut) AND NOT (Fan_M.MotorSts.AlarmPresence)) AND NOT (CIn.ExternalAlarms))));
   END_REGION

   REGION "Stop aborting"
      Ctrl.StopAborting := (((AreaInterface.Cycle AND Sts.Standstill) OR (AreaInterface.Cycle AND Ctrl.StopAborting) OR AreaInterface.Aut OR CIn.Manager.Control_ON) AND Sts.AlarmPresence);
   END_REGION

   REGION "Collect machine to zone interface"
      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmPresence;
      MachineInterface.Aborting := Ctrl.StopAborting;
      MachineInterface.MotionsStandStill := TON_NoPendingCmd.Q AND Sts.Standstill;
      MachineInterface.AckStopInPhase := Ctrl.StopInPhase AND MachineInterface.MotionsStandStill;
      MachineInterface.AckStopProgrammed := Ctrl.StopProgrammed AND MachineInterface.MotionsStandStill;
      MachineInterface.AlarmsPresence := Sts.AlarmPresence;
      MachineInterface.WarningPresence := Sts.WarningPresence;

   END_REGION

   REGION "Warning Machine not ready for automatic"
      IF AreaInterface.Cycle THEN
         Warning.NotAutReady := FALSE;
      ELSIF (AreaInterface.CheckAutReady AND NOT (MachineInterface.AutReady)) THEN
         Warning.NotAutReady := TRUE;
      END_IF;
   END_REGION

   REGION "HMI Status Positioning EPOS Machine"
      // Area dati Status per HMI sull'azionamento

      HMI.Sts.Enabled := S120_SinaPos.AxisEnabled;
      HMI.Sts.Standstill := Sts.Standstill;
      HMI.Sts.Homed := COut.Homed;
      HMI.Sts.Alarm := Sts.AlarmPresence;
      HMI.Sts.Warning := Sts.WarningPresence;
      HMI.Sts.Plus_Run := COut.PlusRunning;
      HMI.Sts.Minus_Run := COut.MinusRunning;
      HMI.Sts.InTargetPos := Sts.InTargetPosition;
      HMI.Sts.MinPosReached := COut.MinusLsSwReached OR COut.MinusLimitReached;
      HMI.Sts.MaxPosReached := COut.PlusLsSwReached OR COut.PlusLimitReached;
      HMI.Sts.TargetPos := COut.ActualTargetPos;
      HMI.Sts.ActualPos := COut.ActualPosition;
      HMI.Sts.ActualVel := COut.ActualVelocity;



   END_REGION


END_FUNCTION_BLOCK
