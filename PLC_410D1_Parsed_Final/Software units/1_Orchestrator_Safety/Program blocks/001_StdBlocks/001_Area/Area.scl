// Block: Area
// Title: Info

FUNCTION_BLOCK "Area"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Info
   VAR_INPUT
      Estop : Bool;
      DataIn : Struct
         SelMan : Bool;
         SelAut : Bool;
         PbStart : Bool;
         PbStop : Bool;
         PbStopProgrammed : Bool;
         PbAckRst : Bool;
      END_STRUCT;
      Config : AreaConfig;
      MachinesStatus : MachineStatus;
      ForceStopInPhase : Bool;
      ForceStopProgrammed : Bool;
      ResetTimersTimeoutStops : Bool;
   END_VAR

   VAR_OUTPUT
      AreaInterface : AreaInterface;
      DataOut : Struct
         horn : Bool;
         lampReady : Bool;
         lampCycle : Bool;
         LampWarningPresence : Bool;
         LampAlarmPresence : Bool;
      END_STRUCT;
      SilencingAlarms : Bool;
      HMI_StatusDinamicText : Int;
   END_VAR

   VAR
      pbStartOneShotAux : Bool;
      RstAlrOneShot1 : Bool;
      RstAlrOneShot2 : Bool;
      CycleStopImmediately : Bool;
      CycleStopInPhase : Bool;
      CycleStarted : Bool;
      CycleStopProgrammed : Bool;
      CycleOn : Bool;
      ManAuxPe : Bool;
      ManAuxNe : Bool;
      ManPositiveEdge : Bool;
      ManNegativeEdge : Bool;
      AutAuxPe : Bool;
      AutAuxNe : Bool;
      AutPositiveEdge : Bool;
      AutNegativeEdge : Bool;
      AlarmLAuxPe : Bool;
      CycleAuxPe : Bool;
      ResetAlarmsCmd : Bool;
      tonDelayPbStart : IEC_TIMER;
      tonDelayRstAck : IEC_TIMER;
      tonTimeOutStopPhase : IEC_TIMER;
      tonTimeOutStopProgr : IEC_TIMER;
      tonTimeOutResetAlr : IEC_TIMER;
   END_VAR

   VAR_TEMP
      AreaEStop : Bool;
      ManMode : Bool;
      AutMode : Bool;
      pbStartOneShot : Bool;
      CycleStop : Bool;
      CycleCheckStartCnd : Bool;
      PbAckRstDelayed : Bool;
      TimeOutPT : Time;
   END_VAR

   VAR CONSTANT
      HMI_STATUS_CODE_00_INVALID : Int;
      HMI_STATUS_CODE_01_EMERGENCY : Int;
      HMI_STATUS_CODE_02_SEL_0 : Int;
      HMI_STATUS_CODE_11_MAN : Int;
      HMI_STATUS_CODE_21_AUT_NOT_READY : Int;
      HMI_STATUS_CODE_22_AUT_READY : Int;
      HMI_STATUS_CODE_31_CYCLE_STARTING : Int;
      HMI_STATUS_CODE_32_CYCLE_ON : Int;
      HMI_STATUS_CODE_41_STOP_IMMEDIATELY : Int;
      HMI_STATUS_CODE_42_STOP_IN_PHASE : Int;
      HMI_STATUS_CODE_43_STOP_PROGRAMMED : Int;
   END_VAR


BEGIN
   REGION "Info"
      //=============================================================================
      //PM FORMING
      //-----------------------------------------------------------------------------
      // Library: StandardBlocks
      // Tested with: S7-1518TF
      // Engineering: TIA Portal V18
      // Restrictions: -
      // Requirements: S7-1500
      // Functionality: Area Manager
      //
      // v1.0.0  28/12/2022 
      //=============================================================================


   END_REGION

   REGION "EStop active"
      AreaInterface.EStop := Estop;
      AreaEStop := Estop;
   END_REGION

   REGION "Mode Manual / Automatic"
      AreaInterface.Man := ((NOT (AreaEStop) AND DataIn.SelMan) AND NOT (DataIn.SelAut));
      ManMode := ((NOT (AreaEStop) AND DataIn.SelMan) AND NOT (DataIn.SelAut));
      AreaInterface.Aut := ((NOT (AreaEStop) AND DataIn.SelAut) AND NOT (DataIn.SelMan));
      AutMode := ((NOT (AreaEStop) AND DataIn.SelAut) AND NOT (DataIn.SelMan));
   END_REGION

   REGION "Mode manual positive / negative Edge"
      ManPositiveEdge := PosEdge(ManMode, ManAuxPe);
      ManNegativeEdge := NegEdge(ManMode, ManAuxNe);
   END_REGION

   REGION "Mode manual one shots"
      AreaInterface.ManOneShot := (ManPositiveEdge OR ManNegativeEdge);
   END_REGION

   REGION "Mode automatic positive / negative Edge"
      AutPositiveEdge := PosEdge(AutMode, AutAuxPe);
      AutNegativeEdge := NegEdge(AutMode, AutAuxNe);
   END_REGION

   REGION "Mode automatic one shots"
      AreaInterface.AutOneShot := (AutPositiveEdge OR AutNegativeEdge);
   END_REGION

   REGION "Timeout reset command"
      #tonTimeOutResetAlr(
         IN := ResetAlarmsCmd,
         PT := Config.TimeOutResetAlarms
      );

      #tonTimeOutResetAlr.Q;
   END_REGION

   REGION "Pb Ack/Rst delayed"
      #tonDelayRstAck(
         IN := DataIn.PbAckRst,
         PT := T#2S
      );

      #tonDelayRstAck.Q;
      PbAckRstDelayed := #tonDelayRstAck.Q;
   END_REGION

   REGION "Alarms reset command (need ACK)"
      IF tonTimeOutResetAlr.Q THEN
         ResetAlarmsCmd := FALSE;
      ELSIF (PosEdge(PbAckRstDelayed) OR NegEdge(Estop)) THEN
         ResetAlarmsCmd := TRUE;
      END_IF;
   END_REGION

   REGION "Alarms resetting command to interface"
      AreaInterface.RstAlarms := ResetAlarmsCmd;
   END_REGION

   REGION "Alarms silencing command out"
      SilencingAlarms := NOT ((NOT (DataIn.PbAckRst) AND NOT (AreaEStop)));
   END_REGION

   REGION "Cause of immediately stop = Stop in phase with a short timeout"
      IF (((NOT (CycleStarted) AND NOT (CycleOn)) AND NOT (DataIn.PbStart)) OR ((NOT (CycleStarted) AND NOT (CycleOn)) AND NOT (AutMode))) THEN
         CycleStopImmediately := FALSE;
      ELSIF (NOT (DataIn.SelAut) OR AreaEStop OR (DataIn.PbStop AND NOT (CycleOn))) THEN
         CycleStopImmediately := TRUE;
      END_IF;
   END_REGION

   REGION "Stop in phase timeout time preset"
      IF CycleStopImmediately THEN
         TimeOutPT := Config.TimeOutStopImmediate;
      END_IF;
   END_REGION

   REGION "Request of a stop with machines in phase for next start"
      #tonTimeOutStopPhase(
         IN := (CycleStopInPhase AND NOT (ResetTimersTimeoutStops)),
         PT := TimeOutPT
      );

      IF ((NOT (CycleStarted) AND NOT (CycleOn)) AND NOT (DataIn.PbStart)) THEN
         CycleStopInPhase := FALSE;
      ELSIF (DataIn.PbStop OR MachinesStatus.AtLeastOneMachineIsAborting OR ForceStopInPhase OR CycleStopImmediately) THEN
         CycleStopInPhase := TRUE;
      END_IF;
      AreaInterface.StopInPhase := CycleStopInPhase;
      #tonTimeOutStopPhase.Q;
   END_REGION

   REGION "Request of a programmed stop (e.g. at the end of part)"
      #tonTimeOutStopProgr(
         IN := (CycleStopProgrammed AND NOT (ResetTimersTimeoutStops)),
         PT := Config.TimeOutStopProgrammed
      );

      pbStartOneShot := PosEdge(DataIn.PbStart, pbStartOneShotAux);
      IF (((NOT (CycleStarted) AND NOT (CycleOn)) AND NOT (DataIn.PbStart)) OR CycleStopInPhase) THEN
         CycleStopProgrammed := FALSE;
      ELSIF ((PosEdge(DataIn.PbStart, pbStartOneShotAux) AND CycleOn) OR DataIn.PbStopProgrammed OR ForceStopProgrammed) THEN
         CycleStopProgrammed := TRUE;
      END_IF;
      AreaInterface.StopProgrammed := CycleStopProgrammed;
      #tonTimeOutStopProgr.Q;
   END_REGION

   REGION "Cumulative Stop Cycle"
      CycleStop := (CycleStopImmediately OR (CycleStopInPhase AND MachinesStatus.AllMachineAckStopInPhase) OR (CycleStopInPhase AND tonTimeOutStopPhase.Q) OR (CycleStopProgrammed AND MachinesStatus.AllMachineAckStopProgrammed) OR (CycleStopProgrammed AND tonTimeOutStopProgr.Q));
   END_REGION

   REGION "Start Cycle"
      IF (CycleOn OR CycleStop) THEN
         CycleStarted := FALSE;
      ELSIF tonDelayPbStart.Q THEN
         CycleStarted := TRUE;
      END_IF;
      IF CycleStop THEN
         CycleOn := FALSE;
      ELSIF (CycleStarted AND NOT (DataIn.PbStart)) THEN
         CycleOn := TRUE;
      END_IF;
      AreaInterface.Cycle := CycleOn;
   END_REGION

   REGION "Cycle positve edge one shot"
      AreaInterface.CycleOneShot := PosEdge(CycleOn, CycleAuxPe);
   END_REGION

   REGION "Check/enable cycle start"
      #tonDelayPbStart(
         IN := (((((AutMode AND NOT (CycleStarted)) AND NOT (CycleOn)) AND DataIn.PbStart) AND NOT (CycleStop)) AND MachinesStatus.AllMachineAutReady),
         PT := T#2S
      );

      CycleCheckStartCnd := ((((AutMode AND NOT (CycleStarted)) AND NOT (CycleOn)) AND DataIn.PbStart) AND NOT (CycleStop));
      AreaInterface.CheckAutReady := ((((AutMode AND NOT (CycleStarted)) AND NOT (CycleOn)) AND DataIn.PbStart) AND NOT (CycleStop));
      #tonDelayPbStart.Q;
   END_REGION

   REGION "Horn cycle starting / restarting"
      DataOut.horn := (((((CycleCheckStartCnd AND NOT (CycleStarted)) AND MachinesStatus.AllMachineAutReady) AND NOT (Estop)) AND NOT (Sys.LampTestMem)) OR Sys.LampTest);
   END_REGION

   REGION "Lamp automatic ready"
      DataOut.lampReady := ((((AutMode AND MachinesStatus.AllMachineAutReady) AND NOT (CycleOn)) AND NOT (Sys.LampTestMem)) OR Sys.LampTest);
   END_REGION

   REGION "Lamp automatic cycle on"
      DataOut.lampCycle := ((((((((CycleCheckStartCnd AND MachinesStatus.AllMachineAutReady) AND Sys.Clock_500MS) OR CycleStarted OR CycleOn) AND NOT (CycleStopInPhase)) AND NOT (CycleStopProgrammed)) OR (CycleStopInPhase AND Sys.Clock_1S) OR (CycleStopProgrammed AND Sys.Clock_2S)) AND NOT (Sys.LampTestMem)) OR Sys.LampTest);
   END_REGION

   REGION "Lamp warning presence"
      DataOut.LampWarningPresence := ((MachinesStatus.AtLeastOneWngPresence AND NOT (Sys.LampTestMem)) OR Sys.LampTest);
   END_REGION

   REGION "Lamp alarm presence"
      DataOut.LampAlarmPresence := ((MachinesStatus.AtLeastOneAlrPresence AND NOT (Sys.LampTestMem)) OR Sys.LampTest);
   END_REGION

   REGION "HMI dinamic text fot Area Status"
      HMI_StatusDinamicText := HMI_STATUS_CODE_00_INVALID;

      IF      CycleStopImmediately THEN 
          HMI_StatusDinamicText := HMI_STATUS_CODE_41_STOP_IMMEDIATELY;

      ELSIF   CycleStopInPhase THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_42_STOP_IN_PHASE;

      ELSIF   CycleStopProgrammed THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_43_STOP_PROGRAMMED;
          
      ELSIF   CycleOn THEN   
          HMI_StatusDinamicText := HMI_STATUS_CODE_32_CYCLE_ON;

      ELSIF  tonDelayPbStart.IN OR CycleStarted THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_31_CYCLE_STARTING;


      ELSIF   AutMode AND MachinesStatus.AllMachineAutReady THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_22_AUT_READY;

      ELSIF   AutMode THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_21_AUT_NOT_READY;

      ELSIF  Estop THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_01_EMERGENCY;

      ELSIF   NOT ManMode AND NOT AutMode THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_02_SEL_0;

      ELSIF   ManMode THEN
          HMI_StatusDinamicText := HMI_STATUS_CODE_11_MAN;

      END_IF;


   END_REGION


END_FUNCTION_BLOCK
