FUNCTION_BLOCK "MsgManager"
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      Ack : Bool;   // Command from area for ack messages
   END_VAR

   VAR_OUTPUT 
      MessagePresence : Bool;
      NewMessage : Bool;
      MessageCount : Int;
   END_VAR

   VAR_IN_OUT 
      Messages : Array[*] of Bool;   // Write from plc the respective message bit
      MessagesHMI : Array[*] of Word;   // Word for HMI tags
      MessagesACK : Array[*] of Word;   // Word for ack messages (internal use)
   END_VAR

   VAR 
      MsgDim : DInt;
      HmiMsgDim : DInt;
      AckMsgDim : DInt;
      MsgCount : Int;
      Status : Int;
      IndexBuild : Int;
      IndexCompare : Int;
      LoopStart : Int;
      LoopEnd : Int;
      HMIIndex : Int;
      CompareWord : Word;
      A : Word;
      MvBlkVar_ErrorID : Int;
   END_VAR

   VAR_TEMP 
      ArchiveMsgDimension : UDInt;
      ArchiveHmiMsgDimension : UDInt;
      ArchiveAckMsgDimension : UDInt;
   END_VAR

   VAR CONSTANT 
      "0_IDLE" : Int := 0;
      "1_BUILD_HMI_WORD" : Int := 1;
      "2_CHECK_NEXT_INDEX" : Int := 2;
      "6_COUNT_AND_NEW_ALARM" : Int := 6;
   END_VAR


BEGIN
	
	REGION Info
	    
	    //=============================================================================
	    //PM FORMING
	    //-----------------------------------------------------------------------------
	    // Library: StandardBlocks
	    // Tested with: S7-1518TF
	    // Engineering: TIA Portal V18
	    // Restrictions: -
	    // Requirements: S7-1500
	    // Functionality: Message Manager
	    //
	    // v1.0.0  28/12/2022 
	    // v1.1.0  14/02/2023  New optimized version, removed timer for lamp and acustic signal
	    // v1.1.1  09/05/2023  Remove step 5-Init Values  
	    //=============================================================================
	    
	END_REGION
	
	
	REGION Array Limits
	    //Alarms archive dimension
	    #MsgDim := UPPER_BOUND(ARR := #Messages, DIM := 1);
	    #MsgDim := #MsgDim / 16;
	    #ArchiveMsgDimension := DINT_TO_UDINT(IN := #MsgDim);
	    //HMI Alarms archive dimension
	    #HmiMsgDim := UPPER_BOUND(ARR := #MessagesHMI, DIM := 1);
	    #ArchiveHmiMsgDimension := DINT_TO_UDINT(IN := #HmiMsgDim);
	    //Alarms ACK archive dimension
	    #AckMsgDim := UPPER_BOUND(ARR := #MessagesACK, DIM := 1);
	    #ArchiveAckMsgDimension := DINT_TO_UDINT(IN := #AckMsgDim);
	END_REGION
	
	REGION Init
	    IF "Sys".FirstPLCCycle THEN
	        //Clear message area
	        FILL_BLK(IN := 0,
	                 COUNT := #ArchiveHmiMsgDimension,
	                 OUT => #MessagesHMI[1]);
	        //Clear ACK message area
	        FILL_BLK(IN := 0,
	                 COUNT := #ArchiveAckMsgDimension,
	                 OUT => #MessagesACK[1]);
	        //Reset general bits
	        #MessagePresence := FALSE;
	        #NewMessage := FALSE;
	        #NewMessage := FALSE;
	    END_IF;
	END_REGION
	
	REGION Build HMI Archive
	    
	    CASE #Status OF
	            
	        #"0_IDLE":
	            #HMIIndex := 1;
	            #LoopStart := 1;
	            #LoopEnd := DINT_TO_INT(#MsgDim * 16);
	            #Status := #"1_BUILD_HMI_WORD";
	            
	        #"1_BUILD_HMI_WORD":
	            FOR #IndexBuild := 1 TO 16 DO
	                #A.%X15 := #Messages[#IndexBuild + (#LoopStart - 1)];
	                IF #IndexBuild < 16 THEN
	                    #A := SHR_WORD(IN := #A, N := 1);
	                END_IF;
	            END_FOR;
	            #MessagesHMI[#HMIIndex] := #A;
	            #HMIIndex += 1;
	            #LoopStart += 16;
	            #Status := #"2_CHECK_NEXT_INDEX";
	            
	         #"2_CHECK_NEXT_INDEX":
	            IF #LoopStart <= #LoopEnd THEN
	                #Status := #"1_BUILD_HMI_WORD";
	            ELSE
	                #Status := #"6_COUNT_AND_NEW_ALARM";
	            END_IF;
	            
	        #"6_COUNT_AND_NEW_ALARM":
	            #MsgCount := 0;
	            FOR #IndexCompare := 1 TO #HmiMsgDim DO
	                //Count alarms number
	                #MsgCount := ("BIT_COUNT"(#MessagesHMI[#IndexCompare])) + #MsgCount;
	                //Alarm presence
	                IF #MsgCount > 0 THEN
	                    #MessagePresence := TRUE;
	                ELSE
	                    #MessagePresence := FALSE;
	                END_IF;
	                //New alarm
	                #CompareWord := #MessagesACK[#IndexCompare] OR #MessagesHMI[#IndexCompare];
	                #CompareWord := #CompareWord XOR #MessagesACK[#IndexCompare];
	                IF #CompareWord <> W#0 THEN
	                    #NewMessage := TRUE;
	                END_IF;
	            END_FOR;
	            #Status := #"0_IDLE";
	    END_CASE;
	    
	    #MessageCount := #MsgCount;
	        
	END_REGION
	
	
	REGION Ack Alarms    
	    IF #Ack THEN
	        //Copy actual alarms into ACK Mask
	        #MvBlkVar_ErrorID := MOVE_BLK_VARIANT(SRC := #MessagesHMI, COUNT := #ArchiveHmiMsgDimension, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #MessagesACK);
	        #NewMessage := FALSE;
	    END_IF;
	END_REGION
	
END_FUNCTION_BLOCK

