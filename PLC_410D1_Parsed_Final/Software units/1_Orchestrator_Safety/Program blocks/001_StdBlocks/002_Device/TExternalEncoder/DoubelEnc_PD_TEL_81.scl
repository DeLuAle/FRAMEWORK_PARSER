FUNCTION_BLOCK "DoubelEnc_PD_TEL_81"
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      Encoder1 : DInt;
      Encoder2 : DInt;
      EncoderInUse : Int := 1;
      init : Bool;
      isAbsolute : Bool;
      hasOverflows : Bool;
      numberOfBits : UInt;
      FAK_Encoder1 : Real := 1.0;
      FAK_Encoder2 : Real := 1.0;
   END_VAR

   VAR_OUTPUT 
      EncoderActive : Int;
   END_VAR

   VAR_IN_OUT 
      tel81 {InstructionName := 'PD_TEL81'; LibVersion := '8.0'} : PD_TEL81;
   END_VAR

   VAR 
      statError : Bool;
      statConsiderOverflows : Bool;
      statOldPos1 : DInt;
      statOldPos2 : DInt;
      statPosRangeEnc1 : DInt;
      statPosRange2Enc1 : DInt;
      statPosRangeEnc2 : DInt;
      statPosRange2Enc2 : DInt;
      lastEncoderUsed : Int;
      switchDone : Bool;
      FAK_Rest_Enc_1 : Real;
      FAK_Rest_Enc_2 : Real;
      PulseDiff1 : Real;
      PulseDiff2 : Real;
   END_VAR

   VAR_TEMP 
      tempReqCmd : Bool;
      tempDPos1 : DInt;
      tempDPos2 : DInt;
   END_VAR


BEGIN
	//=============================================================================
	// SIEMENS AG
	// (c)Copyright 2016 All Rights Reserved
	//-----------------------------------------------------------------------------
	// Library:         -
	// Tested with:     S7-1500 FW V2.0 or higher
	// Engineering:     TIA Portal V14
	// Restrictions:    -
	// Functionality:   make the encoder telegramm 81
	//-----------------------------------------------------------------------------
	// Change log table:
	// Version    Date          Changes applied
	// 01.00.00   23.09.2016    First released version
	// 02.00.00   14.09.2020    Inserted double encoder
	// 02.00.01   10.10.2020    Inserted FAK managment
	//=============================================================================
	
	//Rilevazione cambio encoder
	IF #EncoderInUse <> #lastEncoderUsed THEN
	    #switchDone := FALSE;
	    #lastEncoderUsed := #EncoderInUse;
	END_IF;
	
	// init overflow calculation
	IF #init THEN
	    IF #hasOverflows = FALSE OR #numberOfBits >= 31 OR #numberOfBits < 2 THEN
	        #statConsiderOverflows := FALSE;
	    ELSE
	        #statConsiderOverflows := TRUE;
	        #statPosRangeEnc1 := 1;
	        #statPosRangeEnc1 := SHL(IN := #statPosRangeEnc1, N := #numberOfBits);
	        #statPosRange2Enc1 := #statPosRangeEnc1 / 2;
	    END_IF;
	    
	    #statOldPos1 := #Encoder1;
	    #statOldPos2 := #Encoder2;
	
	    #tel81.Input.G1_XIST1 := 0;
	    
	    #lastEncoderUsed := #EncoderInUse;
	    #switchDone := TRUE;
	END_IF;
	
	// Calculate the position difference
	#tempDPos1 := #Encoder1 - #statOldPos1;
	// Apply FAK to encoder 1
	IF #FAK_Encoder1 >= 0.9 AND #FAK_Encoder1 <= 1.1 THEN 
	    #PulseDiff1 := (DINT_TO_REAL(#tempDPos1) * #FAK_Encoder1) + #FAK_Rest_Enc_1;
	    #tempDPos1 := REAL_TO_DINT(#PulseDiff1);
	    #FAK_Rest_Enc_1 := #PulseDiff1 - DINT_TO_REAL(#tempDPos1);
	END_IF;
	
	#tempDPos2 := #Encoder2 - #statOldPos2;
	// Apply FAK to encoder 2
	IF #FAK_Encoder2 >= 0.9 AND #FAK_Encoder2 <= 1.1 THEN 
	    #PulseDiff2 := (DINT_TO_REAL(#tempDPos2) * #FAK_Encoder2) + #FAK_Rest_Enc_2;
	    #tempDPos2 := REAL_TO_DINT(#PulseDiff2);
	    #FAK_Rest_Enc_2 := #PulseDiff1 - DINT_TO_REAL(#tempDPos2);
	END_IF;
	
	IF #statConsiderOverflows THEN
	    IF #tempDPos1 > #statPosRange2Enc1 THEN
	        #tempDPos1 := #tempDPos1 - #statPosRangeEnc1;
	    ELSIF #tempDPos1 < - #statPosRange2Enc1 THEN
	        #tempDPos1 := #tempDPos1 + #statPosRangeEnc1;
	    END_IF;
	
	    IF #tempDPos2 > #statPosRange2Enc2 THEN
	        #tempDPos2 := #tempDPos2 - #statPosRangeEnc2;
	    ELSIF #tempDPos2 < - #statPosRange2Enc2 THEN
	        #tempDPos2 := #tempDPos2 + #statPosRangeEnc2;
	    END_IF;
	END_IF;
	
	// Incremental position has no overflows within 32 bits
	// only consider the changes
	
	IF #EncoderInUse = 1 THEN
	    IF NOT #switchDone THEN
	        //Aggiorna quota con l'altro encoder prima dello switch
	        #tel81.Input.G1_XIST1 := #tel81.Input.G1_XIST1 + DINT_TO_DWORD(#tempDPos2);
	        #switchDone := TRUE;
	    END_IF;
	    #tel81.Input.G1_XIST1 := #tel81.Input.G1_XIST1 + DINT_TO_DWORD(#tempDPos1);
	ELSE
	    IF NOT #switchDone THEN
	        //Aggiorna quota con l'altro encoder prima dello switch
	        #tel81.Input.G1_XIST1 := #tel81.Input.G1_XIST1 + DINT_TO_DWORD(#tempDPos1);
	        #switchDone := TRUE;
	    END_IF;
	    #tel81.Input.G1_XIST1 := #tel81.Input.G1_XIST1 + DINT_TO_DWORD(#tempDPos2);
	END_IF;
	
	#statOldPos1 := #Encoder1;
	#statOldPos2 := #Encoder2;
	
	// Error acknowledgement
	IF #statError THEN
	    IF #tel81.Output.G1_STW.AcknowledgeError THEN        // Acknowledge
	        #statError := FALSE;
	        #tel81.Input.G1_XIST2 := 0;
	        #tel81.Input.G1_ZSW.SensorError := FALSE;
	    END_IF;
	END_IF;
	
	// interprete the encoder control word  G1_STW
	#tempReqCmd := 
	    #tel81.Output.G1_STW.Command0Request OR 
	    #tel81.Output.G1_STW.Command1Request OR 
	    #tel81.Output.G1_STW.Command2Request OR 
	    #tel81.Output.G1_STW.RequestParkingEncoder;
	
	IF #isAbsolute = FALSE THEN
	    #tempReqCmd := #tempReqCmd OR #tel81.Output.G1_STW.AbsoluteValueCyclically;
	END_IF;
	
	IF #tempReqCmd THEN                    // any unsupported comands requested? ==> Error
	    #tel81.Input.G1_ZSW.SensorError := TRUE;
	    #tel81.Input.G1_XIST2 := 16#0F01;
	    #statError := TRUE;
	ELSE
	    
	    IF #tel81.Output.G1_STW.AbsoluteValueCyclically THEN   
	        // Request absolute value
	        IF #EncoderInUse = 1 THEN
	            #tel81.Input.G1_XIST2 := DINT_TO_DWORD(#Encoder1);
	        ELSE
	            #tel81.Input.G1_XIST2 := DINT_TO_DWORD(#Encoder2);
	        END_IF;
	
	        #tel81.Input.G1_ZSW.AbsoluteValueCyclicallyExecuted := TRUE;
	    ELSE
	        #tel81.Input.G1_ZSW.AbsoluteValueCyclicallyExecuted := FALSE;
	        #tel81.Input.G1_XIST2 := 0;
	    END_IF;
	    
	END_IF;
	
	#EncoderActive := #EncoderInUse;
	
	
	
	
END_FUNCTION_BLOCK

