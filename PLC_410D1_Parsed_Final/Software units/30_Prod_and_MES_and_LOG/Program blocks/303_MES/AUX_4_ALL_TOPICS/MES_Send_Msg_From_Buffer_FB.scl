FUNCTION_BLOCK "MES_Send_Msg_From_Buffer_FB"
{ S7_Optimized_Access := 'TRUE' ; Published := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      PT_TIMEOUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;
      PT_RETRY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;
      Lock : Bool;   // Blocco invio messaggi
   END_VAR

   VAR_IN_OUT 
      Buffer_msg : Array[*] of "MES_Msg";
      SEND : Struct
         ack : DInt;
         msg : "IPC_Msg_Generico";
      END_STRUCT;
      Err : "MES_Msg_Send_Err";
   END_VAR

   VAR 
      Status : UInt;
      index_MIN_Buffer : Int;
      index_MAX_Buffer : Int;
      Index_Send : Int;
      index_Retry : Int;
      index_Pop : Int;
      i : Int;
      ElemetsToMove : UDInt;
      RETVAL : DInt;
      TON_Timeout {InstructionName := 'TON_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TON_TIME;
      TON_Retry {InstructionName := 'TON_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TON_TIME;
      TON_RstTimeout {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;
      CORREZIONE_INDICE_0 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := -1;   // Indice base-0 per MOVE_BLK_VARIANT
   END_VAR

   VAR_TEMP 
      Found : Bool;
   END_VAR

   VAR CONSTANT 
      S0_INIT : UInt := 0;
      S1_CHOOSE : UInt := 1;
      S2_SEND : UInt := 2;
      S3_PAUSE : UInt := 3;
   END_VAR


BEGIN
	
	// Dimensione del buffer dei messaggi da inviare
	// 
	#index_MIN_Buffer := DINT_TO_INT(LOWER_BOUND(ARR := #Buffer_msg, DIM := 1));
	#index_MAX_Buffer := DINT_TO_INT(UPPER_BOUND(ARR := #Buffer_msg, DIM := 1));
	
	
	// Correzione indice zero per funzione MOVE_BLK_VARIANT
	// 
	// Counting at the parameters SRC_INDEX AND DEST_INDEX always begins with the low limit "0", regardless OF the later declaration OF the ARRAY."
	// 
	IF #index_MIN_Buffer > 0 THEN
	    #CORREZIONE_INDICE_0 := - #index_MIN_Buffer;
	END_IF;
	
	
	
	
	
	// Tempo per riprovare a trasmettere un messaggio non accettato
	// 
	#TON_Retry(IN := #Err.Msg_NotAccepted.Presence,
	           PT := #PT_RETRY);
	
	
	
	
	
	
	CASE #Status OF
	        
	        
	    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	    //
	    // INIZIALIZZA IL SEND CANCELLANDO MESSAGGIO
	    // 
	    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	        
	        
	    #S0_INIT:
	        
	        
	        #SEND.msg := "MES_Msg_Delete"();
	        
	        // MES risponde con ACK = 0 
	        // 
	        IF #SEND.ack = 0 THEN
	            
	            // Avvio Send..
	            
	            #Status := #"S1_CHOOSE";
	            
	            RETURN;
	        END_IF;
	        
	       
	        // MES non risponde al messaggio.. ACK persistente <> 0
	        //
	        // Timeout risposta MES
	        // 
	        #TON_Timeout(IN := TRUE,
	                     PT := #PT_TIMEOUT);
	        
	        IF #TON_Timeout.Q THEN
	            
	            #Err.TimeOut_ACK := TRUE;
	            
	            #Status := #S3_PAUSE;
	            
	        END_IF;
	            
	      
	        
	        
	        //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	        //
	        // SCELTA DELL'ELEMENTO DEL BUFFER DA INVIARE
	        // 
	        //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    
	        
	        
	    #S1_CHOOSE:
	        
	        #TON_Timeout(IN := FALSE,
	                     PT := #PT_TIMEOUT);
	        
	        
	        #Status := #S0_INIT; // Se non parte un send ritorna indietro se non si trova qulacosa da fare
	        
	        
	        // Interruzione se c'è un segnale di blocco invio messaggi
	        // 
	        IF #Lock THEN
	            RETURN;
	        END_IF;
	        
	        
	        
	        
	        // Trova elemento più vecchio e senza errori da inviare OPPURE il più vecchio con errori
	        // 
	        #Index_Send := -1;
	        #index_Retry := -1;
	        
	        FOR #i := #index_MAX_Buffer TO #index_MIN_Buffer BY -1 DO
	            
	            
	            // Avvio send nuovo messaggio
	            // 
	            IF #Buffer_msg[#i].Id <> 0 AND NOT #TON_Retry.Q AND #Index_Send = -1 THEN
	                
	                #Index_Send := #i;
	                #SEND.msg := #Buffer_msg[#i];
	                #Status := #"S2_SEND";
	                EXIT;
	                
	            END_IF;
	            
	                     
	            // Avvio send messaggio con errori da re.inviare  
	            // 
	            IF #Buffer_msg[#i].Id = #Err.Msg_NotAccepted.Msg.Id AND #TON_Retry.Q AND #index_Retry = -1 THEN
	                
	                #index_Retry := #i;
	                #SEND.msg := #Buffer_msg[#i];
	                #Status := #"S2_SEND";
	                EXIT;
	                    
	            END_IF;
	            
	        END_FOR;
	        
	        // Il messaggio con errore non c'è più..forse è andato fuori dal buffer
	        // 
	        IF #TON_Retry.Q AND #index_Retry = -1 THEN
	            
	            #Err.Msg_NotAccepted.Presence := FALSE;
	            #Err.Msg_NotAccepted.Msg := "MES_Msg_Delete"();
	            #Err.TimeOut_ACK := 0;
	            
	            // Ricomincia sequenza
	            // 
	            #Status := #S1_CHOOSE;
	            RETURN;
	            
	            
	        END_IF;
	            
	        
	        
	        
	        //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	        //
	        // ACK SEND DA MES
	        // 
	        //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     
	        
	       
	        
	    #S2_SEND:
	        
	        // Condizione non possibile = Non avere un messaggio in send
	        // 
	        IF #SEND.msg.Id <= 0 THEN
	            #Status := #S0_INIT;
	            RETURN;
	        END_IF;
	        
	        
	        
	        // MES sta rispondendo a un messaggio..
	        // 
	        IF #SEND.ack <> 0 THEN
	            
	            #Found := FALSE;
	            
	            // Ricerca posizione dove è il messaggio che è stato inviato perchè
	            // nel frattempo potrebbero esserci stati dei push che lo hanno spostato di posizione..
	            // 
	            // Questa volta la ricerca va dall'indice minimo al massimo perchè si presume che
	            // il buffer non deve essere molto pieno se la comunicazione con MES funziona
	            // 
	            FOR #i := #index_MIN_Buffer TO #index_MAX_Buffer DO
	                
	                // Trovato messaggio nel buffer...
	                // 
	                IF #Buffer_msg[#i].Id = #SEND.msg.Id THEN
	                    
	                    #Found := TRUE; // messaggio inviato esiste ancora ! 
	                    
	                    #index_Pop := #i;
	                    
	                    // Send eseguito con successo...
	                    // 
	                    IF #SEND.ack = #SEND.msg.Id THEN
	                        
	                       // Azzeramento errore risposta precedente con errore
	                       // 
	                        IF #SEND.msg.Id = #Err.Msg_NotAccepted.Msg.Id THEN
	                            #Err.Msg_NotAccepted.Presence := FALSE;
	                       END_IF;
	                       
	                       // Pop messaggio da buffer
	                       // 
	                       #RETVAL := "MES_Buffer_Pop"(Index := #index_Pop, Buffer_msg := #Buffer_msg);
	                        
	                        
	                       IF #RETVAL < "PROD_FUN_RESULT_OK" THEN
	                           #Err.Buffer_Pop.Presence := TRUE;
	                           #Err.Buffer_Pop.Code := #RETVAL;
	                       END_IF;
	                       
	                       
	                        // Send eseguito con codice di errore dal MES...
	                        // 
	                    ELSIF #SEND.ack < 0 THEN
	                        
	                        // Se noon c'è gia un'altro messaggio più vecchio con errore
	                        // 
	                        IF NOT #Err.Msg_NotAccepted.Presence THEN
	                            #Err.Msg_NotAccepted := "MES_Error_Set"(msg_RETVAL := #SEND.ack, msg := #SEND.msg);
	                        END_IF;
	                        
	                        // Ripartenza ritardo per riprovare a trasmettere messaggio con errore
	                        // 
	                        #TON_Retry(IN := FALSE,PT := #PT_RETRY);
	                        
	                    END_IF;
	                    
	                    EXIT; // Uscita perchè messaggio in send è stato trovato
	                    
	                END_IF;
	                
	                
	            END_FOR;
	            
	            
	            // Ritorno a inizio sequenza..
	            // 
	            IF #Found THEN
	                
	                #Err.TimeOut_ACK := FALSE;
	                
	                #TON_Timeout(IN := FALSE,
	                             PT := #PT_TIMEOUT);
	                
	                #Status := #S0_INIT;
	                
	                RETURN;
	                
	            END_IF;
	            
	        END_IF;
	        
	        
	        // MES non risponde al messaggio.. ACK persistente = 0
	        //
	        #TON_Timeout(IN := TRUE,
	                     PT := #PT_TIMEOUT);
	        
	        IF #TON_Timeout.Q THEN
	            
	            #Err.TimeOut_ACK := TRUE;
	            
	            #TON_RstTimeout(IN := FALSE, PT:=#PT_RETRY);
	            
	            #Status := #S3_PAUSE;
	            
	           
	            RETURN;
	        END_IF;
	        
	        
	        
	    #S3_PAUSE :
	        
	        #SEND.msg := "MES_Msg_Delete"();
	        
	        #TON_Timeout(IN := FALSE,
	                     PT := #PT_TIMEOUT);
	        
	        
	        #TON_RstTimeout(IN := TRUE,
	                        PT := #PT_RETRY);
	        
	        IF #TON_RstTimeout.Q THEN
	            
	            #Status := #S0_INIT;
	        END_IF;
	        
	        
	    ELSE
	        #Status := #S0_INIT;
	END_CASE;
	
	
	
	
END_FUNCTION_BLOCK

