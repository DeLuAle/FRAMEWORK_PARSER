FUNCTION "MES_Buffer_Clear_GAP" : DInt
{ S7_Optimized_Access := 'TRUE' ; Published := 'FALSE' }
VERSION : 0.1
   VAR_IN_OUT 
      Buffer_msg : Array[*] of "MES_Msg";
   END_VAR

   VAR_TEMP 
      index_MIN_Buffer : Int;
      index_MAX_Buffer : Int;
      CORREZIONE_INDICE_0 : Int;   // Indice base-0 per MOVE_BLK_VARIANT
      i : Int;
      indx_Empty : Int;
      indx_Busy : Int;
      All_Empty : Bool;
      All_Full : Bool;
      Gap_Found : Bool;
      NumToShift : UDInt;
      RETVAL : Int;
   END_VAR


BEGIN
	// Dimensione del buffer dei messaggi da inviare
	// 
	#index_MIN_Buffer := DINT_TO_INT(LOWER_BOUND(ARR := #Buffer_msg, DIM := 1));
	#index_MAX_Buffer := DINT_TO_INT(UPPER_BOUND(ARR := #Buffer_msg, DIM := 1));
	
	
	
	// Correzione indice zero per funzione MOVE_BLK_VARIANT
	// 
	// Counting at the parameters SRC_INDEX AND DEST_INDEX always begins with the low limit "0", regardless OF the later declaration OF the ARRAY."
	// 
	IF #index_MIN_Buffer > 0 THEN
	    #CORREZIONE_INDICE_0 := - #index_MIN_Buffer;
	END_IF;
	
	
	
	#MES_Buffer_Clear_GAP := -999;
	
	// Ricerca GAP = una posizione vuota e la seguente occupata
	//
	#All_Full := TRUE;
	#All_Empty := TRUE;
	#Gap_Found := FALSE;
	
	#indx_Empty := -1;
	#indx_Busy := -1;
	
	
	FOR #i := #index_MIN_Buffer TO #index_MAX_Buffer DO
	    
	    
	    
	    // Prima si trova la posizione vuota
	    IF #Buffer_msg[#i].Id <= 0 THEN
	        
	        #All_Full := FALSE;
	        
	        IF #indx_Empty <= 0 THEN
	            #indx_Empty := #i;
	            CONTINUE;
	        END_IF;
	        
	    ELSE
	        
	        #All_Empty := FALSE;
	        
	        // Poi si trova la prima posizione occupata
	        IF #indx_Empty > 0 THEN
	            
	            IF #indx_Busy <= 0 THEN
	                #indx_Busy := #i;
	                #Gap_Found := TRUE;
	                EXIT;
	            END_IF;
	        END_IF;
	        
	    END_IF;
	    
	    
	    
	END_FOR;
	
	// DEBUG
	#All_Full := #All_Full;
	#All_Empty := #All_Empty;
	#Gap_Found := #Gap_Found;
	
	#indx_Empty := #indx_Empty;
	#indx_Busy := #indx_Busy;
	
	
	
	
	
	// Tutto il buffer è vuoto
	// 
	IF #All_Empty THEN
	    #MES_Buffer_Clear_GAP := "PROD_FUN_RESULT_BUFFER_EMPTY";
	    RETURN;
	END_IF;
	
	// Tutto il buffer è pieno8
	// 
	IF #All_Full AND "Sys".ByPass THEN
	    #MES_Buffer_Clear_GAP := "PROD_ERR_BUFFER_MSGs_FULL";
	    RETURN;
	END_IF;
	
	// // Buffer compatto: tutti gli occupati all'inizio, tutti i vuoti alla fine
	// 
	IF NOT #Gap_Found THEN
	    #MES_Buffer_Clear_GAP := "PROD_FUN_RESULT_NO_GAP";
	    RETURN;
	END_IF;
	
	
	
	
	// Shift in alto del buffer..
	// 
	#NumToShift := INT_TO_UDINT(#index_MAX_Buffer - #indx_Empty);
	
	
	
	#RETVAL := MOVE_BLK_VARIANT(
	                            SRC := #Buffer_msg,
	                            COUNT := #NumToShift,
	                            SRC_INDEX := #indx_Empty + 1 + #CORREZIONE_INDICE_0,
	                            DEST_INDEX := #indx_Empty + #CORREZIONE_INDICE_0,
	                            DEST => #Buffer_msg);
	
	// Uscita per errore shift
	// 
	IF #RETVAL <> 0 THEN
	    #MES_Buffer_Clear_GAP := "PROD_ERR_BUFFER_MSGs_SHIFT";
	    RETURN;
	END_IF;
	
	
	// cancellazione ultima posizione duplicata dopo lo shift
	// 
	#Buffer_msg[#index_MAX_Buffer] := "MES_Msg_Delete"();
	
	
	// Uscita per Gap rimosso    
	//
	#MES_Buffer_Clear_GAP := "PROD_FUN_RESULT_CLEAR_GAP_DONE";
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
END_FUNCTION

