FUNCTION_BLOCK "ThicknessCheck_FB"
{ S7_Optimized_Access := 'TRUE' ; Published := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      "HW_ID_DL-PN" : HW_SUBMODULE;
      HW_ID_IL1000 : HW_SUBMODULE;
      HW_ID_IL1050 : HW_SUBMODULE;
      CIn : Struct
         Rst : Bool;
         Init : Bool;
         Enable : Bool;
         MaterialCounter : LReal;
         Setpoint : Real;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT 
      Cout : Struct
         Thickness_Act : Real;
         Thickness_Avg : Real;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT 
      HMI : Struct
         Button_Init : Bool;
         Button_Bypass : Bool;
         STATUS : Int;
      END_STRUCT;
      Par : "Thickness_Par";
      Pers_Data : "Thickness_PersData";
      Alarm : Struct
         Err_Sensor_Get_PN_IO : Bool;
         Err_Sensor_Rack : Bool;
         Err_Sensor_Value : Bool;
         ThicknessOutOfRange : Bool;
      END_STRUCT;
      Warning : Struct
         SensorDisable : Bool;
         ThicknessOutOfRange : Bool;
         Err_Bypass : Bool;
      END_STRUCT;
   END_VAR

   VAR 
      Sts : Struct
         init_Done : Bool;
         Sensore : Struct
            Value_DWORD : DWord;
            Value_mm_REAL : Real;
         END_STRUCT;
         Measure_Out_Of_Range : Bool;
      END_STRUCT;
      Ctrl : Struct
         Trigger : Bool;
      END_STRUCT;
      Keyence_Head : "Keyence_DL_PN";
      Keyence_SensMaste : "Keyence_ILx";
      Keyence_SensSlave : "Keyence_ILx";
      LastItem { S7_SetPoint := 'False'} : "Thickness_Measure_Item";
      "GETIO_DL-PN" {InstructionName := 'GETIO'; LibVersion := '1.1'} : GETIO;
      GETIO_L1000 {InstructionName := 'GETIO'; LibVersion := '1.1'} : GETIO;
      GETIO_L1050 {InstructionName := 'GETIO'; LibVersion := '1.1'} : GETIO;
      TON_Init {InstructionName := 'TON_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TON_TIME;
      R_TRIG_Button_Bypass {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      R_TRIG_Init {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
   END_VAR

   VAR_TEMP 
      i : Int;
      Status1 : DWord;
      Len1 : Int;
      Status2 : DWord;
      Len2 : Int;
      Status3 : DWord;
      Len3 : Int;
      TmpReadValue : DWord;
      RETVAL : Int;
      NextPos : LReal;
      Temp_Avg : Real;
      Temp_Measure_Status : Int;
      Counter_Probe : Int;
      "Counter" : Int;
   END_VAR

   VAR CONSTANT 
      SYSTEM_INIT : Int := -1;
      SYSTEM_OFF : Int := 0;
      SYSTEM_ON : Int := 1;
      SYSTEM_WARNING : Int := 2;
      SYSTEM_ERROR : Int := 3;
      SYSTEM_BYPASS : Int := 4;
      MEASURE_NULL : Int := 0;
      MEASURE_OK : Int := 1;
      MEASURE_NG : Int := 2;
      NULL_DATE_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#2000-01-01-00:00:00;
   END_VAR


BEGIN
	//Keyence thickness Sensor reading Function V1.0
	
	
	
	
	
	
	
	
	REGION Reset alarm
	    
	    IF #CIn.#Rst OR NOT #Par.SensorON THEN
	        
	        IF #Alarm.ThicknessOutOfRange THEN
	            #Pers_Data.Measure.OutOfRange_Counter := 0;
	        END_IF;
	  
	        
	        #Alarm.ThicknessOutOfRange :=
	        #Alarm.Err_Sensor_Get_PN_IO :=
	        #Alarm.Err_Sensor_Rack :=
	        #Alarm.Err_Sensor_Value := FALSE;
	        
	    END_IF;
	END_REGION
	
	
	
	REGION Sensor Warning
	    #Warning.SensorDisable := NOT #Par.SensorON;
	    
	END_REGION
	
	
	
	REGION Bypass ON/OFF = "DEROGA"
	    
	    #R_TRIG_Button_Bypass(CLK := #HMI.Button_Bypass);
	    
	    
	    IF #R_TRIG_Button_Bypass.Q AND #Alarm.ThicknessOutOfRange THEN
	        
	        #Pers_Data.Measure.BypassON := TRUE;
	        
	    ELSIF #R_TRIG_Button_Bypass.Q AND #Pers_Data.Measure.BypassON THEN
	        #Pers_Data.Measure.BypassON := FALSE;
	        
	    END_IF;
	    
	    
	END_REGION
	
	
	
	
	REGION INIT
	    
	    // Button
	    // 
	    #TON_Init(IN := #HMI.Button_Init ,
	              PT := T#3s);
	    
	    #R_TRIG_Init(CLK := #TON_Init.Q OR #CIn.Init);
	    
	    
	    IF #R_TRIG_Init.Q THEN
	        
	        
	        #Pers_Data.Measure.ID := 0;
	        #Pers_Data.Measure.Last_TriggerPosition := -1.0;
	        #Pers_Data.Measure.AverageSum := 0;
	        #Pers_Data.Measure.BypassON := FALSE;
	        #Pers_Data.Measure.OutOfRange_Counter := 0;
	        #Pers_Data.Measure.InRange_Counter := 0;
	        
	        #LastItem.ID := 0;
	        #LastItem.Time_Stamp := #NULL_DATE_TIME;
	        #LastItem.Status := #MEASURE_NULL;
	        #LastItem.Material_Position := 0;
	        #LastItem.Value := 0;
	        #LastItem.Err := 0;
	        #LastItem.Avg := 0;
	        #LastItem.AvgErr := 0;
	        
	        FOR #i := 1 TO "THICKNESS_CHECK__BUFFER_ITEMS" DO
	            #Pers_Data.Measure.Buffer[#i] := #LastItem;
	        END_FOR;
	        
	        
	       // #NextPos := "M_PosAPlusCostB"(PosA := #CIn.MaterialCounter, CostB := #Par.Trigger_interval, MODULE :="MATERIAL_COUNTERS_MODULE");
	        
	        
	    END_IF;
	    
	    
	END_REGION
	
	
	
	
	REGION Peripheral reading PN
	    
	    
	    
	    // Sensor read
	    // 
	    #"GETIO_DL-PN"(ID     := #"HW_ID_DL-PN",
	                  STATUS => #Status1,
	                  LEN    => #Len1,
	                  INPUTS := #Keyence_Head);
	    
	    
	    #GETIO_L1000(ID     := #HW_ID_IL1000,
	              STATUS => #Status2,
	              LEN    => #Len2,
	              INPUTS := #Keyence_SensMaste);
	
	  #GETIO_L1050(ID     := #HW_ID_IL1050                  ,
	              STATUS => #Status3,
	              LEN    => #Len3,
	              INPUTS := #Keyence_SensSlave);
	      
	      
	      
	      
	      
	    
	    //Fuction error
	    #Alarm.Err_Sensor_Get_PN_IO := #Status1 <> 0;
	    
	    //Sensor error
	    #Alarm.Err_Sensor_Rack :=
	    
	    #Keyence_Head."DLPN1 Error status"
	    OR
	    #Keyence_SensMaste."IL10xx Error status"
	    OR
	    #Keyence_SensMaste."IL10xx Error status";
	    
	    //Sensor value error    
	    #Alarm.Err_Sensor_Value :=
	    
	    #Keyence_SensMaste."IL10xx Comparator value invalid"
	    OR
	    #Keyence_SensMaste."IL10xx Comparator value under range"
	    OR
	    #Keyence_SensMaste."IL10xx Comparator value over range"
	    OR
	    #Keyence_SensSlave."IL10xx Comparator value invalid"
	    OR
	    #Keyence_SensSlave."IL10xx Comparator value under range"
	    OR
	    #Keyence_SensSlave."IL10xx Comparator value over range";
	    
	    #Sts.Sensore.Value_mm_REAL := 0.0;
	    
	    IF TRUE
	        AND NOT #Alarm.Err_Sensor_Get_PN_IO
	        AND NOT #Alarm.Err_Sensor_Rack
	        AND NOT #Alarm.Err_Sensor_Value
	    THEN
	        // Swap byte per concersion Little Endian (Keyence) -> Big Endian (Siemens)
	        // 
	        #Sts.Sensore.Value_DWORD := "ByteSwap_DWORD"(B3 := #Keyence_SensMaste."IL10xx Comparator value Byte3",
	                                                     B2 := #Keyence_SensMaste."IL10xx Comparator value Byte2",
	                                                     B1 := #Keyence_SensMaste."IL10xx Comparator value Byte1",
	                                                     B0 := #Keyence_SensMaste."IL10xx Comparator value Byte0");
	        
	        // Il valore RAW è espresso in micron...Conversione valore in mm
	        // 
	        #Sts.Sensore.Value_mm_REAL := DINT_TO_REAL(DWORD_TO_DINT(#Sts.Sensore.Value_DWORD)) / 1000.0;
	        #Cout.Thickness_Act := #Sts.Sensore.Value_mm_REAL;
	        
	    END_IF;
	    
	    
	    
	END_REGION
	
	
	
	REGION Material measure trigger    
	    
	    IF #CIn.Enable AND #Par.SensorON THEN
	        
	        IF #Par.Trigger_interval <= 0.0 THEN
	            #Par.Trigger_interval := 300.0;
	        END_IF;
	        
	        
	        IF #Pers_Data.Measure.Last_TriggerPosition >= 0.0 THEN
	            
	            #NextPos := "M_PosAPlusCostB"(PosA := #Pers_Data.Measure.Last_TriggerPosition, CostB := #Par.Trigger_interval, MODULE := "MATERIAL_COUNTERS_MODULE");
	            
	            IF "M_CmpGTE"(Xa := #CIn.MaterialCounter , Xb := #NextPos, MODULE := "MATERIAL_COUNTERS_MODULE")
	            THEN
	                #Pers_Data.Measure.Last_TriggerPosition := #CIn.MaterialCounter;
	                #Ctrl.Trigger := TRUE;
	            END_IF;
	            
	        ELSE
	            #Pers_Data.Measure.Last_TriggerPosition := #CIn.MaterialCounter;
	            #Ctrl.Trigger := TRUE;
	        END_IF;
	    END_IF;
	END_REGION
	
	
	
	REGION Average calc
	    
	    IF #Ctrl.Trigger THEN
	        
	        #Ctrl.Trigger := FALSE;
	        
	        
	        #Counter_Probe := 0;
	        #Pers_Data.Measure.AverageSum := 0;
	        
	        FOR #i := 1 TO "THICKNESS_CHECK__BUFFER_ITEMS" DO
	            
	            IF #Pers_Data.Measure.Buffer[#i].Status <> #MEASURE_NULL
	            THEN
	                #Counter_Probe += 1;
	                #Pers_Data.Measure.AverageSum += #Pers_Data.Measure.Buffer[#i].Value;
	            END_IF;
	        END_FOR;
	        
	        #Counter_Probe += 1;
	        #Pers_Data.Measure.AverageSum += #Sts.Sensore.Value_mm_REAL;
	        
	        #Temp_Avg := LREAL_TO_REAL(#Pers_Data.Measure.AverageSum / #Counter_Probe);
	        
	        
	        //Item icrease
	        #Pers_Data.Measure.ID += 1;
	        
	        (*
	        //Average calc
	        #Pers_Data.Measure.AverageSum := #Pers_Data.Measure.AverageSum + #Sts.Sensore.Value_mm_REAL;
	        
	        #Temp_Avg := LREAL_TO_REAL(#Pers_Data.Measure.AverageSum / #Pers_Data.Measure.ID);
	        *)
	        
	        #LastItem.Avg := #Temp_Avg;
	        #LastItem.AvgErr := #LastItem.Avg - #CIn.Setpoint;
	        
	        
	        
	        // Measure fault ADD
	        // 
	        
	        #Sts.Measure_Out_Of_Range := #LastItem.AvgErr >= #Par.Tolerance_Max OR #LastItem.AvgErr <= #Par.Tolerance_Min;
	        
	        
	        IF #Sts.Measure_Out_Of_Range THEN
	            
	            #Pers_Data.Measure.OutOfRange_Counter += 1;
	            #Pers_Data.Measure.InRange_Counter := 0;
	            #Temp_Measure_Status := #MEASURE_NG;
	        ELSE
	            #Pers_Data.Measure.InRange_Counter += 1;
	            #Temp_Measure_Status := #MEASURE_OK;
	        END_IF;
	        
	        IF #Par.BypassAutoReset > 0
	            AND
	            #Pers_Data.Measure.InRange_Counter >= #Par.BypassAutoReset
	        THEN
	            #Pers_Data.Measure.OutOfRange_Counter := 0;
	        END_IF;
	        
	        
	        // Item data collect
	        // 
	        #LastItem.ID := #Pers_Data.Measure.ID;
	        #RETVAL := RD_SYS_T(#LastItem.Time_Stamp);
	        #LastItem.Status := #Temp_Measure_Status;
	        #LastItem.Value := #Sts.Sensore.Value_mm_REAL;
	        #LastItem.Err := #Sts.Sensore.Value_mm_REAL - #CIn.Setpoint;
	        //#LastItem.Avg := #Temp_Avg;
	        //#LastItem.AvgErr := #LastItem.Avg - #CIn.Setpoint;
	        #LastItem.Material_Position := #Pers_Data.Measure.Last_TriggerPosition;
	        
	        // Push item
	        // 
	        #RETVAL := "Thickness_item_Push_to_Top"(item := #LastItem, Buffer := #Pers_Data.Measure.Buffer);
	        
	        
	        // MES data record
	        // 
	        IF #LastItem.AvgErr >= (#Pers_Data.MES_Record.Err + #Par.MES_RecordChange_ThresholdMax)
	            OR #LastItem.AvgErr <= (#Pers_Data.MES_Record.Err - #Par.MES_RecordChange_ThresholdMin)
	        THEN
	            #Pers_Data.MES_Record := #LastItem;
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	
	
	REGION Warnin / Alarm measurement
	    
	    #Warning.Err_Bypass := FALSE;
	    #Warning.ThicknessOutOfRange := FALSE;
	    #Alarm.ThicknessOutOfRange := FALSE;
	    
	    IF #Pers_Data.Measure.OutOfRange_Counter > 0
	    THEN
	        #Warning.ThicknessOutOfRange := TRUE;
	    END_IF;
	    
	    
	    IF #Pers_Data.Measure.OutOfRange_Counter > #Par.NG_Measures_ToFault
	    THEN
	        #Alarm.ThicknessOutOfRange := TRUE;
	        #Warning.ThicknessOutOfRange := FALSE;
	    END_IF;
	    
	    
	    
	    IF #Pers_Data.Measure.BypassON
	    THEN
	        #Warning.Err_Bypass := TRUE;
	        #Alarm.ThicknessOutOfRange := FALSE;
	        #Warning.ThicknessOutOfRange := FALSE;
	    END_IF;
	    
	END_REGION
	
	REGION SYSTEM STATUS
	    
	    
	    IF #CIn.Init
	    THEN
	        #HMI.STATUS := #SYSTEM_INIT;
	        
	    ELSIF NOT #Par.SensorON
	    THEN
	        #HMI.STATUS := #SYSTEM_OFF;
	        
	    ELSIF #Pers_Data.Measure.BypassON
	    THEN
	        #HMI.STATUS := #SYSTEM_BYPASS;
	    ELSIF #Pers_Data.Measure.OutOfRange_Counter > #Par.NG_Measures_ToFault
	    THEN
	        #HMI.STATUS := #SYSTEM_ERROR;
	    ELSIF #Pers_Data.Measure.OutOfRange_Counter > 0
	    THEN
	        #HMI.STATUS := #SYSTEM_WARNING;
	        
	    ELSE
	        #HMI.STATUS := #SYSTEM_ON;
	    END_IF;
	    
	    
	END_REGION
	
	
	
	
	REGION Coordination out
	    
	    #Cout.Thickness_Act := #Sts.Sensore.Value_mm_REAL;
	    #Cout.Thickness_Avg := #LastItem.Avg;
	    
	END_REGION
	
	
	
	
END_FUNCTION_BLOCK

