{
  "meta": {
    "analysis_scope": "L1_SpeedAxis + L1_Motor + L2_FeedMachine",
    "version": "3.0",
    "analysis_date": "2026-01-06",
    "purpose": "Knowledge base per generazione SCL",
    "changes_v2": [
      "Corretta semantica Gen_Cnd: pattern graceful degradation con auto-sostentamento",
      "Corretta semantica CtrlSafe: feedback verso Safety PLC, non decisione",
      "Aggiunto pattern Infeed: shared resource bottom-up",
      "Chiarita gerarchia Simulation: Sys \u2192 Input \u2192 TO",
      "Documentato VelocityOverride: controllo di processo (loop/profili)",
      "Chiarito Brake: watchdog su CU per motori induzione",
      "Documentato Fan: prerequisito con graceful degradation",
      "Chiarito Aborting: escalation bottom-up per StopInPhase",
      "Aggiunto GeneralConditions di SpeedAxis",
      "Documentate variabili globali Sys.*"
    ],
    "source_files": [
      "FeedMachine_FB.scl (450 lines)",
      "SpeedAxis.scl (578 lines)",
      "Motor.scl (107 lines)",
      "FeedMachine_CIn.udt",
      "FeedMachine_COut.udt",
      "FeedMachine_Config.udt",
      "FeedMachine_DataIn.udt",
      "FeedMachine_DataOut.udt",
      "FeedMachine_Par.udt",
      "FeedMachine_Alr.udt",
      "FeedMachine_Wng.udt",
      "FeedMachine_Manager.udt"
    ],
    "integration_references": [
      "Infeed_Integration_Patterns.json"
    ],
    "changes_v3": [
      "Aggiunto ReductionRatio_Calculation completo con formula e esempio",
      "Aggiunto PowerPermit_Formula in SpeedAxis",
      "Espanso Sys.* global variables con OB100 e debug details",
      "Aggiunto FeedMachine_Manager_UDT completo",
      "Aggiunto AreaInterface_UDT completo",
      "Aggiunto ZoneSafetyInterface_UDT completo",
      "Aggiunto MachineInterface_UDT completo",
      "Aggiunto L3_UDT_Templates per generazione aggregatori",
      "Aggiunto Responsibility_Matrix (Infeed, HU, Safety)",
      "Aggiunto L3_Timeout_Handling patterns",
      "Aggiunto L3_Common_Mistakes (7 errori tipici)",
      "Aggiunto L3_Validation_Checklist (14 regole)"
    ]
  },
  "Preconditions": {
    "Required_Inputs": {
      "L3_Machine_List": "List of L3/L4 machine instances and their call blocks",
      "L3_CIn_Mapping": "Mapping for Manager/ExtEnable/Config/DSI and any HMI manual commands",
      "L3_COut_Aggregation": "Which COut signals must be aggregated and where they are consumed",
      "Safety_Inputs": "AreaInterface, ZSI/DSI signals and any interlocks"
    },
    "Question_Gate": {
      "If_Missing": [
        "Stop and ask for the missing inputs before generating L3 integration."
      ],
      "Minimum_Questions": [
        "Which L3/L4 machine instances are present and what are their call block names?",
        "Which Manager/ExtEnable/Config/DSI fields are used for this machine type?",
        "Which COut signals must be aggregated in L3?",
        "Which safety/area signals (AreaInterface, ZSI/DSI) must be wired?"
      ]
    }
  },
  "global_variables": {
    "description": "Variabili globali di sistema usate dai FB",
    "Sys": {
      "description": "DB globale con variabili di sistema PLC",
      "nota": "Potrebbe non essere incluso nell'export progetto - gestito da OB startup",
      "Sys.FirstPLCCycle": {
        "type": "Bool",
        "meaning": "TRUE solo al primo ciclo PLC dopo power-on o Stop\u2192Run",
        "set_by": "OB100 (Startup)",
        "use_case": "Inizializzazioni, reset array messaggi, skip logiche transitorie",
        "example_usage": [
          "TON_NoPendingCmd.IN skip su primo ciclo per evitare false 'no commands'",
          "Reset contatori giornalieri",
          "Inizializzazione stati macchina"
        ],
        "implementation": "Settato a TRUE in OB100, automaticamente FALSE da ciclo 2 in poi"
      },
      "Sys.SimulationDevice": {
        "type": "Bool",
        "meaning": "Flag globale modalit\u00e0 simulazione dispositivi",
        "set_by": "Forzamento manuale durante debug",
        "impact": "Bypassa feedback fisici, simula TO, disabilita uscite fisiche",
        "typical_use": [
          "Test logica senza hardware fisico collegato",
          "Commissioning software in laboratorio",
          "Debug di sequenze complesse senza rischio macchina"
        ],
        "propagation": [
          "FeedMachine: Simulation input := Sys.SimulationDevice",
          "Motor: Simulation := Sys.SimulationDevice",
          "SpeedAxis: TO.Simulation.Mode synced con flag"
        ]
      }
    }
  },
  "L1_SpeedAxis": {
    "purpose": "Device driver per asse controllato in velocit\u00e0 (MC_MoveVelocity)",
    "physical_model": "Motore brushless con drive Sinamics, encoder integrato, movimento bidirezionale continuo",
    "family": "Motion",
    "technology_object": {
      "type": "TO_SpeedAxis",
      "description": "Technology Object Siemens - struttura definita da TIA Portal",
      "key_fields": {
        "ActualSpeed": "Velocit\u00e0 attuale encoder",
        "Velocity": "Velocit\u00e0 comandata",
        "Override.Velocity": "Percentuale override (1-100%)",
        "StatusWord": "Stato TO (Enable, Done, Error, etc.)",
        "ErrorWord": "Codice errore",
        "WarningWord": "Codice warning",
        "ErrorDetail.Number": "Numero errore dettagliato",
        "ErrorDetail.Reaction": "Tipo reazione (0=warning, >0=fault)",
        "DynamicLimits.MaxVelocity": "Limite velocit\u00e0 configurato",
        "DynamicLimits.MaxAcceleration": "Limite accelerazione",
        "DynamicLimits.MaxDeceleration": "Limite decelerazione",
        "DynamicLimits.MaxJerk": "Limite jerk",
        "Simulation.Mode": "0=reale, 1=simulato",
        "VirtualAxis.Mode": "Modalit\u00e0 asse virtuale"
      }
    },
    "AxisCtrl": {
      "description": "Comandi da L2 verso L1 SpeedAxis",
      "SafeStop": {
        "type": "Bool",
        "meaning": "Blocco di sicurezza - impedisce tutti i movimenti",
        "source": "DSI.SafeStop passato da L2",
        "impact": "SafeStop=TRUE \u2192 PowerPermit=FALSE, movimento bloccato"
      },
      "Rst": {
        "type": "Bool",
        "meaning": "Reset allarmi TO e MC_*",
        "source": "AreaInterface.RstAlarms",
        "impact": "Azzera errori MC_Power, MC_MoveVelocity, MC_Halt, MC_Stop"
      },
      "RstHW": {
        "type": "Bool",
        "meaning": "Reset hardware con restart TO",
        "use_case": "Recupero da errori gravi TO (es. errore encoder)",
        "condition": "Eseguito solo se RestartConditions=TRUE"
      },
      "Power": {
        "type": "Bool",
        "meaning": "Richiesta abilitazione potenza asse",
        "condition": "Eseguito se PowerPermit=TRUE"
      },
      "MovePlus": {
        "type": "Bool",
        "meaning": "Comando movimento direzione positiva (Forward)",
        "condition": "Eseguito se MoveVelPlusPermitted AND AxisEnabled"
      },
      "MoveMinus": {
        "type": "Bool",
        "meaning": "Comando movimento direzione negativa (Backward)",
        "condition": "Eseguito se MoveVelMinusPermitted AND AxisEnabled"
      },
      "ExtControl": {
        "type": "Bool",
        "meaning": "Controllo esterno attivo (bypass comandi interni)",
        "use_case": "Gearing, camming, o controllo da altro FB"
      },
      "Velocity": {
        "type": "LReal",
        "meaning": "Velocit\u00e0 target in unit\u00e0 ingegneristiche del TO",
        "nota": "L2 converte da unit\u00e0 applicazione (mm/min) a unit\u00e0 TO via ReductionRatio"
      },
      "Acceleration": {
        "type": "LReal",
        "meaning": "Accelerazione in unit\u00e0 TO"
      },
      "Deceleration": {
        "type": "LReal",
        "meaning": "Decelerazione in unit\u00e0 TO"
      },
      "Jerk": {
        "type": "LReal",
        "meaning": "Jerk (derivata accelerazione), 0 = rampa lineare"
      }
    },
    "AxisSts": {
      "description": "Stati da L1 verso L2",
      "AlarmPresence": {
        "type": "Bool",
        "formula": "Alarm.TOAxis OR Alarm.MCFunction OR Alarm.Drive",
        "meaning": "Almeno un allarme L1 attivo"
      },
      "WarningPresence": {
        "type": "Bool",
        "formula": "Warning.TOAxis OR Warning.Drive",
        "meaning": "Almeno un warning L1 attivo"
      },
      "Enabled": {
        "type": "Bool",
        "formula": "MC_POWER.Status AND StatusWord.Enable",
        "meaning": "Asse abilitato e pronto per movimento"
      },
      "Done": {
        "type": "Bool",
        "meaning": "Comando completato (da StatusWord TO)"
      },
      "Standstill": {
        "type": "Bool",
        "formula": "(ABS(ActualSpeed) < StandstillVelocity) per StandstillDelay",
        "meaning": "Asse completamente fermo"
      },
      "RstHWDone": {
        "type": "Bool",
        "meaning": "Reset hardware completato"
      },
      "AtProgrammedSpeed": {
        "type": "Bool",
        "meaning": "Velocit\u00e0 target raggiunta (StatusWord.CostantVelocity)"
      },
      "MoveMinusPermitted": {
        "type": "Bool",
        "formula": "NOT MovePlus AND GeneralConditions",
        "meaning": "Movimento negativo permesso"
      },
      "MovePlusPermitted": {
        "type": "Bool",
        "formula": "NOT MoveMinus AND GeneralConditions",
        "meaning": "Movimento positivo permesso"
      },
      "ActualSpeed": {
        "type": "LReal",
        "meaning": "Velocit\u00e0 attuale in unit\u00e0 TO"
      }
    },
    "GeneralConditions": {
      "description": "Condizioni generali per eseguire operazioni MC",
      "formula": "NOT AxisCtrl.SafeStop AND NOT Alarm.TOAxis AND NOT Alarm.MCFunction",
      "meaning": "Nessun blocco safety E nessun errore TO E nessun errore MC",
      "used_by": [
        "MoveVelPlusPermitted",
        "MoveVelMinusPermitted"
      ]
    },
    "Alarms": {
      "TOAxis": {
        "trigger": "ErrorDetail.Reaction > 0 in stato Error",
        "meaning": "Errore Technology Object (TO)",
        "typical_cause": "Errore encoder, limite SW, errore seguimento"
      },
      "MCFunction": {
        "trigger": "Errore da MC_Power, MC_MoveVelocity, MC_Halt, MC_Stop",
        "meaning": "Errore funzione Motion Control"
      },
      "Drive": {
        "trigger": "ErrorWord.DriveFault dal telegramma",
        "meaning": "Fault dal drive Sinamics"
      }
    },
    "Warnings": {
      "TOAxis": {
        "trigger": "(Error AND Reaction=0) OR WarningWord<>0 OR RestartNeeded OR RestartActive OR SimulationActive",
        "meaning": "Warning TO o condizioni anomale non bloccanti"
      },
      "Drive": {
        "trigger": "WarningWord.DriveWarning dal telegramma",
        "meaning": "Warning dal drive Sinamics"
      }
    },
    "MC_Blocks_Used": {
      "MC_POWER": "Abilitazione potenza asse",
      "MC_MOVEVELOCITY": "Movimento continuo a velocit\u00e0",
      "MC_HALT": "Arresto con decelerazione controllata",
      "MC_STOP": "Arresto emergenza (fallback se Halt fallisce dopo HALT_TIMEOUT)",
      "MC_RESET": "Reset errori TO (con opzione Restart per errori gravi)"
    },
    "Simulation_Logica": {
      "description": "Gestione modalit\u00e0 simulazione TO",
      "hierarchy": [
        "1. Sys.SimulationDevice - flag globale sistema",
        "2. Simulation input FB - tipicamente := Sys.SimulationDevice",
        "3. Simulate.Active - stato reale TO (AxisSimulation AND VirtualAxis.Mode=0)"
      ],
      "sync_logic": {
        "description": "Sincronizza input con stato TO",
        "scl": [
          "IF Simulation <> Simulate.Active THEN",
          "    Simulate.Mode := SEL(Simulation, 0, 1);",
          "    WRIT_DBL \u2192 TO.Simulation.Mode",
          "    TO_RestartCmd := TRUE;  // Restart TO per applicare",
          "END_IF"
        ]
      }
    },
    "Power_Flow": {
      "description": "Flusso abilitazione potenza",
      "steps": [
        {
          "step": 1,
          "condition": "PowerPermit := NOT SafeStop AND Drive.Infeed_ON AND NOT Alarm.TOAxis AND NOT ErrorMC_Power",
          "meaning": "Verifica condizioni base per potenza"
        },
        {
          "step": 2,
          "condition": "PowerEnable := (Power OR MovePlus OR MoveMinus OR ExtControl OR MC_Busy) AND PowerPermit",
          "meaning": "Richiesta effettiva potenza"
        },
        {
          "step": 3,
          "action": "PowerOn con delay OFF (PowerOffDelay) per evitare ON/OFF ripetuti",
          "meaning": "Abilitazione con isteresi temporale"
        },
        {
          "step": 4,
          "action": "MC_POWER(Enable := PowerOn)",
          "meaning": "Comando effettivo al TO"
        },
        {
          "step": 5,
          "output": "Infeed_REQ_ON := PowerOn OR pending commands (con delay OFF 300ms)",
          "meaning": "Segnala a Infeed che serve potenza DC bus"
        }
      ],
      "PowerPermit_Formula": {
        "description": "Condizione finale per permettere abilitazione potenza",
        "scl": "PowerPermit := NOT SafeStop AND Drive.Infeed_ON AND NOT Alarm.TOAxis AND NOT ErrorMC_Power",
        "components": {
          "NOT SafeStop": "Nessun blocco di sicurezza attivo",
          "Drive.Infeed_ON": "DC bus S120 alimentato (da Infeed FB)",
          "NOT Alarm.TOAxis": "Nessun errore Technology Object",
          "NOT ErrorMC_Power": "Nessun errore MC_POWER precedente"
        },
        "location": "SpeedAxis.scl line ~388",
        "used_in": [
          "PowerEnable calculation (step 2)",
          "PowerOn logic (step 3)"
        ]
      }
    },
    "Infeed_Pattern": {
      "description": "Pattern shared resource per DC bus comune",
      "type": "Bottom-up aggregation",
      "independence": "Gestito indipendentemente da L3/L4 - \u00e8 gestione risorse elettriche",
      "flow": [
        "1. SpeedAxis.Infeed_REQ_ON = TRUE quando serve potenza",
        "2. Aggregatore esterno fa OR di tutte le richieste",
        "3. Infeed FB accende DC bus S120",
        "4. Infeed FB setta Drive.Infeed_ON = TRUE (broadcast)",
        "5. SpeedAxis vede Infeed_ON \u2192 pu\u00f2 fare MC_POWER",
        "6. Tutte richieste FALSE \u2192 dopo timeout \u2192 Infeed spegne"
      ],
      "nota": "L2 produce COut.Infeed_ReqON, riceve Drive.Infeed_ON - non gestisce logica Infeed"
    }
  },
  "L1_Motor": {
    "purpose": "Device driver per motore semplice ON/OFF con contattore",
    "physical_model": "Motore asincrono con contattore, protezione termica, feedback running",
    "family": "Electric",
    "MotorCtrl": {
      "description": "Comandi da L2 verso L1 Motor",
      "SafeStop": {
        "type": "Bool",
        "meaning": "Blocco di sicurezza - ferma motore",
        "source": "AreaInterface.EStop nel caso di FeedMachine (Fan)",
        "impact": "SafeStop=TRUE \u2192 RunPermitted=FALSE"
      },
      "Rst": {
        "type": "Bool",
        "meaning": "Reset allarmi",
        "source": "AreaInterface.RstAlarms",
        "impact": "Azzera ThermalProtection, Feedback"
      },
      "Run": {
        "type": "Bool",
        "meaning": "Comando marcia",
        "condition": "Eseguito solo se RunPermitted=TRUE"
      }
    },
    "MotorSts": {
      "description": "Stati da L1 verso L2",
      "AlarmPresence": {
        "type": "Bool",
        "formula": "Alarm.ThermalProtection OR Alarm.Feedback",
        "meaning": "Almeno un allarme L1 attivo"
      },
      "RunPermitted": {
        "type": "Bool",
        "formula": "NOT AlarmPresence AND NOT SafeStop",
        "meaning": "Marcia permessa"
      },
      "Running": {
        "type": "Bool",
        "formula": "(Ctrl_RunContactor AND FdbkRunning) OR (Ctrl_RunContactor AND Simulation)",
        "meaning": "Motore effettivamente in marcia (confermato da feedback o simulato)"
      }
    },
    "Alarms": {
      "ThermalProtection": {
        "trigger": "ThermalProtection input TRUE (AND NOT Simulation)",
        "meaning": "Protezione termica scattata",
        "typical_cause": "Sovraccarico, temperatura ambiente, ventilazione insufficiente"
      },
      "Feedback": {
        "trigger": "Mismatch contattore/feedback per FeedbackTimeout",
        "meaning": "Contattore comandato ma feedback non confermato (o viceversa)",
        "typical_cause": "Contattore guasto, cablaggio feedback, fusibile"
      }
    }
  },
  "L2_FeedMachine": {
    "purpose": "Aggregatore per alimentatore lineare (feeder) con controllo velocit\u00e0 bidirezionale",
    "physical_model": "Rulli motorizzati per alimentazione materiale, movimento Fwd/Bwd, ventilatore opzionale, freno opzionale",
    "wrapped_L1": {
      "Ax": {
        "type": "SpeedAxis",
        "purpose": "Controllo movimento principale",
        "mandatory": true
      },
      "Fan_M": {
        "type": "Motor",
        "purpose": "Ventilatore raffreddamento motore/drive",
        "mandatory": false,
        "controlled_by": "Config.Fan.Exist"
      }
    },
    "Config": {
      "description": "Parametri configurazione macchina - impostati in commissioning",
      "SLS_VEL": {
        "type": "LReal",
        "meaning": "Velocit\u00e0 limite sicurezza (Safe Limited Speed)",
        "unit": "mm/min (unit\u00e0 applicazione)",
        "impact": "Quando ZSI.Door_Opened, velocit\u00e0 limitata a questo valore",
        "safety_function": "SLS secondo EN ISO 13849"
      },
      "DelayMissingCondition": {
        "type": "Time",
        "meaning": "Tempo attesa prima di segnalare warning MissingCnd",
        "typical_value": "T#3s",
        "purpose": "Evita warning transienti durante coordinamento L3"
      },
      "Ax": {
        "LeadScrewPitchVal": {
          "type": "LReal",
          "meaning": "Passo vite/avanzamento per giro (mm)",
          "use": "Calcolo ReductionRatio per conversione unit\u00e0"
        },
        "MotorRevolution": {
          "type": "LReal",
          "meaning": "Giri motore per rapporto riduzione"
        },
        "LoadRevolution": {
          "type": "LReal",
          "meaning": "Giri carico per rapporto riduzione"
        },
        "PowerOffDelay": {
          "type": "Time",
          "meaning": "Ritardo spegnimento potenza dopo stop comandi"
        },
        "StandstillVelocity": {
          "type": "Real",
          "meaning": "Soglia velocit\u00e0 per considerare asse fermo"
        },
        "StandstillDelay": {
          "type": "Time",
          "meaning": "Ritardo conferma standstill"
        }
      },
      "Fan": {
        "Exist": {
          "type": "Bool",
          "meaning": "Ventilatore presente?",
          "impact": {
            "TRUE": "Fan_M gestito, Running richiesto per INIZIARE movimento",
            "FALSE": "Fan_M bypassato, Running forzato TRUE"
          }
        },
        "DelayOff": {
          "type": "Time",
          "meaning": "Ritardo spegnimento ventilatore dopo stop asse (raffreddamento post-movimento)"
        }
      },
      "Brake_Presence": {
        "type": "Bool",
        "meaning": "Freno meccanico esterno presente?",
        "impact": "Se TRUE, monitora mismatch comando/feedback freno",
        "nota": "Solo per motori a induzione con freno esterno gestito da CU Sinamics"
      }
    },
    "Brake_Management": {
      "description": "Gestione freno stazionamento per motori a induzione",
      "motor_types": {
        "induction_motor": {
          "brake_type": "Esterno 400V",
          "control": "Sinamics CU comanda uscita digitale \u2192 contattore freno",
          "feedback": "CU legge ingresso digitale \u2190 feedback freno",
          "plc_role": "WATCHDOG - legge segnali CU, verifica coerenza, genera allarme",
          "DataIn.Brake_M_Q": "Lettura comando freno DA CU (non uscita PLC!)",
          "DataIn.Brake_M_Feedback": "Lettura feedback fisico freno"
        },
        "brushless_motor": {
          "brake_type": "Integrato 24V nel motore",
          "control": "Interno Sinamics via cavo potenza",
          "plc_role": "NESSUNO - Config.Brake_Presence = FALSE"
        }
      },
      "alarm_logic": {
        "trigger": "(Brake_M_Q XOR Brake_M_Feedback) per 1s",
        "meaning": "Freno comandato aperto ma feedback chiuso (o viceversa)",
        "risk": "Motore gira con freno inserito \u2192 danneggia freno",
        "scl": "TON_Brake_TimeOut.IN := Brake_Presence AND (Brake_M_Q XOR Brake_M_Feedback)"
      }
    },
    "CIn": {
      "description": "Coordination Input - comandi da L3 verso L2",
      "Manager": {
        "EnableStopDoorOpeningReq": {
          "type": "Bool",
          "meaning": "Abilita arresto per richiesta apertura porta",
          "l3_responsibility": "L3 decide quali istanze partecipano a questo stop"
        },
        "EnableStopInPhase": {
          "type": "Bool",
          "meaning": "Abilita arresto in fase (sincronizzato)",
          "l3_responsibility": "L3 coordina stop multipli device"
        },
        "EnableStopProgrammed": {
          "type": "Bool",
          "meaning": "Abilita arresto programmato"
        },
        "Control_ON": {
          "type": "Bool",
          "meaning": "Modalit\u00e0 automatica attiva",
          "impact": "TRUE \u2192 comandi Bwd/Fwd automatici, FALSE \u2192 manuale abilitato"
        },
        "Bwd": {
          "type": "Bool",
          "meaning": "Comando movimento backward (automatico)"
        },
        "Fwd": {
          "type": "Bool",
          "meaning": "Comando movimento forward (automatico)"
        },
        "Vel": {
          "type": "LReal",
          "meaning": "Velocit\u00e0 target automatico (unit\u00e0 applicazione)"
        },
        "Acc": {
          "type": "LReal",
          "meaning": "Accelerazione automatico"
        },
        "Dec": {
          "type": "LReal",
          "meaning": "Decelerazione automatico"
        },
        "Jerk": {
          "type": "LReal",
          "meaning": "Jerk automatico (0 = rampa lineare)"
        }
      },
      "Bwd_ExtEnable": {
        "type": "Bool",
        "meaning": "Abilitazione esterna movimento backward",
        "source": "L3 - condizioni inter-device",
        "pattern": "Interblocco con altri device (es. rullo chiuso)"
      },
      "Fwd_ExtEnable": {
        "type": "Bool",
        "meaning": "Abilitazione esterna movimento forward",
        "source": "L3 - condizioni inter-device"
      },
      "EnableManChangeVel": {
        "type": "Bool",
        "meaning": "Abilita cambio velocit\u00e0 manuale (Low\u2192High)",
        "use_case": "Dopo DelayChangeVel, passa a VelFwdHigh"
      },
      "ExternalAlarms": {
        "type": "Bool",
        "meaning": "Allarmi esterni aggregati da L3",
        "impact": "Contribuisce a Sts.AlarmPresence",
        "use_case": "Allarmi da altri device che devono bloccare questo"
      },
      "VelocityOverride": {
        "description": "Controllo di processo per modulazione velocit\u00e0",
        "Enable": {
          "type": "Bool",
          "meaning": "Attiva override velocit\u00e0"
        },
        "Value": {
          "type": "LReal",
          "meaning": "Percentuale override (1-100%)",
          "impact": "TO_Ax.Override.Velocity := LIMIT(1, Value, 100)"
        },
        "use_cases": {
          "loop_control": "Ansa/buffer regola velocit\u00e0 in base a quantit\u00e0 materiale",
          "work_profile": "Ricetta prodotto richiede velocit\u00e0 ridotta",
          "sync_feeders": "Sincronizzazione velocit\u00e0 tra pi\u00f9 feeder"
        },
        "source": "L3 - Loop Controller o Profilo Lavoro",
        "nota": "NON \u00e8 per debug - \u00e8 controllo di processo closed-loop"
      }
    },
    "COut": {
      "description": "Coordination Output - stati da L2 verso L3",
      "Infeed_ReqON": {
        "type": "Bool",
        "meaning": "Richiesta accensione Infeed (alimentatore DC bus comune)",
        "source": "SpeedAxis.Infeed_REQ_ON",
        "pattern": "Shared resource bottom-up - aggregato con OR esterno"
      },
      "CtrlSafe": {
        "type": "Bool",
        "meaning": "FEEDBACK verso Safety PLC sullo stato device",
        "semantics": {
          "TRUE": "Posso stare senza coppia - Safety pu\u00f2 fare STO se serve",
          "FALSE": "Ho bisogno di coppia - Safety deve mantenere STO attivo"
        },
        "formula": "NOT TON_NoPendingCmd.IN OR (CtrlSafe AND Ax.Enabled) OR (Control_ON AND NOT StopDoorOpeningReq)",
        "formula_explanation": {
          "term1": "NOT TON_NoPendingCmd.IN - nessun comando pendente",
          "term2": "CtrlSafe AND Ax.Enabled - mantiene TRUE finch\u00e9 asse abilitato (evita MC error)",
          "term3": "Control_ON AND NOT StopDoorOpeningReq - in automatico senza richiesta porte"
        },
        "important": "\u00c8 un FEEDBACK, non una DECISIONE. Safety PLC aggrega tutti i CtrlSafe della zona e decide.",
        "door_opening_flow": [
          "1. Operatore chiede apertura porta",
          "2. Manager smette di dare comandi (Control_ON o comandi manuali)",
          "3. Feed si ferma naturalmente",
          "4. Asse si disabilita \u2192 CtrlSafe va FALSE",
          "5. Safety PLC vede AllCtrlSafe=FALSE \u2192 pu\u00f2 permettere apertura",
          "6. Con SOS attivo: asse pu\u00f2 restare abilitato (coppia per tenere posizione)"
        ]
      },
      "Standstill": {
        "type": "Bool",
        "meaning": "Asse completamente fermo",
        "formula": "Ax.AxisSts.Standstill OR DSI.DevicesInSafeState"
      },
      "Bwd_CheckNext": {
        "type": "Bool",
        "meaning": "Richiesta movimento backward (trigger per L3)",
        "formula": "Ctrl.Bwd_Man OR Ctrl.Bwd_Aut",
        "pattern": "L3 usa per coordinare prerequisiti inter-device"
      },
      "Fwd_CheckNext": {
        "type": "Bool",
        "meaning": "Richiesta movimento forward (trigger per L3)",
        "formula": "Ctrl.Fwd_Man OR Ctrl.Fwd_Aut"
      },
      "Bwd_VelZero": {
        "type": "Bool",
        "meaning": "In movimento backward con velocit\u00e0 target zero",
        "formula": "MOVE_VELOCITY.Busy AND Direction=2 AND TargetVel=0 AND InVelocity"
      },
      "Bwd_Running": {
        "type": "Bool",
        "meaning": "In movimento backward con velocit\u00e0 > 0",
        "formula": "MOVE_VELOCITY.Busy AND Direction=2 AND TargetVel>0"
      },
      "Fwd_VelZero": {
        "type": "Bool",
        "meaning": "In movimento forward con velocit\u00e0 target zero"
      },
      "Fwd_Running": {
        "type": "Bool",
        "meaning": "In movimento forward con velocit\u00e0 > 0"
      },
      "ActualVelocity": {
        "type": "LReal",
        "meaning": "Velocit\u00e0 attuale in unit\u00e0 applicazione",
        "formula": "TO_Ax.ActualSpeed * ReductionRatio"
      },
      "TargetVelocity": {
        "type": "LReal",
        "meaning": "Velocit\u00e0 target effettiva (dopo override)",
        "formula": "(MOVE_VELOCITY.Velocity * Override / 100) * ReductionRatio"
      },
      "MaxVelocity": {
        "type": "LReal",
        "meaning": "Velocit\u00e0 massima configurata in unit\u00e0 applicazione"
      }
    },
    "DataIn": {
      "description": "Input da campo",
      "PB": {
        "Bwd_Minus": {
          "type": "Bool",
          "meaning": "Pulsante jog backward"
        },
        "Fwd_Plus": {
          "type": "Bool",
          "meaning": "Pulsante jog forward"
        },
        "MoveToPos": {
          "type": "Bool",
          "meaning": "Pulsante move to position (non usato in FeedMachine)"
        }
      },
      "Fan_M_ThermalProtection": {
        "type": "Bool",
        "meaning": "Protezione termica ventilatore scattata"
      },
      "Fan_M_Feedback": {
        "type": "Bool",
        "meaning": "Feedback running ventilatore"
      },
      "Brake_M_Q": {
        "type": "Bool",
        "meaning": "LETTURA comando freno da Sinamics CU (non uscita PLC!)",
        "nota": "Solo per motori induzione con freno esterno"
      },
      "Brake_M_Feedback": {
        "type": "Bool",
        "meaning": "LETTURA feedback stato freno fisico"
      }
    },
    "DataOut": {
      "description": "Output verso campo",
      "Fan_M_Contactor": {
        "type": "Bool",
        "meaning": "Comando contattore ventilatore"
      }
    },
    "Par": {
      "description": "Parametri operativi - modificabili a runtime da HMI",
      "Man": {
        "VelBwd": {
          "type": "LReal",
          "meaning": "Velocit\u00e0 manuale backward"
        },
        "VelFwdLow": {
          "type": "LReal",
          "meaning": "Velocit\u00e0 manuale forward bassa (default all'avvio)"
        },
        "VelFwdHigh": {
          "type": "LReal",
          "meaning": "Velocit\u00e0 manuale forward alta (dopo delay)"
        },
        "Acc": {
          "type": "LReal",
          "meaning": "Accelerazione manuale"
        },
        "Dec": {
          "type": "LReal",
          "meaning": "Decelerazione manuale"
        },
        "Jerk": {
          "type": "LReal",
          "meaning": "Jerk manuale"
        },
        "DelayChangeVel": {
          "type": "Time",
          "meaning": "Ritardo per passaggio Low\u2192High in manuale",
          "nota": "T#0s = no cambio velocit\u00e0"
        }
      }
    },
    "Alarms": {
      "BrakeTimeOut": {
        "trigger": "Mismatch comando/feedback freno per 1s",
        "condition": "Brake_Presence AND ((Brake_M_Q AND NOT Feedback) OR (NOT Brake_M_Q AND Feedback))",
        "impact": "Gen_Cnd=FALSE, movimento bloccato",
        "applies_to": "Solo motori induzione con freno esterno"
      },
      "Ax": {
        "type": "TAx_Speed_Alarms",
        "meaning": "Allarmi delegati a SpeedAxis L1"
      },
      "Fan_M": {
        "type": "MotorAlr",
        "meaning": "Allarmi delegati a Motor L1 (se Fan.Exist)"
      }
    },
    "Warnings": {
      "NotAutReady": {
        "trigger": "AreaInterface.CheckAutReady AND NOT MachineInterface.AutReady",
        "meaning": "Macchina non pronta per automatico"
      },
      "MissingCnd_Bkw": {
        "trigger": "Standstill AND Bwd_CheckNext AND NOT Bwd_Cnd per DelayMissingCondition",
        "meaning": "Condizioni mancanti per movimento backward"
      },
      "MissingCnd_Fwd": {
        "trigger": "Standstill AND Fwd_CheckNext AND NOT Fwd_Cnd per DelayMissingCondition",
        "meaning": "Condizioni mancanti per movimento forward"
      },
      "Ax": {
        "type": "TAx_Warnings",
        "meaning": "Warning delegati a SpeedAxis L1"
      }
    },
    "Conditions_Logica": {
      "description": "Logica condizioni movimento (cuore del L2)",
      "Gen_Cnd": {
        "description": "Condizioni generali per qualsiasi movimento",
        "pattern": "GRACEFUL DEGRADATION con auto-sostentamento",
        "formula": "(BaseCond AND Fan_M.Running) OR (BaseCond AND (Bwd_Cnd OR Fwd_Cnd) AND NOT TON_NoPendingCmd.Q)",
        "BaseCond_components": [
          "NOT StopDueDoorOpeningRequest",
          "NOT StopInPhase",
          "NOT StopProgrammed",
          "NOT StopAborting",
          "NOT DSI.SafeStop",
          "NOT DSI.DevicesInSafeState",
          "NOT Alarm.BrakeTimeOut"
        ],
        "semantics": {
          "start_movement": "Per INIZIARE movimento \u2192 Fan DEVE essere Running",
          "continue_movement": "Per CONTINUARE movimento gi\u00e0 avviato \u2192 basta che Cnd sia gi\u00e0 TRUE",
          "rationale": "Se Fan si ferma durante movimento, feeder continua fino a stop naturale invece di fermarsi bruscamente (danni meccanici)",
          "alarm_cascade": "Fan KO \u2192 Allarme \u2192 Aborting \u2192 StopInPhase \u2192 arresto graduale di tutta l'area"
        }
      },
      "Bwd_Cnd": {
        "description": "Condizioni complete per movimento backward",
        "formula": "Gen_Cnd AND Ax.AxisSts.MoveMinusPermitted AND CIn.Bwd_ExtEnable",
        "meaning": "Base OK + L1 pronto + L3 ha dato via libera"
      },
      "Fwd_Cnd": {
        "description": "Condizioni complete per movimento forward",
        "formula": "Gen_Cnd AND Ax.AxisSts.MovePlusPermitted AND CIn.Fwd_ExtEnable",
        "meaning": "Base OK + L1 pronto + L3 ha dato via libera"
      },
      "evaluation_order": [
        "1. Stops (Door, Phase, Programmed, Aborting)",
        "2. Safety (DSI.SafeStop, DSI.DevicesInSafeState)",
        "3. Alarms (BrakeTimeOut)",
        "4. Prerequisites (Fan_M.Running) - SOLO per iniziare",
        "5. L1 Permit (Ax.MovePermitted)",
        "6. L3 ExtEnable (condizioni inter-device)",
        "7. Comando (Man/Aut) \u2192 trigger movimento"
      ]
    },
    "Fan_Management": {
      "description": "Gestione ventilatore con graceful degradation",
      "prerequisite_behavior": {
        "start": "Fan.Running BLOCCANTE per iniziare movimento",
        "during": "Fan KO durante movimento \u2192 movimento CONTINUA fino a stop naturale",
        "rationale": "Fermare bruscamente feeder con materiale pu\u00f2 causare danni"
      },
      "delay_off": {
        "trigger": "Asse fermo E nessun comando pendente",
        "delay": "Config.Fan.DelayOff",
        "purpose": "Raffreddamento post-movimento"
      },
      "bypass_when_not_exist": {
        "condition": "Config.Fan.Exist = FALSE",
        "effect": [
          "DataOut.Fan_M_Contactor := FALSE",
          "Fan_M.MotorSts.Running := TRUE (forzato)",
          "Fan_M.MotorSts.RunPermitted := FALSE",
          "Allarmi Fan azzerati"
        ]
      }
    },
    "Manual_Mode": {
      "description": "Logica movimento manuale",
      "activation": {
        "condition": "AreaInterface.Man AND NOT CIn.Manager.Control_ON",
        "trigger": "Positive edge su pulsante PB",
        "hold": "Movimento continua finch\u00e9 pulsante premuto"
      },
      "velocity_change": {
        "description": "Cambio velocit\u00e0 Low\u2192High in manuale forward",
        "condition": "Fwd_Man AND NOT Standstill AND EnableManChangeVel AND DelayChangeVel > 0",
        "delay": "Par.Man.DelayChangeVel",
        "effect": "Passa da VelFwdLow a VelFwdHigh"
      },
      "exclusion": {
        "nota": "Bwd_Minus esclude Fwd_Plus e viceversa (meccanica)"
      }
    },
    "Automatic_Mode": {
      "description": "Logica movimento automatico",
      "activation": {
        "condition": "CIn.Manager.Control_ON = TRUE"
      },
      "commands": {
        "Bwd_Aut": "Control_ON AND CIn.Manager.Bwd AND NOT CIn.Manager.Fwd",
        "Fwd_Aut": "Control_ON AND NOT CIn.Manager.Bwd AND CIn.Manager.Fwd"
      },
      "dynamics_source": "CIn.Manager.Vel/Acc/Dec/Jerk"
    },
    "StopDueDoorOpeningRequest": {
      "description": "Gestione richiesta apertura porta",
      "latch_formula": "((NoPendingCmd AND Standstill) OR StopDueDoorOpeningRequest) AND EnableStopDoorOpeningReq AND ZSI.Door_NormalStop AND NOT ZSI.Door_Opened",
      "flow_automatic": [
        "1. Operatore chiede apertura porta \u2192 ZSI.Door_NormalStop = TRUE",
        "2. Manager smette di dare comandi",
        "3. Feed si ferma",
        "4. Latch attivo \u2192 blocca nuovi movimenti",
        "5. Safety verifica condizioni \u2192 apre porta",
        "6. ZSI.Door_Opened = TRUE \u2192 reset latch",
        "7. Movimento con bimanuali safe + SLS"
      ],
      "flow_manual": [
        "1. Operatore chiede apertura porta",
        "2. Se comando manuale in corso \u2192 aspetta rilascio pulsante",
        "3. Appena fermo \u2192 latch attivo",
        "4. Blocca nuovi comandi manuali da pulsanti normali",
        "5. Porta aperta \u2192 movimento solo con bimanuali safe + SLS"
      ],
      "sls_protection": {
        "trigger": "ZSI.Door_Opened = TRUE",
        "action": "IF Vel > Config.SLS_VEL THEN Vel := Config.SLS_VEL",
        "standard": "EN ISO 13849 - Safe Limited Speed"
      }
    },
    "Aborting_Pattern": {
      "description": "Pattern escalation allarmi bottom-up",
      "trigger": "((Cycle AND Standstill) OR (Cycle AND StopAborting) OR Aut OR Control_ON) AND AlarmPresence",
      "meaning": "Se c'\u00e8 allarme in ciclo automatico (o in Aut pronto) \u2192 richiedi arresto in fase di tutta l'area",
      "flow": [
        "1. L2: Allarme attivo + (Cycle OR Aut) \u2192 Aborting = TRUE",
        "2. L2: MachineInterface.Aborting = TRUE",
        "3. L4: Aggrega OR \u2192 ZoneStatus.AtLeastOneMachineIsAborting",
        "4. L5: Aggrega OR \u2192 MachinesStatus.AtLeastOneMachineIsAborting",
        "5. L5: Trigger StopInPhase",
        "6. L5: AreaInterface.StopInPhase := TRUE (broadcast)",
        "7. L4: Sequenzia EnableStopInPhase per ogni macchina della zona",
        "8. L2: Latch stop \u2192 Standstill \u2192 AckStopInPhase",
        "9. L5: Quando tutti ACK \u2192 Cycle := FALSE"
      ],
      "exit_condition": "Reset allarme + nuovo avvio ciclo"
    },
    "Unit_Conversione": {
      "description": "Conversione unit\u00e0 applicazione \u2194 unit\u00e0 TO",
      "ReductionRatio": {
        "formula": "Calc_ReductionRatio(LoadRevolution, MotorRevolution, LeadScrewPitchVal)",
        "meaning": "Rapporto tra unit\u00e0 applicazione (mm) e unit\u00e0 TO (giri motore)"
      },
      "to_TO": {
        "velocity": "Vel_TO := Vel_App / ReductionRatio",
        "acceleration": "Acc_TO := Acc_App / ReductionRatio"
      },
      "from_TO": {
        "velocity": "Vel_App := Vel_TO * ReductionRatio"
      },
      "limits_check": {
        "description": "Dinamiche limitate a DynamicLimits del TO",
        "scl": [
          "Vel := MIN(Vel, TO.DynamicLimits.MaxVelocity * ReductionRatio)",
          "Acc := MIN(Acc, TO.DynamicLimits.MaxAcceleration * ReductionRatio)"
        ]
      },
      "ReductionRatio_Calculation": {
        "description": "Conversione unit\u00e0 applicazione (mm/min) \u2194 unit\u00e0 TO (giri/min motore)",
        "source_function": "Calc_RedutionRatio",
        "inputs": {
          "LeadScrewPitchValue": {
            "type": "LReal",
            "unit": "mm/giro_carico",
            "meaning": "Avanzamento per giro vite"
          },
          "MotorRevolution": {
            "type": "LReal",
            "meaning": "Giri motore nel rapporto di riduzione",
            "example": "5 in un riduttore 5:1"
          },
          "LoadRevolution": {
            "type": "LReal",
            "meaning": "Giri carico nel rapporto di riduzione",
            "example": "1 in un riduttore 5:1"
          }
        },
        "formula_step1": "MotorLoadGearRatio := MotorRevolution / LoadRevolution",
        "formula_step2": "ReductionRatio := LeadScrewPitchValue / MotorLoadGearRatio",
        "formula_simplified": "ReductionRatio = LeadScrewPitchValue \u00d7 (LoadRevolution / MotorRevolution)",
        "result_unit": "mm/giro_motore",
        "error_handling": {
          "condition": "LoadRevolution = 0 OR MotorRevolution = 0",
          "fallback": "MotorLoadGearRatio := 1.0; ReductionRatio := 1.0"
        },
        "practical_example": {
          "setup": "Vite passo 10mm, riduttore 5:1 (5 giri motore \u2192 1 giro vite)",
          "calculation": "GearRatio = 5/1 = 5, ReductionRatio = 10/5 = 2 mm/giro_motore",
          "meaning": "1 giro motore = 0.2 giri vite = 2mm avanzamento"
        },
        "conversiones": {
          "app_to_TO": "Vel_TO := Vel_App / ReductionRatio  // 100mm/min \u2192 50RPM",
          "TO_to_app": "Vel_App := Vel_TO \u00d7 ReductionRatio  // 50RPM \u2192 100mm/min"
        }
      }
    },
    "DSI_integration": {
      "description": "Come L2 usa Device Safety Interface",
      "SafeStop_flow": [
        "DSI.SafeStop passato direttamente a Ax.AxisCtrl.SafeStop",
        "Gen_Cnd include NOT DSI.SafeStop",
        "Gen_Cnd include NOT DSI.DevicesInSafeState"
      ],
      "PowerEnable_flow": [
        "SpeedAxis riceve PowerEnable := DSI.PowerEnable OR Sys.SimulationDevice",
        "PowerPermit in L1 richiede Drive.Infeed_ON"
      ]
    },
    "MachineInterface": {
      "description": "Interfaccia verso Zone Manager (L4) e Area Manager (L5)",
      "AutReady": {
        "formula": "AreaInterface.Aut AND NOT Sts.AlarmPresence",
        "meaning": "Pronto per ciclo automatico"
      },
      "Aborting": {
        "formula": "((Cycle AND Standstill) OR (Cycle AND Aborting) OR Aut OR Control_ON) AND AlarmPresence",
        "meaning": "In stato di abort per allarme \u2192 causa StopInPhase area"
      },
      "MotionsStandStill": {
        "formula": "TON_NoPendingCmd.Q AND Sts.Standstill",
        "meaning": "Tutti i movimenti fermi e nessun comando pendente"
      },
      "AckStopInPhase": {
        "formula": "StopInPhase AND MotionsStandStill",
        "meaning": "Conferma stop in fase completato"
      },
      "AckStopProgrammed": {
        "formula": "StopProgrammed AND MotionsStandStill",
        "meaning": "Conferma stop programmato completato"
      },
      "AlarmsPresence": {
        "formula": "Sts.AlarmPresence",
        "meaning": "Presenza allarmi aggregati (BrakeTimeOut OR Ax.Alarms OR Fan_M.Alarms OR ExternalAlarms)"
      },
      "WarningPresence": {
        "formula": "Sts.WarningPresence",
        "meaning": "Presenza warning aggregati"
      }
    }
  },
  "Config_Combinations": {
    "description": "Configurazioni tipiche per diversi tipi di feeder",
    "feeder_standard_with_fan": {
      "name": "Alimentatore standard con ventilatore",
      "physical": "Rulli motorizzati, motore brushless, ventilatore raffreddamento",
      "config": {
        "Fan.Exist": true,
        "Brake_Presence": false,
        "SLS_VEL": 1000.0
      },
      "behavior": "Fan deve essere Running prima di muovere, graceful degradation se Fan KO durante movimento"
    },
    "feeder_no_fan": {
      "name": "Alimentatore senza ventilatore",
      "physical": "Rulli motorizzati, motore autoventilato",
      "config": {
        "Fan.Exist": false,
        "Brake_Presence": false,
        "SLS_VEL": 1000.0
      },
      "behavior": "Fan.Running forzato TRUE, movimento immediato"
    },
    "feeder_with_brake_induction": {
      "name": "Alimentatore con freno (motore induzione)",
      "physical": "Rulli motorizzati, motore asincrono con freno esterno 400V",
      "config": {
        "Fan.Exist": true,
        "Brake_Presence": true,
        "SLS_VEL": 500.0
      },
      "behavior": "Monitora feedback freno da CU Sinamics, allarme su mismatch"
    },
    "feeder_brushless_no_brake_monitoring": {
      "name": "Alimentatore brushless",
      "physical": "Rulli motorizzati, motore brushless con freno 24V integrato",
      "config": {
        "Fan.Exist": true,
        "Brake_Presence": false,
        "SLS_VEL": 1000.0
      },
      "behavior": "Freno gestito internamente da Sinamics, PLC non monitora"
    },
    "high_speed_feeder": {
      "name": "Alimentatore alta velocit\u00e0",
      "physical": "Rulli ad alta velocit\u00e0, curve S",
      "config": {
        "Fan.Exist": true,
        "Brake_Presence": false,
        "SLS_VEL": 2000.0,
        "Par.Man.DelayChangeVel": "T#2s"
      },
      "behavior": "Cambio velocit\u00e0 manuale Low\u2192High dopo 2s"
    }
  },
  "L3_integration_patterns": {
    "description": "Integration patterns per generazione L3",
    "passthrough_direct": {
      "description": "L3 passa senza modifiche",
      "fields": [
        "Manager.EnableStopDoorOpeningReq",
        "Manager.EnableStopInPhase",
        "Manager.EnableStopProgrammed",
        "Config.*",
        "Alarm.*",
        "Warning.*"
      ],
      "scl_pattern": "t_CIn_{Instance}.Manager.EnableStopInPhase := CIn.Manager.EnableStopInPhase;"
    },
    "broadcast_shared": {
      "description": "Stesso valore a tutte le istanze",
      "fields": [
        "AreaInterface",
        "ZSI"
      ],
      "scl_pattern": "// Broadcast - assegnati nella chiamata FB"
    },
    "per_instance_commands": {
      "description": "Comandi movimento specifici per istanza",
      "fields": [
        "Manager.Bwd",
        "Manager.Fwd",
        "Manager.Vel",
        "Manager.Acc",
        "Manager.Dec",
        "Manager.Jerk"
      ],
      "scl_pattern": "t_CIn_{Instance}.Manager.Fwd := CIn.{Instance}.Fwd;"
    },
    "ext_enable_inter_device": {
      "description": "Condizioni ExtEnable basate su stati altri device",
      "fields": [
        "Bwd_ExtEnable",
        "Fwd_ExtEnable"
      ],
      "patterns": {
        "independent": "t_CIn_{Instance}.Fwd_ExtEnable := TRUE;",
        "sequential": "t_CIn_{Instance}.Fwd_ExtEnable := {OtherInstance}.COut.IsAtWork;",
        "from_l3_cin": "t_CIn_{Instance}.Bwd_ExtEnable := CIn.ExtCnd.{Instance}_CanMoveBackward;"
      }
    },
    "control_on_extended": {
      "description": "Control_ON esteso con comandi device-specific",
      "scl_pattern": "t_CIn_{Instance}.Manager.Control_ON := CIn.Manager.Control_ON OR CIn.{Instance}.Bwd OR CIn.{Instance}.Fwd;"
    },
    "aggregation_rules": {
      "description": "Come L3 aggrega COut da tutte le istanze",
      "AND_aggregation": {
        "fields": [
          "AllStandstill",
          "AllCtrlSafe"
        ],
        "pattern": "COut.AllStandstill := {Inst1}.COut.Standstill AND {Inst2}.COut.Standstill;"
      },
      "OR_aggregation": {
        "fields": [
          "AnyInfeed_ReqON",
          "AnyAlarmsPresence"
        ],
        "pattern": "COut.AnyInfeed_ReqON := {Inst1}.COut.Infeed_ReqON OR {Inst2}.COut.Infeed_ReqON;"
      }
    },
    "velocity_sync_pattern": {
      "description": "Pattern per sincronizzare velocit\u00e0 tra feeder",
      "example": {
        "scenario": "Due feeder che devono andare alla stessa velocit\u00e0",
        "scl": [
          "// Master fornisce velocit\u00e0",
          "t_CIn_Feed2.Manager.Vel := Feed1.COut.ActualVelocity;",
          "// Oppure da parametro comune",
          "t_CIn_Feed1.Manager.Vel := CIn.CommonVelocity;",
          "t_CIn_Feed2.Manager.Vel := CIn.CommonVelocity;"
        ]
      }
    },
    "velocity_override_from_loop": {
      "description": "Pattern per controllo velocit\u00e0 da loop/ansa",
      "example": {
        "scenario": "Loop controller modula velocit\u00e0 feeder ingresso",
        "scl": [
          "// Loop calcola percentuale in base a quantit\u00e0 materiale",
          "t_CIn_FeedIn.VelocityOverride.Enable := LoopControl.Active;",
          "t_CIn_FeedIn.VelocityOverride.Value := LoopControl.CalcPercent;  // 1-100%"
        ]
      }
    },
    "check_next_coordination": {
      "description": "Pattern per coordinamento con CheckNext",
      "example": {
        "scenario": "Feeder + Rullo pinch: rullo deve chiudersi prima di avanzare",
        "scl": [
          "// Feeder vuole avanzare \u2192 CheckNext come trigger",
          "IF Feed.COut.Fwd_CheckNext THEN",
          "    // Comanda chiusura rullo",
          "    t_CIn_Rullo.Manager.Work := TRUE;",
          "END_IF;",
          "",
          "// Rullo chiuso \u2192 abilita avanzamento feeder",
          "t_CIn_Feed.Fwd_ExtEnable := Rullo.COut.Work;"
        ]
      }
    },
    "infeed_aggregation": {
      "description": "Pattern aggregazione richieste Infeed",
      "nota": "Gestito ESTERNO a L3 - tipicamente a livello Area o dedicato",
      "example_scl": [
        "// Aggregatore Infeed (NON in L3 machine)",
        "InfeedRequest := Feed1.COut.Infeed_ReqON OR Feed2.COut.Infeed_ReqON OR Axis1.Infeed_ReqON;",
        "",
        "// Infeed FB",
        "Infeed(Request := InfeedRequest, ...);",
        "",
        "// Broadcast a tutti i drive",
        "Drive1.Infeed_ON := Infeed.Running;",
        "Drive2.Infeed_ON := Infeed.Running;"
      ]
    },
    "drive_tokenchain_mapping": {
      "description": "Mapping drive -> CU chain, position and HW_ID for parameter access",
      "rules": [
        "TokenChain selects the CU chain (TOKENCHAIN_CU1..TOKENCHAIN_CU8).",
        "AxisID/AxisNo is the drive position inside the CU (Token_CONST: CUx_ID_y_*).",
        "AccessPoint is the HW_ID of the CU from TIA hardware config.",
        "All three must match the electrical schema and CU parameterization."
      ],
      "scl_example": [
        "// Example for a drive on CU2, position 4",
        "t_CIn_Feed1.Drive.AccessPoint := <HWID_CU2>;",
        "t_CIn_Feed1.Drive.TokenChain := TOKENCHAIN_CU2;",
        "t_CIn_Feed1.Drive.AxisID := CU2_ID_4_830A1_830M1;"
      ],
      "source_files": [
        "TokenChain_FC.scl",
        "GetToken.scl",
        "RW_SINAMICS_Par.scl",
        "Token_CONST.xml/Token_CONST.csv"
      ],
      "notes": [
        "TokenChain_FC is called in System_CALL to advance tokens.",
        "GetToken serializes RW_SINAMICS_Par per CU."
      ]
    }
  },
  "handshake_summary": {
    "description": "Riassunto degli handshake critici",
    "CheckNext_handshake": {
      "purpose": "Coordinamento inter-device per movimento",
      "direction": "Device \u2192 L3 \u2192 Altri Device \u2192 Device",
      "flow": [
        "Feed riceve comando Fwd \u2192 Fwd_CheckNext = TRUE",
        "L3 vede Fwd_CheckNext \u2192 comanda prerequisiti (es. Rullo.Work)",
        "Rullo raggiunge Work \u2192 Rullo.COut.Work = TRUE",
        "L3 collega: Feed.Fwd_ExtEnable := Rullo.COut.Work",
        "Feed esegue movimento forward",
        "Movimento completato \u2192 Fwd_CheckNext = FALSE"
      ]
    },
    "CtrlSafe_handshake": {
      "purpose": "Feedback verso Safety PLC per gestione potenza",
      "direction": "Device \u2192 L3 aggregation \u2192 Safety PLC",
      "semantics": "CtrlSafe \u00e8 FEEDBACK non DECISIONE",
      "flow": [
        "Feed in movimento \u2192 CtrlSafe = TRUE (ho bisogno di coppia)",
        "L3 aggrega: AllCtrlSafe = TRUE",
        "Safety PLC mantiene potenza",
        "Feed fermo + nessun comando \u2192 CtrlSafe = FALSE",
        "L3: AllCtrlSafe = FALSE",
        "Safety PLC pu\u00f2 fare STO se richiesto (es. apertura porta)"
      ]
    },
    "Infeed_handshake": {
      "purpose": "Gestione DC bus comune (shared resource)",
      "direction": "Devices \u2192 OR aggregation \u2192 Infeed FB \u2192 Broadcast",
      "independence": "Gestito indipendentemente da L3/L4",
      "flow": [
        "Feed richiede movimento \u2192 Infeed_ReqON = TRUE",
        "Aggregatore esterno fa OR di tutte le richieste",
        "Infeed FB accende DC bus S120",
        "Infeed.Running \u2192 Drive.Infeed_ON = TRUE (broadcast)",
        "SpeedAxis vede Infeed_ON \u2192 pu\u00f2 fare MC_POWER",
        "Tutte richieste FALSE \u2192 dopo timeout \u2192 Infeed spegne"
      ]
    },
    "Aborting_handshake": {
      "purpose": "Escalation allarmi per arresto coordinato area",
      "direction": "L2 \u2192 L4 \u2192 L5 (bottom-up) \u2192 L5 \u2192 L4 \u2192 L2 (top-down)",
      "flow": [
        "L2: Allarme + Ciclo \u2192 Aborting = TRUE",
        "L4: OR aggregation \u2192 AtLeastOneMachineIsAborting",
        "L5: Trigger StopInPhase",
        "L5: AreaInterface.StopInPhase broadcast",
        "L4: Sequenzia EnableStopInPhase (Feed prima, poi Pinch, poi Decoiler...)",
        "L2: Latch \u2192 Standstill \u2192 AckStopInPhase",
        "L5: Tutti ACK \u2192 Cycle := FALSE"
      ]
    },
    "DoorOpening_handshake": {
      "purpose": "Apertura porte sicurezza con arresto graceful",
      "direction": "Safety \u2192 L2 \u2192 Safety",
      "flow_automatic": [
        "Operatore chiede apertura \u2192 ZSI.Door_NormalStop = TRUE",
        "Manager (L3/L4) smette di dare comandi",
        "L2 setta EnableStopDoorOpeningReq",
        "Feed si ferma naturalmente",
        "L2: StopDueDoorOpeningRequest latch attivo",
        "L2: CtrlSafe \u2192 FALSE",
        "Safety: AllCtrlSafe = FALSE \u2192 pu\u00f2 aprire porta",
        "ZSI.Door_Opened = TRUE \u2192 reset latch",
        "Movimento solo con bimanuali safe + SLS"
      ],
      "flow_manual": [
        "Operatore chiede apertura",
        "Se pulsante premuto \u2192 aspetta rilascio",
        "Appena fermo \u2192 latch attivo",
        "Blocca pulsanti normali",
        "Porta aperta \u2192 solo bimanuali safe + SLS"
      ]
    }
  },
  "FeedMachine_Manager_UDT": {
    "description": "Comandi automatici da L3/L4 verso FeedMachine",
    "path": "CIn.Manager",
    "fields": {
      "EnableStopDoorOpeningReq": {
        "type": "Bool",
        "semantic": "stop_enable_passthrough",
        "meaning": "Abilita arresto per richiesta apertura porta"
      },
      "EnableStopInPhase": {
        "type": "Bool",
        "semantic": "stop_enable_passthrough",
        "meaning": "Abilita arresto in fase (sincronizzato)"
      },
      "EnableStopProgrammed": {
        "type": "Bool",
        "semantic": "stop_enable_passthrough",
        "meaning": "Abilita arresto programmato"
      },
      "Control_ON": {
        "type": "Bool",
        "semantic": "mode_selector",
        "meaning": "Selettore Aut/Man: TRUE=Automatico, FALSE=Manuale"
      },
      "Bwd": {
        "type": "Bool",
        "semantic": "auto_command_direction",
        "meaning": "Comando movimento backward",
        "condition": "Attivo solo se Control_ON=TRUE AND NOT Fwd"
      },
      "Fwd": {
        "type": "Bool",
        "semantic": "auto_command_direction",
        "meaning": "Comando movimento forward",
        "condition": "Attivo solo if Control_ON=TRUE AND NOT Bwd"
      },
      "Vel": {
        "type": "LReal",
        "semantic": "auto_setpoint",
        "meaning": "Velocit\u00e0 target automatico (unit\u00e0 applicazione mm/min)"
      },
      "Acc": {
        "type": "LReal",
        "semantic": "auto_setpoint",
        "meaning": "Accelerazione automatico"
      },
      "Dec": {
        "type": "LReal",
        "semantic": "auto_setpoint",
        "meaning": "Decelerazione automatico"
      },
      "Jerk": {
        "type": "LReal",
        "semantic": "auto_setpoint",
        "meaning": "Jerk automatico (0 = rampa lineare)"
      }
    }
  },
  "AreaInterface_UDT": {
    "description": "Interfaccia broadcast da L5 Area Manager verso tutte le macchine dell'area",
    "broadcast_scope": "Tutte le macchine dell'area ricevono gli stessi valori",
    "fields": {
      "EStop": {
        "type": "Bool",
        "meaning": "Emergenza area attiva"
      },
      "Man": {
        "type": "Bool",
        "meaning": "Modalit\u00e0 manuale area attiva"
      },
      "Aut": {
        "type": "Bool",
        "meaning": "Modalit\u00e0 automatica area pronta"
      },
      "Cycle": {
        "type": "Bool",
        "meaning": "Ciclo automatico area in esecuzione"
      },
      "StopInPhase": {
        "type": "Bool",
        "meaning": "Richiesta stop in fase broadcast"
      },
      "StopProgrammed": {
        "type": "Bool",
        "meaning": "Richiesta stop programmato broadcast"
      },
      "RstAlarms": {
        "type": "Bool",
        "meaning": "Reset allarmi area (positive edge)"
      },
      "CheckAutReady": {
        "type": "Bool",
        "meaning": "Richiesta verifica AutReady attiva"
      }
    }
  },
  "ZoneSafetyInterface_UDT": {
    "description": "Interfaccia da Safety PLC per gestione porte zona",
    "fields": {
      "Door_NormalStop": {
        "type": "Bool",
        "meaning": "Richiesta apertura porta con arresto normale"
      },
      "Door_SafeStop": {
        "type": "Bool",
        "meaning": "Porta aperta senza autorizzazione - STOP SICUREZZA"
      },
      "Door_Opened": {
        "type": "Bool",
        "meaning": "Porta zona fisicamente aperta"
      },
      "Door_EntryEnable": {
        "type": "Bool",
        "meaning": "Ingresso zona abilitato"
      }
    }
  },
  "MachineInterface_UDT": {
    "description": "Interfaccia da L2 verso L4 Zone Manager / L5 Area Manager",
    "fields": {
      "AutReady": {
        "type": "Bool",
        "formula": "AreaInterface.Aut AND NOT Sts.AlarmPresence"
      },
      "Aborting": {
        "type": "Bool",
        "meaning": "Macchina in stato abort causa allarme"
      },
      "AckStopInPhase": {
        "type": "Bool",
        "formula": "StopInPhase AND MotionsStandStill"
      },
      "AckStopProgrammed": {
        "type": "Bool",
        "formula": "StopProgrammed AND MotionsStandStill"
      },
      "MotionsStandStill": {
        "type": "Bool",
        "formula": "TON_NoPendingCmd.Q AND Sts.Standstill"
      },
      "AlarmsPresence": {
        "type": "Bool",
        "meaning": "Presenza allarmi aggregati"
      },
      "WarningPresence": {
        "type": "Bool",
        "meaning": "Presenza warning aggregati"
      }
    }
  },
  "L3_UDT_Templates": {
    "description": "Strutture dati suggerite per blocchi L3 aggregatori",
    "L3_CIn_Template": {
      "Manager": "Riferimento Manager L4 - passthrough",
      "AreaInterface": "Broadcast area - uguale per tutti",
      "ZSI": "Broadcast zona sicurezza",
      "ExtCnd": "Condizioni calcolate da L3 per ExtEnable devices",
      "PerInstanceCommands": "Comandi specifici per istanza"
    },
    "L3_COut_Template": {
      "AllStandstill": {
        "aggregation": "AND"
      },
      "AllCtrlSafe": {
        "aggregation": "AND",
        "destination": "Safety PLC"
      },
      "AnyInfeed_ReqON": {
        "aggregation": "OR"
      },
      "AnyAlarmsPresence": {
        "aggregation": "OR"
      }
    }
  },
  "Responsibility_Matrix": {
    "Infeed_DC_Bus": {
      "aggregation_level": "ESTERNO A L3 - Area level o Drive Manager dedicato",
      "L3_role": "NESSUNO - L3 passa solo COut.Infeed_ReqON verso aggregatore"
    },
    "HU_Hydraulic_Unit": {
      "aggregation_level": "DIPENDE DA CONFIGURAZIONE FISICA",
      "L3_minimum": "Sempre esporre COut.ReqOilPressure"
    },
    "Safety_Aggregation": {
      "aggregation_level": "L3 \u2192 L4 \u2192 Safety PLC",
      "L3_responsibility": "Aggregare con AND, NON decidere sulla sicurezza"
    }
  },
  "L3_Timeout_Handling": {
    "CheckNext_Timeout": {
      "problem": "Device CheckNext=TRUE ma condizioni non si verificano mai",
      "solution": {
        "timeout": "Config.DelayMissingCondition \u00d7 2",
        "action": "L3 \u2192 inietta ExternalAlarms verso device in attesa"
      }
    }
  },
  "L3_Common_Mistakes": {
    "mistake_1": {
      "error": "Dimenticare aggregazione ExternalAlarms",
      "fix": "Sempre includere CIn.ExternalAlarms"
    },
    "mistake_2": {
      "error": "ExtEnable sempre TRUE quando condizionato",
      "fix": "Analizzare dipendenze fisiche"
    },
    "mistake_3": {
      "error": "Confondere CheckNext con stato fisico",
      "fix": "CheckNext=richiesta, State=reale"
    },
    "mistake_4": {
      "error": "CtrlSafe aggregato con OR invece AND",
      "fix": "AllCtrlSafe := AND di tutti"
    }
  },
  "L3_Validation_Checklist": {
    "structure": {
      "rule_1": "Ogni COut aggregato deve avere logica in L3"
    },
    "timing": {
      "rule_2": "CheckNext timeout o ExternalAlarm"
    },
    "safety": {
      "rule_3": "CtrlSafe aggregato con AND"
    },
    "resources": {
      "rule_6": "Infeed_ReqON aggregato con OR"
    },
    "commands": {
      "rule_9": "Manager passthrough per stop enables"
    }
  },
  "Standard_Schema": {
    "Schema_Version": "1.0",
    "Standard_Sections": [
      "meta",
      "Precondizioni",
      "Variabili_Globali",
      "L1",
      "L2",
      "L3",
      "Pattern_Integrazione_L3",
      "Matrice_Responsabilita",
      "Errori_Comuni_L3",
      "Checklist_Validazione_L3"
    ],
    "Note": "Le sezioni italiane sono alias delle sezioni tecniche esistenti; usare i contenuti piu dettagliati presenti nel file."
  },
  "TODO_Strategy": {
    "goal": "Allow first pass code generation to compile in TIA while leaving TODOs for missing mappings.",
    "rules": [
      "Use TODOs only in comments, never as placeholder variable names.",
      "Always assign a safe default value so the code compiles.",
      "Resolve TODOs in a second pass by replacing the full assignment line."
    ],
    "safe_defaults": {
      "Bool": "FALSE",
      "LReal": "0.0",
      "Int/UInt": "0"
    },
    "example_block": [
      "// TODO: Map real device command",
      "t_CIn_Device.Manager.Control_ON := FALSE;",
      "// TODO: Map real setpoint",
      "t_CIn_Device.Manager.Vel := 0.0;"
    ]
  }
}