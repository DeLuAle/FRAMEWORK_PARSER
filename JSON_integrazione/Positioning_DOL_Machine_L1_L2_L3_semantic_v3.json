{
  "meta": {
    "analysis_scope": "L1_OnOffAxis + L1_SpeedMotor + L2_Positioning_DOL_Machine",
    "version": "3.0",
    "analysis_date": "2026-01-07",
    "physical_model": "Positioning system using Variable Speed Drive (Sinamics S120) + Encoder Feedback. 'Hybrid' architecture using discrete logic controller (OnOffAxis) driving an analog-style speed reference.",
    "key_features": [
      "Drive Control - Usos Sinamics S120 via TEL1 (SpeedMotor)",
      "Variable Speed - Dynamically selects Low/Med/High velocity based on distance",
      "Logic Split - OnOffAxis handles position evaluation, L2 FB handles speed generation",
      "Dynamic Deceleration - Drive ramp times used for smooth stop (unlike contactor slamming)",
      "Safety - STO handling integration",
      "Unit Transformation - Native conversion between Machine Units (Um1) and Display/Profile Units (Um2)"
    ]
  },
  "Preconditions": {
    "Required_Inputs": {
      "L3_Machine_List": "List of L3/L4 machine instances and their call blocks",
      "L3_CIn_Mapping": "Mapping for Manager/ExtEnable/Config/DSI and any HMI manual commands",
      "L3_COut_Aggregation": "Which COut signals must be aggregated and where they are consumed",
      "Safety_Inputs": "AreaInterface, ZSI/DSI signals and any interlocks"
    },
    "Question_Gate": {
      "If_Missing": [
        "Stop and ask for the missing inputs before generating L3 integration."
      ],
      "Minimum_Questions": [
        "Which L3/L4 machine instances are present and what are their call block names?",
        "Which Manager/ExtEnable/Config/DSI fields are used for this machine type?",
        "Which COut signals must be aggregated in L3?",
        "Which safety/area signals (AreaInterface, ZSI/DSI) must be wired?"
      ]
    }
  },
  "Unit_Transformation": {
    "description": "Linear transformation handling between Control Units (Um1) and Human Interface/Profile Units (Um2). Allows the HMI to work in a different unit (e.g. inches, degrees) than the logic.",
    "Definitions": {
      "Um1 (Unit 1)": "Primary/Machine Unit. The unit used by the logic, L1 controllers, and standard calculations (e.g. mm).",
      "Um2 (Unit 2)": "Secondary/Display Unit. The unit presented to the operator or defined in product recipes (e.g. inches)."
    },
    "Functions": {
      "Um1-2": {
        "Formula": "Um2 = (Um1 * m) + q",
        "Source_File": "Um1-2.scl",
        "Usage": "Displaying actual position data to HMI (COut.ActualPosition -> HMI.Sts.ActualPos_UM2)"
      },
      "Um2-1": {
        "Formula": "Um1 = (Um2 - q) / m",
        "Source_File": "Um2-1.scl",
        "Usage": "Converting setpoints from HMI/Recipe to logical values (HMI.PresetPosition -> Ax.AxisCtrl.HomePosition)"
      }
    },
    "Data_Type": {
      "Name": "udt_LinTranformation",
      "Fields": {
        "m": "Slope/Multiplier (Real)",
        "q": "Offset (Real)"
      }
    }
  },
  "L1_OnOffAxis": {
    "description": "Logic Controller for Positioning context. In DOL, it acts as the 'Distance State Machine', telling the L2 System *which* speed window applies, rather than driving contactors directly.",
    "source_file": "OnOffAxis.scl",
    "role_in_DOL": {
      "Input": "Position Feedback & Target",
      "Processing": "Evaluates distance to target against 'PreEnd' windows",
      "Outputs_Used": [
        "CmdLowSpeed",
        "CmdMediumSpeed",
        "CmdHighSpeed",
        "CmdMinus/CmdPlus (Direction)"
      ]
    },
    "Config": {
      "StandStillDelay": "Mapped to S120.DecTime (plus margin) to align logical standstill with physical drive ramp down",
      "PreEndMedSpeed": "Distance to start ramping down from High to Med",
      "PreEndLowSpeed": "Distance to start ramping down from Med to Low",
      "PreCutOff": "Distance to cut torque completely (final stop)"
    }
  },
  "L1_SpeedMotor": {
    "description": "Drive Wrapper for Sinamics S120 (TEL1). Receives velocity commands from the L2 logic.",
    "source_file": "SpeedMotor.scl",
    "role_in_DOL": {
      "Input": "Velocity Setpoint & Direction from L2 Logic",
      "Function": "Executes speed ramp, handles Infeed power, reports actual velocity/current",
      "Parameterization": "ReferenceVelocity used to scale % commands from L2"
    }
  },
  "L2_Positioning_DOL_Machine": {
    "description": "Aggregator L2 for Drive Open Loop Positioning. Bridges the discreet logic of OnOffAxis with the continuous control of SpeedMotor.",
    "structure": {
      "Ax": "L1_OnOffAxis instance (The Brain)",
      "S120": "L1_SpeedMotor instance (The Muscle)",
      "PosFeedback": "External interface (Encoder)"
    },
    "Velocity_Logica": {
      "description": "Converts OnOffAxis discrete speed flags into continuous S120 velocity setpoints",
      "Algorithm": [
        "IF Ax.CmdLowSpeed THEN Speed = Par.LowSpeed %",
        "ELSIF Ax.CmdMediumSpeed THEN Speed = Par.MedSpeed %",
        "ELSIF Ax.CmdHighSpeed THEN Speed = Par.HighSpeed %",
        "ELSE Speed = 0.0"
      ],
      "Overrides": [
        "Manual Override: Multiplied by CIn.Manager.Speed / 100",
        "Brake Hold: Force Speed 0.0 if Brake not released"
      ]
    },
    "Mapping": {
      "Direction": "Ax.CmdMinus -> S120.MoveMinus, Ax.CmdPlus -> S120.MovePlus",
      "Power": "CIn.Manager.Control_ON OR ExternalPowerOn -> S120.Power",
      "Safety": "AreaInterface.SafeStop -> S120.SafeStop"
    },
    "Config": {
      "Ax": "OnOffAxis Limits & Windows",
      "S120": "Drive Ramp times (Acc/Dec), Reference Velocity",
      "Fan": "Optional Motor Fan control features"
    },
    "Par": {
      "PosTolerance": "Positioning Window",
      "Low/Med/HighSpeed": "Velocity setpoints (%) for each zone",
      "PreEndLow/MedSpeed": "Distance thresholds for zone transition"
    },
    "Alarms": {
      "BrakeTimeOut": "Brake failed to release/engage",
      "S120_ComErr": "Profinet Communication lost",
      "S120": "Bubbled up Drive Faults",
      "Ax": "Bubbled up Positioning Logic Faults"
    },
    "PosFbk_Interface_and_Variants": {
      "description": "Usos standard PosFbk_ITF. See MOL machine or generic documentation for variants (Sick, Baumer, Analog, etc.)."
    }
  },
  "L3_Integration_Patterns": {
    "passthrough_direct": {
      "description": "L3 passes Manager stop enables and Config/Alarm/Warning without modification",
      "scl_pattern": "t_CIn_{Instance}.Manager.EnableStopInPhase := CIn.Manager.EnableStopInPhase;"
    },
    "broadcast_shared": {
      "description": "Broadcast AreaInterface and ZSI/DSI to all instances",
      "scl_pattern": "t_CIn_{Instance}.AreaInterface := AreaInterface;"
    },
    "ext_enable": {
      "description": "ExtEnable derived from other device states or set TRUE if no interlock",
      "scl_pattern": "t_CIn_{Instance}.Fwd_ExtEnable := TRUE;"
    },
    "aggregation_rules": {
      "description": "Aggregate COut signals with AND/OR as required",
      "scl_pattern": "COut.AllStandstill := Inst1.COut.Standstill AND Inst2.COut.Standstill;"
    },
    "drive_tokenchain_mapping": {
      "description": "Mapping drive -> CU chain, position and HW_ID for parameter access",
      "rules": [
        "TokenChain selects the CU chain (TOKENCHAIN_CU1..TOKENCHAIN_CU8).",
        "AxisID/AxisNo is the drive position inside the CU (Token_CONST: CUx_ID_y_*).",
        "AccessPoint is the HW_ID of the CU from TIA hardware config.",
        "All three must match the electrical schema and CU parameterization."
      ],
      "scl_example": [
        "// Example for a drive on CU3, position 2",
        "t_CIn_DOL1.Drive.AccessPoint := <HWID_CU3>;",
        "t_CIn_DOL1.Drive.TokenChain := TOKENCHAIN_CU3;",
        "t_CIn_DOL1.Drive.AxisID := CU3_ID_2_1410A1_1_1410M1;"
      ],
      "source_files": [
        "TokenChain_FC.scl",
        "GetToken.scl",
        "RW_SINAMICS_Par.scl",
        "Token_CONST.xml/Token_CONST.csv"
      ],
      "notes": [
        "TokenChain_FC is called in System_CALL to advance tokens.",
        "GetToken serializes RW_SINAMICS_Par per CU."
      ]
    }
  },
  "L3_Validation_Checklist": {
    "inputs": "Required inputs provided and mapped",
    "safety": "AreaInterface/ZSI/DSI wired and consistent",
    "aggregation": "COut aggregation implemented as specified",
    "commands": "Manager/Manual commands mapped without conflicts"
  },
  "Standard_Schema": {
    "Schema_Version": "1.0",
    "Standard_Sections": [
      "meta",
      "Precondizioni",
      "Variabili_Globali",
      "L1",
      "L2",
      "L3",
      "Pattern_Integrazione_L3",
      "Matrice_Responsabilita",
      "Errori_Comuni_L3",
      "Checklist_Validazione_L3"
    ],
    "Note": "Le sezioni italiane sono alias delle sezioni tecniche esistenti; usare i contenuti piu dettagliati presenti nel file."
  },
  "TODO_Strategy": {
    "goal": "Allow first pass code generation to compile in TIA while leaving TODOs for missing mappings.",
    "rules": [
      "Use TODOs only in comments, never as placeholder variable names.",
      "Always assign a safe default value so the code compiles.",
      "Resolve TODOs in a second pass by replacing the full assignment line."
    ],
    "safe_defaults": {
      "Bool": "FALSE",
      "LReal": "0.0",
      "Int/UInt": "0"
    },
    "example_block": [
      "// TODO: Map real device command",
      "t_CIn_Device.Manager.Control_ON := FALSE;",
      "// TODO: Map real setpoint",
      "t_CIn_Device.Manager.Vel := 0.0;"
    ]
  }
}