// Block: FlyingStation_Manager
// Title: Reset Alarms

FUNCTION_BLOCK "FlyingStation_Manager"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Reset Alarms
   VAR_INPUT
      Rst : Bool;
      MaterialCounter : Struct
         AlrPresence : Bool;
         WngPresence : Bool;
         Data : MatCountData;
      END_STRUCT;
      Config : Struct
         CutoffStation : Bool;
      END_STRUCT;
      CIn : Struct
         WorkMode : UInt;
         AreaCycle : Bool;
         Semiautomatic : Bool;
         AreaStop : Bool;
         WorkExtEnable : Bool;
         ReturnExtEnable : Bool;
         Target : Struct
            Valid : Bool;
            MaterialPosition : LReal;
         END_STRUCT;
         Material : Struct
            Presence : Bool;
         END_STRUCT;
         Lead : Struct
            StoppedForWork : Bool;
            Standstill : Bool;
            Vel : LReal;
            Dec : LReal;
            Jerk : LReal;
            FollowingAx_ExtrTime : LReal;
         END_STRUCT;
         Tool : Struct
            AtRest : Bool;
            AtWork : Bool;
            CutoffAtWork : Bool;
            StandStill : Bool;
            Alarm : Bool;
            WorkCycleTime : Time;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      COut : Struct
         FlyingMode : Bool;
         WorkDone : Bool;
         Active : Bool;
         AtHomePosition : Bool;
         AtWorkPosition : Bool;
         CarriageTargetInRange : Bool;
         JobData : Struct
            Gap : LReal;
            MaterialPosition : LReal;
         END_STRUCT;
         Lead : Struct
            LeadMovePermitted : Bool;
            StopFeedingToPerformWork : Bool;
            TargetValid : Bool;
            TargetPosition : LReal;
            Vel : LReal;
         END_STRUCT;
         Tool : Struct
            WorkPermit : Bool;
            Exe_Work : Bool;
         END_STRUCT;
         Carriage : Struct
            Exe_PosAbs : Bool;
            PosAbs_TargetPosAx : LReal;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Lead_TO : TO_PositioningAxis;
      Carriage_TO : TO_SynchronousAxis;
      Carriage : FlyingCarriage_FB;
      Carriage_Parameter : udt_FlyingCarriage_Parameter;
      Carriage_FsParameter : udt_FsParameter;
      RTN : Struct
         LastCut_Material_Position : LReal;
         LastJob_Material_Position : LReal;
         PrevCut_Material_Position : LReal;
         PrevJob_Material_Position : LReal;
      END_STRUCT;
   END_VAR

   VAR
      Sts : Struct
         iSts : UInt;
         WorkMode : UInt;
         AxPosition : LReal;
         MaterialActualPosition : LReal;
         MaterialTargetPosition : LReal;
         WaitingPosition : LReal;
         MaterialMissingToTarget : LReal;
         CarriageTargetPosition : LReal;
         LeadAxSynchPosition : LReal;
         CarriageTargetCutoffPosition : LReal;
         MaterialPositionRelativeToBlade : LReal;
         MaterialPositionRelativeGround : LReal;
         CarriageTargetInRange : Bool;
         PermissionToBackHome : Bool;
         AtCut : Struct
            Lead_Position : LReal;
            Carriage_Position : LReal;
         END_STRUCT;
      END_STRUCT;
      Ctrl : Struct
         STOP : Bool;
      END_STRUCT;
      DynamicWaitingPosition : Struct
         carriageWorkSpace : LReal;
         HomePosition : LReal;
      END_STRUCT;
      Alarm : Struct
         DestinationLost : Bool;
      END_STRUCT;
      Warning : Struct
         NotReachable : Bool;
         NotSynched : Bool;
         WorkByTimeout : Bool;
      END_STRUCT;
      tonAtWorkPosition : TON_TIME;
   END_VAR

   VAR_TEMP
      MODULE : LReal;
      fsError : Int;
      workForward : Bool;
   END_VAR

   VAR CONSTANT
      STS_IDLE : UInt;
      STS_BACKHOME : UInt;
      STS_WAIT : UInt;
      STS_FLY_SYNCH : UInt;
      STS_FLY_WORK : UInt;
      STS_FLY_REST : UInt;
      STS_STILL_1 : UInt;
      STS_STILL_2 : UInt;
      STS_STILL_3 : UInt;
      STS_STILL_WORK : UInt;
      STS_STILL_REST : UInt;
      STS_STOP : UInt;
   END_VAR


BEGIN
   REGION "Reset Alarms"
      IF Rst THEN
          Alarm.DestinationLost  := FALSE;
      END_IF;

   END_REGION

   REGION "Work Mode"
      Sts.WorkMode :=  CIn.WorkMode ;

      IF NOT CIn.AreaCycle THEN    
          CASE Sts.WorkMode OF
              FS_WM_FLYING_FWD,FS_WM_SSTILL_FWD:
                  Sts.WorkMode := FS_WM_SSTILL_FWD;
              ELSE  
                  Sts.WorkMode := FS_WM_SSTILL_LOCAL;
          END_CASE;
      END_IF;

      COut.FlyingMode := Sts.WorkMode >= FS_WM_FLYING_HOME;
      workForward := (Sts.WorkMode = FS_WM_SSTILL_FWD) OR (Sts.WorkMode = FS_WM_FLYING_FWD);

   END_REGION

   REGION "Module"
      MODULE := MaterialCounter.Data.COUNTER_MODULE;

   END_REGION

   REGION "FS: Waiting Position"

      CASE CIn.WorkMode OF
          FS_WM_SSTILL_LOCAL:
              Sts.WaitingPosition := Sts.AxPosition;    
          FS_WM_SSTILL_FWD:
              Sts.WaitingPosition := Carriage_FsParameter.Positions.StillCutPosition;
               
          FS_WM_FLYING_FWD:    // Flying on ending
              DynamicWaitingPosition.carriageWorkSpace := Fs_CalcSlaveSpace(
                          CutoffStation   := Config.CutoffStation,                                                
                          Master_Vel      := CIn.Lead.Vel,
                          Master_Dec      := CIn.Lead.Dec,
                          Master_Jerk     := CIn.Lead.Jerk,
                          Work_CycleTime  := ((CIn.Tool.WorkCycleTime)) / 1000.0, 
                          CarriageAx      := Carriage.Ax, 
                          Carriage_FsParameter := Carriage_FsParameter);

              DynamicWaitingPosition.HomePosition := Carriage_FsParameter.Positions.StillCutPosition
                                                      - DynamicWaitingPosition.carriageWorkSpace;

              Sts.WaitingPosition := ( IN1 := DynamicWaitingPosition.HomePosition, 
                                                 IN2 := Carriage_FsParameter.Positions.HomePosition);
                                                               
      ELSE
              Sts.WaitingPosition := Carriage_FsParameter.Positions.HomePosition;
      END_CASE;

   END_REGION

   REGION "FS:  Station Status"
      // Positions
      Sts.AxPosition                     := Fs_ActualPosition(Carriage_TO);
      Sts.MaterialActualPosition         := M_PosAMinusCostB(PosA:=MaterialCounter.Data.CounterValue,CostB:=Sts.AxPosition,MODULE:=MODULE);
      COut.AtHomePosition                := (Sts.AxPosition - Sts.WaitingPosition) < Carriage_Parameter.PosTolerance;
      Sts.MaterialPositionRelativeToBlade:= M_PosAMinusPosB(PosA:=Sts.MaterialActualPosition,PosB:=RTN.LastCut_Material_Position,MODULE:= MODULE);
      Sts.MaterialPositionRelativeGround := M_PosAMinusPosB(PosA:=MaterialCounter.Data.CounterValue,PosB:=RTN.LastCut_Material_Position,MODULE:= MODULE);


      COut.Active := (Sts.iSts > STS_IDLE) AND (Sts.iSts < STS_STOP);

      // Tool work permitted
      COut.Tool.WorkPermit := ((CIn.Lead.Standstill AND Carriage.COut.Standstill)
                               OR Carriage.COut.InSynch
                               OR NOT CIn.Material.Presence)
                               AND (CIn.WorkExtEnable OR (NOT COut.FlyingMode));
                                  
      // Back home permission
      Sts.PermissionToBackHome   := ((Sts.WaitingPosition < Sts.AxPosition) OR (NOT Config.CutoffStation))
                                     AND CIn.ReturnExtEnable;

      // Feeding permitted
      COut.Lead.LeadMovePermitted := CIn.Tool.AtRest OR (Carriage.COut.InSynch AND NOT CIn.Tool.Alarm);

   END_REGION

   REGION "Lead & Carriage Targets"

      IF CIn.Target.Valid AND CIn.Tool.AtRest THEN
          Sts.MaterialTargetPosition     := CIn.Target.MaterialPosition;
          Sts.MaterialMissingToTarget    := M_PosAMinusPosB(PosA:=Sts.MaterialTargetPosition,PosB:= Sts.MaterialActualPosition,MODULE:= MODULE);
          Sts.CarriageTargetPosition     := M_PosAMinusPosB(PosA:=MaterialCounter.Data.CounterValue,PosB:=Sts.MaterialTargetPosition,MODULE:= MODULE);
          Sts.CarriageTargetInRange      := (Sts.CarriageTargetPosition >= Carriage_Parameter.Limits.SwLimNegative)
                                              AND (Sts.CarriageTargetPosition <= Carriage_Parameter.Limits.SwLimPositive);
          
          tonAtWorkPosition(IN := (Sts.MaterialMissingToTarget) < Carriage_Parameter.PosTolerance, PT := Carriage_Parameter.PosWindowDelay);
          COut.AtWorkPosition := tonAtWorkPosition.Q;

          // Carriage & Rollformer Target according to Work Mode
          CASE Sts.WorkMode OF
              FS_WM_SSTILL_LOCAL:   Sts.CarriageTargetCutoffPosition := Sts.AxPosition; Sts.CarriageTargetInRange := FALSE;
              FS_WM_SSTILL_HOME:    Sts.CarriageTargetCutoffPosition := Carriage_FsParameter.Positions.HomePosition;
              ELSE:                   Sts.CarriageTargetCutoffPosition := Carriage_FsParameter.Positions.StillCutPosition;
          END_CASE;
          COut.Lead.TargetPosition := M_PosAPlusCostB(PosA:=Sts.MaterialTargetPosition,CostB:=Sts.CarriageTargetCutoffPosition,MODULE:=MODULE);
          COut.Lead.TargetValid    := TRUE;

      ELSIF CIn.Tool.AtRest THEN
          tonAtWorkPosition(IN := FALSE, PT := Carriage_Parameter.PosWindowDelay);
          COut.AtWorkPosition := Sts.CarriageTargetInRange := COut.Lead.TargetValid := FALSE;
      END_IF;

   END_REGION

   REGION "FS:  Station STOP"
      Ctrl.STOP := ((((NOT (CIn.AreaCycle) AND NOT (CIn.Semiautomatic)) OR CIn.AreaStop) AND Carriage.COut.Standstill) AND COut.Active);
   END_REGION

   REGION "FS: Station State Machine @@@"
      // Stop the station
      IF Ctrl.STOP THEN
          Sts.iSts := STS_STOP;
      END_IF;


      CASE Sts.iSts OF
              
          STS_IDLE:                                                                              // IDLE
              // Reset commands to tools / Carriage
              COut.Tool.Exe_Work         := FALSE;
              COut.Carriage.Exe_PosAbs   := FALSE;
              COut.Lead.Vel              := CIn.Lead.Vel;
              IF CIn.Lead.FollowingAx_ExtrTime > 0.0 THEN
                  Lead_TO.Extrapolation.FollowingAxisDependentTime := CIn.Lead.FollowingAx_ExtrTime;
              END_IF;

              IF      (CIn.AreaCycle OR CIn.Semiautomatic)
                  AND NOT CIn.AreaStop
                  AND CIn.Tool.AtRest
                  AND Carriage.Ax.AxisSts.Enabled
              THEN
                  IF (Sts.WorkMode >= FS_WM_FLYING_HOME)
                      AND NOT COut.AtHomePosition
                      AND (NOT Sts.CarriageTargetInRange OR (Sts.WaitingPosition > Sts.CarriageTargetPosition ))
                      AND ((Sts.WaitingPosition < Sts.AxPosition) OR (NOT Config.CutoffStation))
                  THEN Sts.iSts := STS_BACKHOME;    // Go home
                  ELSIF Sts.CarriageTargetInRange 
                      THEN
                          COut.Lead.StopFeedingToPerformWork := TRUE;
                          Sts.iSts := STS_STILL_1;     
                  ELSE    Sts.iSts := STS_WAIT;        
                  END_IF;
              END_IF;
              
          STS_BACKHOME:                                                                          // BACK TO HOME
              COut.Carriage.PosAbs_TargetPosAx := Sts.WaitingPosition;
              COut.Carriage.Exe_PosAbs := TRUE;
              IF COut.AtHomePosition THEN
                  COut.Carriage.Exe_PosAbs := FALSE;
                  Sts.iSts := STS_WAIT;
              END_IF;

          STS_WAIT:                                                                             // WAIT FOR OPERATION
              // Waiting for start operations
              IF  (CIn.AreaCycle OR CIn.Semiautomatic)
                  AND NOT CIn.AreaStop
                  AND CIn.Target.Valid
              THEN
                  IF Sts.WorkMode >= FS_WM_FLYING_HOME
                  THEN
                      FS_STARTT(AccDec:=Carriage_FsParameter.SyncDinamics.Acceleration,
                                  Jerk:=Carriage_FsParameter.SyncDinamics.Jerk,
                                  FAK:=MaterialCounter.Data.FAK,
                                  StartAdvance:=Carriage_FsParameter.SyncDinamics.StartAdvanceSpace,
                                  SyncDelay:=Carriage_FsParameter.SyncDinamics.SyncLag,
                                  ExtraSpeed:=Carriage_FsParameter.SyncDinamics.ExtraSpeed,
                                  ErrWindow:=Carriage_FsParameter.FollowingErrorWindow,
                                  ErrDwellTime:=Carriage_FsParameter.DwellTimeErrorWindow,
                                  Timeout:=Carriage_FsParameter.ErrorTimeout,
                                  Ax:=Carriage.Ax);
          
                      IF FS_CHK_ENABLED(Carriage.Ax) THEN
                          Sts.LeadAxSynchPosition := PosMatToPosAxis_Wheel(Data := MaterialCounter.Data, PosMaterial := Sts.MaterialTargetPosition);
                          FS_INSPOS_T(Position:=Sts.LeadAxSynchPosition,
                                        Ax:=Carriage.Ax);       
                          Sts.iSts := STS_FLY_SYNCH;
                      END_IF;
                  ELSE
                      FS_ABORT(Ax:=Carriage.Ax);
                      Sts.iSts := STS_STILL_1;
                  END_IF;
              END_IF;

          STS_FLY_SYNCH:                                                                         // FLYING MODE - WAITING FOR SYNCHRO
              // Waiting for Synchro
              IF NOT FS_CHK_ENABLED(Carriage.Ax) THEN
                  FS_ABORT(Ax:=Carriage.Ax);
                  COut.Lead.StopFeedingToPerformWork := Sts.CarriageTargetInRange AND NOT workForward;
                  Sts.iSts := STS_STILL_1;
              ELSIF FS_CHK_OKTAG(Carriage.Ax) AND COut.Tool.WorkPermit THEN       
                  Sts.iSts := STS_FLY_WORK; 
              ELSIF FS_CHK_OKTAG(Carriage.Ax) AND  CIn.Lead.Standstill THEN
                  COut.Lead.StopFeedingToPerformWork := Sts.CarriageTargetInRange AND NOT workForward;
                  Sts.iSts := STS_STILL_1;            
              END_IF; 
              // Extract warning messages
              fsError := FS_CHK_ERROR(Carriage.Ax);
              Warning.NotReachable   := fsError.%X0;
              Warning.NotSynched     := fsError.%X1;   
              Warning.WorkByTimeout  := fsError.%X3;         

          STS_FLY_WORK:                                                                          // FLYING MODE - WORK   
              COut.Tool.Exe_Work := TRUE;
              IF COut.WorkDone 
              THEN
                  COut.Tool.Exe_Work := FALSE;  
                  Sts.iSts := STS_FLY_REST;         
              END_IF;

          STS_FLY_REST:                                                                          // FLYING MODE - REST  
              COut.Tool.Exe_Work := FALSE;
              IF  CIn.Tool.AtRest 
                  AND (NOT FS_CHK_STL(Carriage.Ax))
                  AND Sts.PermissionToBackHome 
              THEN
                  FS_GOHOME(Position:=Sts.WaitingPosition,
                              Velocity:=Carriage_FsParameter.SyncDinamics.ReturnVelocity,
                              Ax:=Carriage.Ax);
                  Warning.NotReachable := FALSE;
                  Warning.NotSynched := FALSE;
                  COut.Lead.Vel      := CIn.Lead.Vel;
                  IF CIn.Lead.FollowingAx_ExtrTime > 0.0 THEN
                      Lead_TO.Extrapolation.FollowingAxisDependentTime := CIn.Lead.FollowingAx_ExtrTime;
                  END_IF;
                  Sts.iSts := STS_WAIT;
              END_IF;        

          STS_STILL_1:                                                                           // STILL MODE - ROLLFORMER POSITIONING
              FS_ABORT(Ax:=Carriage.Ax);
              COut.Lead.Vel := CIn.Lead.Vel;
              // Wait for Rollformer Positioning on Target
              IF CIn.Lead.StoppedForWork THEN            
                  IF  COut.AtWorkPosition THEN
                      COut.Lead.StopFeedingToPerformWork := TRUE;
                      Sts.iSts := STS_STILL_WORK;
                  ELSIF  Sts.CarriageTargetInRange 
                          AND (Sts.WorkMode > FS_WM_SSTILL_LOCAL) 
                          AND (Sts.CarriageTargetPosition > (Sts.WaitingPosition - Carriage_Parameter.PosTolerance))
                      THEN
                      // Check if material position is reachable from carriage
                      COut.Carriage.PosAbs_TargetPosAx := Sts.CarriageTargetPosition;
                      COut.Lead.StopFeedingToPerformWork := TRUE;
                      Sts.iSts := STS_STILL_2;  
                  ELSIF Sts.CarriageTargetPosition > Carriage_Parameter.Limits.SwLimPositive THEN
                      Alarm.DestinationLost := TRUE;
                      Sts.iSts := STS_STOP;
                  ELSE
                      COut.Lead.StopFeedingToPerformWork := FALSE;
                      Sts.iSts := STS_WAIT;
                  END_IF;
              END_IF;

          STS_STILL_2:                                                                           // STILL MODE - CARRIAGE POSITIONING
              COut.Carriage.Exe_PosAbs := CIn.Tool.AtRest;
              IF  Carriage.COut.PositioningDone 
                  AND Carriage.COut.Standstill
                  AND CIn.Lead.Standstill
                  AND COut.Tool.WorkPermit
              THEN
                  COut.Carriage.Exe_PosAbs := FALSE;
                  IF COut.AtWorkPosition THEN               
                      Sts.iSts := STS_STILL_WORK;
                  ELSE
                      // Retry
                      Sts.iSts := STS_STILL_1;
                  END_IF;
              END_IF;

          STS_STILL_WORK:                                                                        // STILL MODE - WORK      
              COut.Tool.Exe_Work := TRUE;
              IF COut.WorkDone 
              THEN
                  COut.Tool.Exe_Work := FALSE;  
                  Sts.iSts := STS_STILL_REST;         
              END_IF;    

          STS_STILL_REST:                                                                        // STILL MODE - REST  
              IF  CIn.Tool.AtRest THEN
                  COut.Lead.StopFeedingToPerformWork := FALSE;
                  Sts.iSts := STS_IDLE;     
              END_IF; 

           STS_STOP:                                                                            // STOP STATION
              COut.Tool.Exe_Work := FALSE;       
              COut.Carriage.Exe_PosAbs := FALSE;

              IF CIn.Lead.Standstill
              THEN
                  FS_ABORT(Ax:=Carriage.Ax);
              END_IF;            
              
              // Exit from Stop
              IF  CIn.Tool.StandStill 
                  AND Carriage.COut.Standstill
              THEN
                  COut.Lead.StopFeedingToPerformWork := FALSE;
                  IF NOT Ctrl.STOP THEN
                      Sts.iSts := STS_IDLE;
                  END_IF;
              END_IF;


      END_CASE;

   END_REGION

   REGION "On Job Done"
      IF (CIn.Tool.AtWork OR CIn.Tool.CutoffAtWork) AND NOT COut.WorkDone THEN

          COut.WorkDone                   := TRUE;

          RTN.PrevJob_Material_Position      := RTN.LastJob_Material_Position;
          // #Sts.AtCut.Lead_Position            := "PosAxisToPosMat_Wheel"(PosAxis:=#Lead_TO.StatusExtrapolation.ExtrapolatedPosition, Data:=#MaterialCounter.Data);
          Sts.AtCut.Lead_Position            := PosAxisToPosMat_Wheel(PosAxis:=Fs_ActualPosition(Lead_TO), Data:=MaterialCounter.Data);
          Sts.AtCut.Carriage_Position        := Fs_ActualPosition(Carriage_TO);    
          RTN.LastJob_Material_Position      := M_PosAMinusCostB(PosA:= Sts.AtCut.Lead_Position,CostB:=Sts.AtCut.Carriage_Position,MODULE:=MODULE);
          COut.JobData.MaterialPosition      := RTN.LastJob_Material_Position;

          (**)
          IF  Config.CutoffStation AND CIn.Tool.CutoffAtWork THEN
              RTN.PrevCut_Material_Position  := RTN.LastCut_Material_Position;
              RTN.LastCut_Material_Position  := RTN.LastJob_Material_Position;
          
              // Blade Detach 
              IF      Carriage_FsParameter.BladeDetachValue    > 0.0 
                  AND Carriage_FsParameter.BladeDetachVelocity > 0.0   
              THEN
                  FS_GSTL(Gap       := Carriage_FsParameter.BladeDetachValue, 
                            SpeedDiff := Carriage_FsParameter.BladeDetachVelocity, 
                            Ax        := Carriage.Ax);
              END_IF;
          END_IF;   
      END_IF;

      COut.JobData.MaterialPosition   := RTN.LastJob_Material_Position;
      COut.JobData.Gap                := M_PosAMinusPosB(PosA:=RTN.LastJob_Material_Position,PosB:= RTN.PrevJob_Material_Position,MODULE:=MODULE); 

      IF CIn.Tool.AtRest AND COut.WorkDone THEN
          COut.WorkDone                      := FALSE;
          COut.Lead.StopFeedingToPerformWork := FALSE;
      END_IF;

   END_REGION


END_FUNCTION_BLOCK
