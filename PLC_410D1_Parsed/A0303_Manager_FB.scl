// Block: A0303_Manager_FB
// Title: Reset Alarms

FUNCTION_BLOCK "A0303_Manager_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Reset Alarms
   VAR_INPUT
      AreaInterface : AreaInterface;
      DataIn : Struct
         LsCheckPassaggio_Coda : Bool;
         LsCheckPassaggio_Testa : Bool;
         LsPezzoPosMax_Coda : Bool;
         LsPezzoPosMax_Testa : Bool;
         SemiAut_Pb : Bool;
      END_STRUCT;
      CIn : Struct
         PareggiatoreTesta : Struct
            Ax : Positioning_DOL_Machine_COut;
         END_STRUCT;
         PareggiatoreCoda : Struct
            Ax : Positioning_DOL_Machine_COut;
         END_STRUCT;
         Spalle : Struct
            Testa : Struct
               Ax : Positioning_DOL_Machine_COut;
            END_STRUCT;
            Coda : Struct
               Ax : Positioning_DOL_Machine_COut;
            END_STRUCT;
         END_STRUCT;
         Spintore : Struct
            Vrt : ValveMachine_COut;
            Orz : ValveMachine_COut;
         END_STRUCT;
         TraslazioneStrato : Struct
            Ax_Testa : Positioning_EPOS_Machine_COut;
            Ax_Coda : Positioning_EPOS_Machine_COut;
            Manip_Sostegno : ValveMachine_COut;
            Manip_Pareggiatore : ValveMachine_COut;
            SostegnoVrt : ValveMachine_COut;
            IsMeasuring : Bool;
         END_STRUCT;
         Sollevamento : Struct
            Ax_Testa : Positioning_DOL_Machine_COut;
            Ax_Coda : Positioning_DOL_Machine_COut;
         END_STRUCT;
         Sostegno : Struct
            Testa : Struct
               Ax : Positioning_DOL_Machine_COut;
               Paletto : Struct
                  CtrlSafe : Bool;
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Pos : Int;
                  RestPosition : Bool;
               END_STRUCT;
            END_STRUCT;
            Coda : Struct
               Ax : Positioning_DOL_Machine_COut;
               Paletto : Struct
                  CtrlSafe : Bool;
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Pos : Int;
                  RestPosition : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         Navetta : Struct
            ReadyToRecive : Bool;
            OutOfWorkspace : Bool;
            InPosizioneDiDeposito : Bool;
            InPosizioneDiPrelievo : Bool;
            InPosizioneDiPrePrelievo : Bool;
            RequestDeposito : Bool;
            RequestPrelievo : Bool;
         END_STRUCT;
         ProdManager : Prod_Beam_Ctrl;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      COut : Struct
         Spalla : Struct
            Testa : Positioning_DOL_Machine_Manager;
            Coda : Positioning_DOL_Machine_Manager;
         END_STRUCT;
         Spintore : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            CanMoveFreely : Bool;
            Rest : Bool;
            Work : Bool;
         END_STRUCT;
         Trasporto : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            CanMoveFreely : Bool;
            OP : Struct
               VAI_A_PRELIEVO : Bool;
               PRELIEVO : Bool;
               VAI_A_DEPOSITO : Bool;
               DEPOSITO : Bool;
            END_STRUCT;
         END_STRUCT;
         Sollevatore : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            CanMoveFreely : Bool;
            TargetPosition : LReal;
            OP : Struct
               PRELIEVO : Bool;
               PRE_DEPOSITO : Bool;
               DEPOSITO : Bool;
            END_STRUCT;
         END_STRUCT;
         Sostegno : Struct
            Testa : Struct
               EnableStopDoorOpeningReq : Bool;
               EnableStopInPhase : Bool;
               EnableStopProgrammed : Bool;
               Control_ON : Bool;
               CanMoveFreely : Bool;
               Phase : Struct
                  VAI_A_LAVORO : Bool;
                  VAI_A_RIPOSO : Bool;
               END_STRUCT;
               Ax : Struct
                  Pos : LReal;
               END_STRUCT;
               Paletti : Struct
                  PosPaletto : Int;
                  Pos1Collision : Bool;
                  Pos2Collision : Bool;
               END_STRUCT;
            END_STRUCT;
            Coda : Struct
               EnableStopDoorOpeningReq : Bool;
               EnableStopInPhase : Bool;
               EnableStopProgrammed : Bool;
               Control_ON : Bool;
               CanMoveFreely : Bool;
               Phase : Struct
                  VAI_A_LAVORO : Bool;
                  VAI_A_RIPOSO : Bool;
               END_STRUCT;
               Ax : Struct
                  Pos : LReal;
               END_STRUCT;
               Paletti : Struct
                  PosPaletto : Int;
                  Pos1Collision : Bool;
                  Pos2Collision : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         Manipolatore : Struct
            ReadyToRecive : Bool;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         Antiribaltamento : Struct
            Offset_Pos : LReal;
         END_STRUCT;
      END_STRUCT;
      Par_Trasporto : Struct
         PosPrelievo : LReal;
         PosDeposito : LReal;
         ToleranceWindow : LReal;
      END_STRUCT;
      Par_Sollevatore : Struct
         PosDeposito : LReal;
         OffsetPrelievo : LReal;
         ToleranceWindow : LReal;
      END_STRUCT;
      Par_SostegnoAntirib : Struct
         RestPosition : LReal;
         ToleranceWindow : LReal;
         PosTimeout : Time;
      END_STRUCT;
      Par_Spalla_Testa : Struct
         MinDistanzaConParegg : LReal;
         ToleranceWindow : LReal;
      END_STRUCT;
      Par_Spalla_Coda : Struct
         MinDistanzaConParegg : LReal;
         ToleranceWindow : LReal;
      END_STRUCT;
   END_VAR

   VAR
      Alarm : Struct
         TrkPassaggioPezzo : Bool;
         TrkPreparationAlreadyFull : Bool;
         TrkStackerAlreadyFull : Bool;
         PaccoOltreLimiteMax : Bool;
         STOP_FineTurno : Bool;
         STOP_End_Of_Proroduction : Bool;
         STOP_ControlloQualita : Bool;
         "STOP_Inattività" : Bool;
      END_STRUCT;
      Warning : Struct
         IsWaiting_NoPiecesBefore : Bool;
         IsWaiting_NoPiecesBefore_A01NotInCycle : Bool;
         IsWaiting_NoPiecesBefore_A02NotInCycle : Bool;
         IsWaiting_NoPiecesBefore_A03NotInCycle : Bool;
         IsWaiting_ShuttleUnload : Bool;
         IsWaiting_PezziDaRintegrare : Bool;
         STOP_End_Of_Proroduction : Bool;
         STOP_FineTurno : Bool;
         STOP_ControlloQualita : Bool;
         MissingCnd : Struct
            SollevatoreNotReadyToRecive : Bool;
         END_STRUCT;
      END_STRUCT;
      OP_CND : Struct
         Trasporto : Struct
            VaiAPrelievo : Array[0..15] of OpCnd;
            Prelievo : Array[0..15] of OpCnd;
            VaiADeposito : Array[0..15] of OpCnd;
            Deposito : Array[0..15] of OpCnd;
         END_STRUCT;
      END_STRUCT;
      Ctrl : Struct
         Stop : Bool;
         Cycle : Struct
            Trasferimento : Struct
               VaiAPrelievo : Bool;
               Prelievo : Bool;
               VaiADeposito : Bool;
               Deposito : Bool;
            END_STRUCT;
            Sollevamento : Struct
               Prelievo : Bool;
               Deposito : Bool;
               PreDeposito : Bool;
            END_STRUCT;
            SostegnoAntirib_Testa : Struct
               VaiALavoro : Bool;
               VaiARiposo : Bool;
               CyclePos : LReal;
               PalettoPos : Int;
            END_STRUCT;
            SostegnoAntirib_Coda : Struct
               VaiALavoro : Bool;
               VaiARiposo : Bool;
               CyclePos : LReal;
               PalettoPos : Int;
            END_STRUCT;
         END_STRUCT;
         BTrk : Struct
            B3ToLayer1 : Bool;
            TransferToStacker : Bool;
         END_STRUCT;
         Spintore : Struct
            Vrt : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Orz : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Work : Bool;
            Rest : Bool;
         END_STRUCT;
         Spalle : Struct
            Testa : Struct
               MoveToPos : Bool;
               Pos : LReal;
            END_STRUCT;
            Coda : Struct
               MoveToPos : Bool;
               Pos : LReal;
            END_STRUCT;
         END_STRUCT;
         TraslazioneStrato : Struct
            Ax : Struct
               MovePrelievo : Bool;
               MoveDeposito : Bool;
               PosDeposito : LReal;
               PosPrelievo : LReal;
            END_STRUCT;
            SostegnoVrt : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Manip_Sostegno : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Manip_Pareggiatore : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
      END_STRUCT;
      Sts : Struct
         AlarmsPresence : Bool;
         WarningsPresence : Bool;
         IsStandstill : Bool;
         SemiAut : Struct
            ON : Bool;
            PbMaterialFwd : Bool;
            Request : Bool;
         END_STRUCT;
         SpallaTesta : Struct
            InCyclePos : Bool;
         END_STRUCT;
         SpallaCoda : Struct
            InCyclePos : Bool;
         END_STRUCT;
         Sollevatore : Struct
            ReadyToRecive : Bool;
            InPrelievoPos : Bool;
            InPrePrelievoPos : Bool;
            InPosDeposito : Bool;
            InPosPreDeposito : Bool;
         END_STRUCT;
         Preparazione : Struct
            Completato : Bool;
         END_STRUCT;
         TraslazioneStrato : Struct
            InPosDeposito : Bool;
            InPosPrelievo : Bool;
            OutOfWorkspace : Bool;
            DropRequest : Bool;
         END_STRUCT;
         SostegnoTesta : Struct
            Ax : Struct
               InCyclePos : Bool;
               InRestPos : Bool;
            END_STRUCT;
            Paletto : Struct
               InCyclePos : Bool;
            END_STRUCT;
         END_STRUCT;
         SostegnoCoda : Struct
            Ax : Struct
               InCyclePos : Bool;
               InRestPos : Bool;
            END_STRUCT;
            Paletto : Struct
               InCyclePos : Bool;
            END_STRUCT;
         END_STRUCT;
         BTrk : Struct
            ZonePreparationEmpty : Bool;
            ZoneStackerEmpty : Bool;
            Actual_O_ID : DInt;
         END_STRUCT;
      END_STRUCT;
      AUX : Struct
         LsPosition1Coda_PE : Bool;
         LsPosition1Coda_NE : Bool;
         LsPosition1Testa_PE : Bool;
         LsPosition1Testa_NE : Bool;
         TrkToTransfer : Bool;
         TrkToShuttle : Bool;
         SemiAut_Pb : Bool;
      END_STRUCT;
      TON_PassaggioPezzoAlarm : IEC_TIMER;
      TON_NoPiecesBefore : IEC_TIMER;
      TON_Stop : IEC_TIMER;
      TON_StopPerInattivita : IEC_TIMER;
      Attrezzamento : Struct
         Ready : Bool;
         FindNewID : Bool;
         RequestNewPosition : Bool;
         TargetSpalle : LReal;
         TargetSostegno : LReal;
         ID : DInt;
      END_STRUCT;
      CycleWithShortPiece : Bool;
      PE_Engaged_Coda : Bool;
      NE_Engaged_Coda : Bool;
      PE_Engaged_Testa : Bool;
      NE_Engaged_Testa : Bool;
      TON_CheckCompletato_Stacker : IEC_TIMER;
      TON_CheckCompletato_Preparation : IEC_TIMER;
   END_VAR

   VAR_TEMP
      PE : Struct
         LsPosition1_Coda : Bool;
         LsPosition1_Testa : Bool;
         TrkToTransfer : Bool;
         TrkToShuttle : Bool;
      END_STRUCT;
      NE : Struct
         LsPosition1_Coda : Bool;
         LsPosition1_Testa : Bool;
      END_STRUCT;
      BTrk_GetData : Struct
         indx : Int;
         Sts : Int;
         Item : Prod_Item_small;
      END_STRUCT;
      BTrk_Absence : Bool;
      LayerTrk_Absence : Bool;
      O_ID_Precedenti : DInt;
      i : Int;
      EmptyNFound : Int;
      ShiftN : Int;
      TargetPrePositionSollevatore : LReal;
      TargetPositionSollevatore_Temp : LReal;
      TargetPositionSollevatore : LReal;
      TargetPreDepositoSollevatore : LReal;
      SollevatoreCodaInPrelievoPos : Bool;
      SollevatoreTestaInPrelievoPos : Bool;
      SollevatoreCodaInPrePrelievoPos : Bool;
      SollevatoreTestaInPrePrelievoPos : Bool;
      SollevatoreCodaInPosDeposito : Bool;
      SollevatoreTestaInPosDeposito : Bool;
      SollevatoreTestaInPosPreDeposito : Bool;
      SollevatoreCodaInPosPreDeposito : Bool;
      TrasportoTestaInPosDeposito : Bool;
      TrasportoTestaInPosPrelievo : Bool;
      TrasportoCodaInPosDeposito : Bool;
      TrasportoCodaInPosPrelievo : Bool;
      ShiftArrayOk : Int;
      TrkToStackerOk : Int;
      PieceToCheck_Presence : Bool;
      O_ID_Temp : DInt;
      ConteggioPezzi_Preparation : Int;
      ConteggioPezzi_Stacker : Int;
      ConteggioPezzi_Transfert : Int;
      MaxBeamsXLayer : Int;
      MaxLayer : Int;
   END_VAR

   VAR CONSTANT
      TrasportoOutOfWorkspace : LReal;
   END_VAR


BEGIN
   REGION "Reset Alarms"
      IF AreaInterface.RstAlarms THEN
          Alarm.TrkPassaggioPezzo := FALSE;
          Alarm.TrkPreparationAlreadyFull := FALSE;
          Alarm.TrkStackerAlreadyFull := FALSE;
          Alarm.PaccoOltreLimiteMax := FALSE;
          Alarm.STOP_End_Of_Proroduction := FALSE;
          Alarm.STOP_FineTurno := FALSE;
          Alarm.STOP_ControlloQualita := FALSE;
      END_IF;

   END_REGION

   REGION "Fronti Sensori"
      PE.LsPosition1_Coda := PosEdge(DataIn.LsCheckPassaggio_Coda);
      NE.LsPosition1_Coda := NegEdge(DataIn.LsCheckPassaggio_Coda);
      PE.LsPosition1_Testa := PosEdge(DataIn.LsCheckPassaggio_Testa);
      NE.LsPosition1_Testa := NegEdge(DataIn.LsCheckPassaggio_Testa);
   END_REGION

   REGION "Semiautomatico Pb"
      Sts.SemiAut.PbMaterialFwd := NOT (NOT (MB3_Pb_Avanti_Stazione_4_Area03));
      MB3_Lp_Avanti_Stazione_4_Area03 := NOT (NOT (MB3_Pb_Avanti_Stazione_4_Area03));
      Sts.SemiAut.ON := ((PosEdge(Sts.SemiAut.PbMaterialFwd) OR Sts.SemiAut.ON) AND Sts.SemiAut.PbMaterialFwd);
   END_REGION

   REGION "Warning Macchina in attesa scarico navetta"
      "BTrk_Presence"(
         en := (((((BTrk.A0303.Preparation.Beam_Qty = BTrk.A0303.Preparation.BeamsPerLayer_Target) OR BTrk.A0303.Preparation.Completato) AND TRUE) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((((BTrk.A0303.Preparation.Beam_Qty = BTrk.A0303.Preparation.BeamsPerLayer_Target) OR BTrk.A0303.Preparation.Completato) AND TRUE) AND BTrk.A0303.Stacker.Completato)),
         Item := BTrk.A0304.Layers[1].Layer[1]
      );

      IF (((((BTrk.A0303.Preparation.Beam_Qty = BTrk.A0303.Preparation.BeamsPerLayer_Target) OR BTrk.A0303.Preparation.Completato) AND TRUE) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((((BTrk.A0303.Preparation.Beam_Qty = BTrk.A0303.Preparation.BeamsPerLayer_Target) OR BTrk.A0303.Preparation.Completato) AND TRUE) AND BTrk.A0303.Stacker.Completato)) THEN
         "BTrk_Presence"(Item := BTrk.A0304.Layers[1].Layer[1]);
      END_IF;
      Warning.IsWaiting_ShuttleUnload := TRUE;
   END_REGION

   REGION "Warning Macchina in attesa nessun pezzo in arrivo"
      #TON_NoPiecesBefore(
         IN := (((((((AreaInterface.Cycle AND A0303_Spalla_Coda.MachineInterface.MotionsStandStill) AND A0303_Spalla_Testa.MachineInterface.MotionsStandStill) AND A0303_Spintore.MachineInterface.MotionsStandStill) AND A0303_Sollevamento.MachineInterface.MotionsStandStill) AND A0303_Sostegno_Coda.MachineInterface.MotionsStandStill) AND A0303_Sostegno_Testa.MachineInterface.MotionsStandStill) AND A0304_Navetta.MachineInterface.MotionsStandStill),
         PT := t#5s
      );

      "Find_O_ID"(
         en := TON_NoPiecesBefore.Q,
         NumStazione := #STATION_A0303_PREPARATION,
         O_ID => O_ID_Temp
      );

      #TON_NoPiecesBefore.Q;
      IF TON_NoPiecesBefore.Q THEN
         "Find_O_ID"(NumStazione := #STATION_A0303_PREPARATION);
      END_IF;
      Warning.IsWaiting_NoPiecesBefore := (O_ID_Temp <= 0);
      Warning.IsWaiting_NoPiecesBefore_A01NotInCycle := ((((O_ID_Temp > 0) AND NOT (Warning.IsWaiting_NoPiecesBefore_A02NotInCycle)) AND NOT (Warning.IsWaiting_NoPiecesBefore_A03NotInCycle)) AND NOT (Areas_ITF.A03.AreaInterface.Cycle));
      Warning.IsWaiting_NoPiecesBefore_A02NotInCycle := (((((O_ID_Temp > 0) AND NOT (Warning.IsWaiting_NoPiecesBefore_A01NotInCycle)) AND NOT (Warning.IsWaiting_NoPiecesBefore_A03NotInCycle)) AND Areas_ITF.A01.AreaInterface.Cycle) AND NOT (Areas_ITF.A02.AreaInterface.Cycle));
      Warning.IsWaiting_NoPiecesBefore_A03NotInCycle := ((((((O_ID_Temp > 0) AND NOT (Warning.IsWaiting_NoPiecesBefore_A01NotInCycle)) AND NOT (Warning.IsWaiting_NoPiecesBefore_A02NotInCycle)) AND Areas_ITF.A01.AreaInterface.Cycle) AND Areas_ITF.A02.AreaInterface.Cycle) AND NOT (Areas_ITF.A03.AreaInterface.Cycle));
   END_REGION

   REGION "Zona  Vuota"
      //CONTROLLO CHE CI SIANO LE CONDIZIONI PER MUOVERSI (TRK EMPTY)
      //
      FOR i := 1 TO BTRK_A0303_ITEMS DO
          IF BTrk.A0303.Preparation.B.B_ID = 0 THEN
              BTrk_Absence := TRUE;
          ELSE
              BTrk_Absence := FALSE;
              EXIT;
          END_IF;
      END_FOR;

      FOR i := 1 TO BTRK_LAYER_ITEMS DO
          IF BTrk.A0303.Preparation.Layer[i].B_ID = 0 THEN
              LayerTrk_Absence := TRUE;
          ELSE
              LayerTrk_Absence := FALSE;
              EXIT;
          END_IF;
      END_FOR;


      Sts.BTrk.ZonePreparationEmpty := BTrk_Absence AND LayerTrk_Absence AND NOT DataIn.LsCheckPassaggio_Coda;
      Sts.BTrk.ZoneStackerEmpty := BTrk.A0303.Stacker.Empty;

   END_REGION

   REGION "A03_EXIT_TOCHECK controllo che accumulo non abbia pezzi da controllare o rintegrati"
      PieceToCheck_Presence:=PieceToCheck_Presence(Trk_B:=BTrk.A03_EXIT_TOCHECK.B) ;


   END_REGION

   REGION "Cerco order ID nelle macchine precedenti"
      "Find_O_ID"(
         en := Attrezzamento.FindNewID,
         NumStazione := #STATION_A0303_PREPARATION,
         O_ID => Attrezzamento.ID
      );

      "Prod_item_GetData_By_O_ID"(
         en := TRUE,
         O_ID := Attrezzamento.ID,
         Beams_Data := Areas_ITF.Prod.A03_A04.Beams_Data,
         Ret_Val => BTrk_GetData.Sts,
         Item => BTrk_GetData.Item,
         indx => BTrk_GetData.indx
      );

      Attrezzamento.FindNewID := ((((Sts.BTrk.ZonePreparationEmpty AND Sts.BTrk.ZoneStackerEmpty) AND BTrk.A0303.Transfert.Empty) AND BTrk.A0304.Empty) OR (((Sts.BTrk.ZonePreparationEmpty AND Sts.BTrk.ZoneStackerEmpty) AND BTrk.A0303.Transfert.Empty) AND NOT (Sys.ByPass)));
      IF Attrezzamento.FindNewID THEN
         "Find_O_ID"(NumStazione := #STATION_A0303_PREPARATION);
      END_IF;
      BTrk_GetData.Sts := "Prod_item_GetData_By_O_ID"(O_ID := Attrezzamento.ID, Beams_Data := Areas_ITF.Prod.A03_A04.Beams_Data);
      IF ((Attrezzamento.FindNewID AND (Attrezzamento.ID = 0)) AND NOT (PieceToCheck_Presence)) THEN
         BTrk.A0303.Preparation.O_ID := 0;
      END_IF;
   END_REGION

   REGION "Numero Max Beams per Layer / Numero Max Layer"
      CASE (IN:=BTrk.A0303.Preparation.Beam_H_B )OF
              
          0:
              ;
          60:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C060;
              MaxLayer := STACK_LAYERS_QTY_MAX_C060;
          70:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C070;
              MaxLayer := STACK_LAYERS_QTY_MAX_C070;
          80:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C080;
              MaxLayer := STACK_LAYERS_QTY_MAX_C080;
          90:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C090;
              MaxLayer := STACK_LAYERS_QTY_MAX_C090;
          100:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C100;
              MaxLayer := STACK_LAYERS_QTY_MAX_C100;
          110:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C110;
              MaxLayer := STACK_LAYERS_QTY_MAX_C110;
          120:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C120;
              MaxLayer := STACK_LAYERS_QTY_MAX_C120;
          130:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C130;
              MaxLayer := STACK_LAYERS_QTY_MAX_C130;
          140:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C140;
              MaxLayer := STACK_LAYERS_QTY_MAX_C140;
          150:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C150;
              MaxLayer := STACK_LAYERS_QTY_MAX_C150;
          180:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C180;
              MaxLayer := STACK_LAYERS_QTY_MAX_C180;
          200:
              MaxBeamsXLayer := STACK_BEAMS_PER_LAYER_QTY_MAX_C200;
              MaxLayer := STACK_LAYERS_QTY_MAX_C200;
              
              
              
              
              
      END_CASE;

   END_REGION

   REGION "Compilo i dati del btrk in base all'order ID in arrivo"
      IF BTrk_GetData.Sts >= 0 AND BTrk_GetData.Item.Beam_Code = 1 THEN
          
          BTrk.A0303.Preparation.O_ID :=BTrk.A0303.Transfert.O_ID:=BTrk.A0303.Stacker.O_ID:=BTrk.A0304.O_ID:=Attrezzamento.ID;
          BTrk.A0303.Preparation.Beam_Len:= BTrk.A0303.Transfert.Beams_Len := BTrk.A0303.Stacker.Beams_Len := BTrk.A0304.Beams_Len := BTrk_GetData.Item.Beams_Len;
          BTrk.A0303.Preparation.BeamsPerLayer_Target := BTrk.A0303.Transfert.BeamsPerLayer_Target := BTrk.A0303.Stacker.BeamsPerLayer_Target := BTrk.A0304.BeamsPerLayer_Target := (IN1 := BTrk_GetData.Item.PackLayout_BeamsPerLayer, IN2 := MaxBeamsXLayer);
          BTrk.A0303.Preparation.Layers_Target := BTrk.A0303.Transfert.Layers_Target := BTrk.A0303.Stacker.Layers_Target := BTrk.A0304.Layers_Target := (IN1 := BTrk_GetData.Item.PackLayout_Layers_Qty, IN2 := MaxLayer);
          BTrk.A0303.Preparation.Beam_H_B := BTrk.A0303.Transfert.Beams_H_B := BTrk.A0303.Stacker.Beams_H_B := BTrk.A0304.Beams_H_B := BTrk_GetData.Item.Beams_H_B;
          BTrk.A0303.Preparation.Beam_W_A := BTrk.A0303.Transfert.Beams_W_A := BTrk.A0303.Stacker.Beams_W_A := BTrk.A0304.Beams_W_A := BTrk_GetData.Item.Beams_W_A;
          
          
      ELSE
          IF BTrk.A0303.Preparation.O_ID <= 0 THEN
              
              BTrk.A0303.Preparation.O_ID := BTrk.A0303.Transfert.O_ID := BTrk.A0303.Stacker.O_ID := BTrk.A0304.O_ID := -1;
              BTrk.A0303.Preparation.Beam_Len := BTrk.A0303.Transfert.Beams_Len := BTrk.A0303.Stacker.Beams_Len := BTrk.A0304.Beams_Len := -1;
              BTrk.A0303.Preparation.BeamsPerLayer_Target := BTrk.A0303.Transfert.BeamsPerLayer_Target := BTrk.A0303.Stacker.BeamsPerLayer_Target := BTrk.A0304.BeamsPerLayer_Target := -1;
              BTrk.A0303.Preparation.Layers_Target := BTrk.A0303.Transfert.Layers_Target := BTrk.A0303.Stacker.Layers_Target := BTrk.A0304.Layers_Target := -1;
              BTrk.A0303.Preparation.Beam_H_B := BTrk.A0303.Transfert.Beams_H_B := BTrk.A0303.Stacker.Beams_H_B := BTrk.A0304.Beams_H_B := -1;
              BTrk.A0303.Preparation.Beam_W_A := BTrk.A0303.Transfert.Beams_W_A := BTrk.A0303.Stacker.Beams_W_A := BTrk.A0304.Beams_W_A := -1;
              
          END_IF;
          
          ;
      END_IF;

   END_REGION

   REGION "Richiesta nuovo posizionamento x cambio Order ID"
      Attrezzamento.RequestNewPosition := (BTrk.A0303.Preparation.O_ID <> -1)
                                          AND (BTrk_GetData.Sts >= 0)
                                          AND (BTrk_GetData.Item.Beam_Code = 1)
                                          AND Attrezzamento.FindNewID
                                          AND NOT Attrezzamento.Ready
                                          AND NOT PieceToCheck_Presence;

   END_REGION

   REGION "Attrezzaggio Pronto per il seguente Order ID"
      Attrezzamento.Ready := (((Sts.SpallaCoda.InCyclePos AND Sts.SpallaTesta.InCyclePos) AND Sts.SostegnoCoda.Ax.InCyclePos) AND Sts.SostegnoTesta.Ax.InCyclePos);
   END_REGION

   REGION "Target Posizionamento Spalle e Sostegno"
      IF BTrk.A0303.Preparation.Beam_Len > 0 THEN
          //Posiziono le spalle in base alla lunghezza dei pezzi
          Attrezzamento.TargetSpalle := (BTrk.A0303.Preparation.Beam_Len / 2.0);
          
          //Posiziono il sostegno in base alla larghezza del pezzo e il numero di pezzi per riga
          Attrezzamento.TargetSostegno := (BTrk.A0303.Preparation.Beam_H_B* BTrk.A0303.Preparation.BeamsPerLayer_Target)+Par.Antiribaltamento.Offset_Pos;
          
      ELSE
          Attrezzamento.TargetSpalle := -1;
          
          Attrezzamento.TargetSostegno := -1;
          
      END_IF;

   END_REGION

   REGION "Ciclo con pezzi corti"
      CycleWithShortPiece := ((BTrk.A0303.Stacker.Beams_Len > 0.0) AND (BTrk.A0303.Stacker.Beams_Len <= 1100.0));
   END_REGION

   REGION "Pacco Completato su preparation anche se non completo perche finiti i pezzi dello stesso Order ID"
      IF NOT BTrk.A0303.Preparation.Empty OR NOT Sys.ByPass THEN
          
         // Cerco se nelle stazioni precedenti ci sono pezzi con lo stesso Order Id  
         
          Find_O_ID(NumStazione:=STATION_A0303_PREPARATION,O_ID=>O_ID_Precedenti);
          TON_CheckCompletato_Preparation.(IN := ((O_ID_Precedenti <> BTrk.A0303.Preparation.O_ID) //AND ("Areas_ITF".Prod.A03_A04.Beams_Data.O_ACT.O_ID <> "BTrk".A0303.Preparation.O_ID)),
                                               PT := T#10s);
          
          
          IF TON_CheckCompletato_Preparation.Q THEN
              
              BTrk.A0303.Preparation.Completato := NOT PieceToCheck_Presence;
              
           END_IF;

          
       END_IF;

   END_REGION

   REGION "Pacco Completato su Stacker anche se non completo perche finiti i pezzi dello stesso Order ID"
      IF NOT BTrk.A0303.Stacker.Empty THEN
          
         // Cerco se nelle stazioni precedenti ci sono pezzi con lo stesso Order Id  
         
          Find_O_ID(NumStazione:=STATION_A0303_STACKER,O_ID=>O_ID_Precedenti);
          TON_CheckCompletato_Stacker.(IN:=((((O_ID_Precedenti <> BTrk.A0303.Stacker.O_ID)) AND (Areas_ITF.Prod.A03_A04.Beams_Data.O_ACT.O_ID <> BTrk.A0303.Stacker.O_ID )) AND BTrk.A0303.Transfert.Empty AND BTrk.A0303.Preparation.Empty),PT := T#10S);
          
          IF TON_CheckCompletato_Stacker.Q THEN
              
              BTrk.A0303.Stacker.Completato := NOT PieceToCheck_Presence;
              
           END_IF;
        
          
       END_IF;

   END_REGION

   REGION "Ax Spalla in posizione"
      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Spalle.Testa.Ax.ActualPosition,
         Target := Attrezzamento.TargetSpalle,
         PosWin := Par_Spalla_Testa.ToleranceWindow,
         Ret_Val => Sts.SpallaTesta.InCyclePos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Spalle.Coda.Ax.ActualPosition,
         Target := Attrezzamento.TargetSpalle,
         PosWin := Par_Spalla_Testa.ToleranceWindow,
         Ret_Val => Sts.SpallaCoda.InCyclePos
      );

      Sts.SpallaTesta.InCyclePos := "TolWindow"(ActPos := CIn.Spalle.Testa.Ax.ActualPosition, Target := Attrezzamento.TargetSpalle, PosWin := Par_Spalla_Testa.ToleranceWindow);
      Sts.SpallaCoda.InCyclePos := "TolWindow"(ActPos := CIn.Spalle.Coda.Ax.ActualPosition, Target := Attrezzamento.TargetSpalle, PosWin := Par_Spalla_Testa.ToleranceWindow);
   END_REGION

   REGION "Comando Posizionamento Spalle"
      //Spalla di TESTA


      IF (NOT Sts.SpallaTesta.InCyclePos  AND (Attrezzamento.TargetSpalle <> -1 )) AND Sts.SostegnoTesta.Ax.InRestPos THEN
          Ctrl.Spalle.Testa.Pos := Attrezzamento.TargetSpalle;
          Ctrl.Spalle.Testa.MoveToPos := Attrezzamento.RequestNewPosition;
      ELSE
          Ctrl.Spalle.Testa.MoveToPos := FALSE;
      END_IF;

       
      //Spalla di CODA
      //


      IF (NOT Sts.SpallaCoda.InCyclePos AND ( Attrezzamento.TargetSpalle <> -1)) AND Sts.SostegnoCoda.Ax.InRestPos THEN
          Ctrl.Spalle.Coda.Pos := Attrezzamento.TargetSpalle;
          Ctrl.Spalle.Coda.MoveToPos := Attrezzamento.RequestNewPosition;
          
      ELSE
          Ctrl.Spalle.Coda.MoveToPos := FALSE;
      END_IF;

   END_REGION

   REGION "Spalla Testa - COut Manager"
      COut.Spalla.Testa.MoveToPos := Ctrl.Spalle.Testa.MoveToPos;
      COut.Spalla.Testa.Pos := Ctrl.Spalle.Testa.Pos;
      COut.Spalla.Testa.Control_ON := NOT ((NOT (AreaInterface.Cycle) AND NOT (Sts.SemiAut.ON)));
      COut.Spalla.Testa.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Spalla.Testa.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Spalla.Testa.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Spalla Coda - COut Manager"
      COut.Spalla.Coda.MoveToPos := Ctrl.Spalle.Coda.MoveToPos;
      COut.Spalla.Coda.Pos := Ctrl.Spalle.Coda.Pos;
      COut.Spalla.Coda.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Spalla.Coda.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Spalla.Coda.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Spalla.Coda.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "OP WORK SPINTORE"
      "BTrk_Presence"(
         en := (NOT (BTrk.A0303.Preparation.Completato) AND (BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target)),
         Item := BTrk.A0303.Preparation.B
      );

      IF (NOT (BTrk.A0303.Preparation.Completato) AND (BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target)) THEN
         "BTrk_Presence"(Item := BTrk.A0303.Preparation.B);
      END_IF;
      Ctrl.Spintore.Work := (((CIn.TraslazioneStrato.SostegnoVrt.Work AND CIn.TraslazioneStrato.Manip_Pareggiatore.Rest) AND CIn.TraslazioneStrato.Manip_Sostegno.Rest) OR (CIn.TraslazioneStrato.SostegnoVrt.Work AND Sts.TraslazioneStrato.OutOfWorkspace));
   END_REGION

   REGION "OP REST SPINTORE"
      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0303.Preparation.B
      );

      "BTrk_Absence"(Item := BTrk.A0303.Preparation.B);
      Ctrl.Spintore.Rest := (NOT (CIn.Spintore.Orz.Rest) OR NOT (CIn.Spintore.Vrt.Rest));
   END_REGION

   REGION "Spintore - COut Manager"
      COut.Spintore.Rest := Ctrl.Spintore.Rest;
      COut.Spintore.Work := Ctrl.Spintore.Work;
      COut.Spintore.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Spintore.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Spintore.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Spintore.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Allarme Passaggio pezzo non rilevato da fotocellula"
      "BTrk_Presence"(
         en := COut.Spintore.Control_ON,
         Item := BTrk.A0303.Preparation.B
      );

      #TON_PassaggioPezzoAlarm(
         IN := ((CIn.Spintore.Vrt.Work AND CIn.Spintore.Orz.Work) AND CIn.TraslazioneStrato.SostegnoVrt.Work),
         PT := T#2S
      );

      IF COut.Spintore.Control_ON THEN
         "BTrk_Presence"(Item := BTrk.A0303.Preparation.B);
      END_IF;
      #TON_PassaggioPezzoAlarm.Q;
      IF #TON_PassaggioPezzoAlarm.Q THEN
         Alarm.TrkPassaggioPezzo := TRUE;
      END_IF;
   END_REGION

   REGION "Preparation Ready to Recive"
      "BTrk_Absence"(
         en := ((((CIn.Spintore.Vrt.Rest AND CIn.TraslazioneStrato.SostegnoVrt.Work) AND CIn.TraslazioneStrato.Manip_Pareggiatore.Rest) AND CIn.TraslazioneStrato.Manip_Sostegno.Rest) OR ((CIn.Spintore.Vrt.Rest AND CIn.TraslazioneStrato.SostegnoVrt.Work) AND Sts.TraslazioneStrato.OutOfWorkspace)),
         Item := BTrk.A0303.Preparation.B
      );

      IF ((((CIn.Spintore.Vrt.Rest AND CIn.TraslazioneStrato.SostegnoVrt.Work) AND CIn.TraslazioneStrato.Manip_Pareggiatore.Rest) AND CIn.TraslazioneStrato.Manip_Sostegno.Rest) OR ((CIn.Spintore.Vrt.Rest AND CIn.TraslazioneStrato.SostegnoVrt.Work) AND Sts.TraslazioneStrato.OutOfWorkspace)) THEN
         "BTrk_Absence"(Item := BTrk.A0303.Preparation.B);
      END_IF;
      COut.Manipolatore.ReadyToRecive := TRUE;
   END_REGION

   REGION "Preparation - completato"
      Sts.Preparazione.Completato := ((BTrk.A0303.Preparation.Completato AND NOT (BTrk.A0303.Preparation.Empty)) OR ((BTrk.A0303.Preparation.Beam_Qty = BTrk.A0303.Preparation.BeamsPerLayer_Target) AND (BTrk.A0303.Preparation.BeamsPerLayer_Target <> 0)));
   END_REGION

   REGION "Ax Trasporto in posizione"
      "TolWindow"(
         en := TRUE,
         ActPos := CIn.TraslazioneStrato.Ax_Coda.ActualPosition,
         Target := Par_Trasporto.PosDeposito,
         PosWin := Par_Trasporto.ToleranceWindow,
         Ret_Val => TrasportoCodaInPosDeposito
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.TraslazioneStrato.Ax_Testa.ActualPosition,
         Target := Par_Trasporto.PosDeposito,
         PosWin := Par_Trasporto.ToleranceWindow,
         Ret_Val => TrasportoTestaInPosDeposito
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.TraslazioneStrato.Ax_Coda.ActualPosition,
         Target := Par_Trasporto.PosPrelievo,
         PosWin := Par_Trasporto.ToleranceWindow,
         Ret_Val => TrasportoCodaInPosPrelievo
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.TraslazioneStrato.Ax_Testa.ActualPosition,
         Target := Par_Trasporto.PosPrelievo,
         PosWin := Par_Trasporto.ToleranceWindow,
         Ret_Val => TrasportoTestaInPosPrelievo
      );

      TrasportoCodaInPosDeposito := "TolWindow"(ActPos := CIn.TraslazioneStrato.Ax_Coda.ActualPosition, Target := Par_Trasporto.PosDeposito, PosWin := Par_Trasporto.ToleranceWindow);
      TrasportoTestaInPosDeposito := "TolWindow"(ActPos := CIn.TraslazioneStrato.Ax_Testa.ActualPosition, Target := Par_Trasporto.PosDeposito, PosWin := Par_Trasporto.ToleranceWindow);
      Sts.TraslazioneStrato.InPosDeposito := (TrasportoCodaInPosDeposito AND TrasportoTestaInPosDeposito);
      TrasportoCodaInPosPrelievo := "TolWindow"(ActPos := CIn.TraslazioneStrato.Ax_Coda.ActualPosition, Target := Par_Trasporto.PosPrelievo, PosWin := Par_Trasporto.ToleranceWindow);
      TrasportoTestaInPosPrelievo := "TolWindow"(ActPos := CIn.TraslazioneStrato.Ax_Testa.ActualPosition, Target := Par_Trasporto.PosPrelievo, PosWin := Par_Trasporto.ToleranceWindow);
      Sts.TraslazioneStrato.InPosPrelievo := (TrasportoCodaInPosPrelievo AND TrasportoTestaInPosPrelievo);
      Sts.TraslazioneStrato.OutOfWorkspace := ((CIn.TraslazioneStrato.Ax_Coda.ActualPosition >= #TrasportoOutOfWorkspace) AND (CIn.TraslazioneStrato.Ax_Testa.ActualPosition >= #TrasportoOutOfWorkspace));
   END_REGION

   REGION "Fasi trasporto"
      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      "BTrk_Absence"(
         en := Sts.Preparazione.Completato,
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      "BTrk_Presence"(
         en := TRUE,
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      "BTrk_Presence"(
         en := TRUE,
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      "BTrk_Absence"(Item := BTrk.A0303.Transfert.Layer[1]);
      Ctrl.Cycle.Trasferimento.VaiAPrelievo := ((((NOT (Sts.TraslazioneStrato.InPosPrelievo) OR NOT (CIn.TraslazioneStrato.SostegnoVrt.Work) OR NOT (CIn.TraslazioneStrato.Manip_Pareggiatore.Rest) OR NOT (CIn.TraslazioneStrato.Manip_Sostegno.Rest)) AND NOT (Ctrl.Cycle.Trasferimento.Prelievo)) AND NOT (Ctrl.Cycle.Trasferimento.VaiADeposito)) AND NOT (Ctrl.Cycle.Trasferimento.Deposito));
      IF ((((NOT (Sts.TraslazioneStrato.InPosPrelievo) OR NOT (CIn.TraslazioneStrato.SostegnoVrt.Work) OR NOT (CIn.TraslazioneStrato.Manip_Pareggiatore.Rest) OR NOT (CIn.TraslazioneStrato.Manip_Sostegno.Rest)) AND NOT (Ctrl.Cycle.Trasferimento.Prelievo)) AND NOT (Ctrl.Cycle.Trasferimento.VaiADeposito)) AND NOT (Ctrl.Cycle.Trasferimento.Deposito)) THEN
         A04_HMI.Synoptic.Trasporto.Fase := 1;
      END_IF;
      Ctrl.Cycle.Trasferimento.Prelievo := ((((((Sts.TraslazioneStrato.InPosPrelievo AND NOT (CIn.TraslazioneStrato.Manip_Pareggiatore.Work)) OR (Sts.TraslazioneStrato.InPosPrelievo AND NOT (CIn.TraslazioneStrato.Manip_Sostegno.Work)) OR (Sts.TraslazioneStrato.InPosPrelievo AND NOT (CIn.TraslazioneStrato.SostegnoVrt.Rest))) AND NOT (Ctrl.Cycle.Trasferimento.VaiAPrelievo)) AND NOT (Ctrl.Cycle.Trasferimento.VaiADeposito)) AND NOT (Ctrl.Cycle.Trasferimento.Deposito)) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target));
      "BTrk_Presence"(Item := BTrk.A0303.Transfert.Layer[1]);
      Ctrl.Cycle.Trasferimento.VaiADeposito := ((((NOT (Sts.TraslazioneStrato.InPosDeposito) AND NOT (Ctrl.Cycle.Trasferimento.VaiAPrelievo)) AND NOT (Ctrl.Cycle.Trasferimento.Prelievo)) AND NOT (Ctrl.Cycle.Trasferimento.Deposito)) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target));
      Ctrl.Cycle.Trasferimento.Deposito := ((((Sts.TraslazioneStrato.InPosDeposito AND Sts.Sollevatore.ReadyToRecive) AND NOT (Ctrl.Cycle.Trasferimento.VaiAPrelievo)) AND NOT (Ctrl.Cycle.Trasferimento.Prelievo)) AND NOT (Ctrl.Cycle.Trasferimento.VaiADeposito));
   END_REGION

   REGION "Trasporto Ready To Drop"
      "BTrk_Presence"(
         en := (TrasportoCodaInPosDeposito AND TrasportoTestaInPosDeposito),
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      IF (TrasportoCodaInPosDeposito AND TrasportoTestaInPosDeposito) THEN
         "BTrk_Presence"(Item := BTrk.A0303.Transfert.Layer[1]);
      END_IF;
      Sts.TraslazioneStrato.DropRequest := TRUE;
   END_REGION

   REGION "Trasporto - COut Manager"
      COut.Trasporto.OP.VAI_A_PRELIEVO := Ctrl.Cycle.Trasferimento.VaiAPrelievo;
      COut.Trasporto.OP.PRELIEVO := Ctrl.Cycle.Trasferimento.Prelievo;
      COut.Trasporto.OP.VAI_A_DEPOSITO := Ctrl.Cycle.Trasferimento.VaiADeposito;
      COut.Trasporto.OP.DEPOSITO := Ctrl.Cycle.Trasferimento.Deposito;
      COut.Trasporto.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Trasporto.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Trasporto.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Trasporto.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Allarme Pezzi oltre il limite consentito"
      IF ((Sts.TraslazioneStrato.InPosPrelievo AND DataIn.LsPezzoPosMax_Coda) OR (Sts.TraslazioneStrato.InPosPrelievo AND DataIn.LsPezzoPosMax_Testa)) THEN
         Alarm.PaccoOltreLimiteMax := TRUE;
      END_IF;
   END_REGION

   REGION "Warning Mancanza Condizioni Trasporto"
      "BTrk_Presence"(
         en := TRUE,
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      "BTrk_Presence"(Item := BTrk.A0303.Transfert.Layer[1]);
      Warning.MissingCnd.SollevatoreNotReadyToRecive := ((NOT (Ctrl.Cycle.Trasferimento.Deposito) AND NOT (Ctrl.Cycle.Trasferimento.VaiADeposito)) AND NOT (Sts.Sollevatore.ReadyToRecive));
   END_REGION

   REGION "Calcolo Target di posizionamento"
      // Finche non c'è la richiesta di scaricare il pezzo il sollevatore si porta un po piu basso ad una quota di pre prelievo, quando poi c'è la richiesta di scaricare il pezzo si alza di un offset

      "Sollevatore_NextPos"(
         en := TRUE,
         Beams_W_A := BTrk.A0303.Stacker.Beams_W_A,
         Layers_Qty := BTrk.A0303.Stacker.Layers_Qty,
         OffsetPrelievo := Par_Sollevatore.OffsetPrelievo,
         Position => TargetPrePositionSollevatore
      );

      "Sollevatore_NextPos"(Beams_W_A := BTrk.A0303.Stacker.Beams_W_A, Layers_Qty := BTrk.A0303.Stacker.Layers_Qty, OffsetPrelievo := Par_Sollevatore.OffsetPrelievo);
      TargetPositionSollevatore_Temp := (BTrk.A0303.Stacker.Layers_Qty * BTrk.A0303.Stacker.Beams_W_A);
      TargetPositionSollevatore := (TargetPositionSollevatore_Temp + 18.0);
   END_REGION

   REGION "Ax  position window"
      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition,
         Target := TargetPositionSollevatore,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreCodaInPrelievoPos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition,
         Target := TargetPositionSollevatore,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreTestaInPrelievoPos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition,
         Target := TargetPrePositionSollevatore,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreCodaInPrePrelievoPos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition,
         Target := TargetPrePositionSollevatore,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreTestaInPrePrelievoPos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition,
         Target := A0303_Sollevamento_PERS.Par_Mach.PosDeposito,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreCodaInPosDeposito
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition,
         Target := A0303_Sollevamento_PERS.Par_Mach.PosDeposito,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreTestaInPosDeposito
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition,
         Target := TargetPreDepositoSollevatore,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreCodaInPosPreDeposito
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition,
         Target := TargetPreDepositoSollevatore,
         PosWin := Par_Sollevatore.ToleranceWindow,
         Ret_Val => SollevatoreTestaInPosPreDeposito
      );

      SollevatoreCodaInPrelievoPos := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition, Target := TargetPositionSollevatore, PosWin := Par_Sollevatore.ToleranceWindow);
      SollevatoreTestaInPrelievoPos := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition, Target := TargetPositionSollevatore, PosWin := Par_Sollevatore.ToleranceWindow);
      SollevatoreCodaInPrePrelievoPos := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition, Target := TargetPrePositionSollevatore, PosWin := Par_Sollevatore.ToleranceWindow);
      SollevatoreTestaInPrePrelievoPos := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition, Target := TargetPrePositionSollevatore, PosWin := Par_Sollevatore.ToleranceWindow);
      SollevatoreCodaInPosDeposito := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition, Target := A0303_Sollevamento_PERS.Par_Mach.PosDeposito, PosWin := Par_Sollevatore.ToleranceWindow);
      SollevatoreTestaInPosDeposito := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition, Target := A0303_Sollevamento_PERS.Par_Mach.PosDeposito, PosWin := Par_Sollevatore.ToleranceWindow);
      TargetPreDepositoSollevatore := (A0303_Sollevamento_PERS.Par_Mach.PosDeposito - 10.0);
      SollevatoreCodaInPosPreDeposito := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Coda.ActualPosition, Target := TargetPreDepositoSollevatore, PosWin := Par_Sollevatore.ToleranceWindow);
      SollevatoreTestaInPosPreDeposito := "TolWindow"(ActPos := CIn.Sollevamento.Ax_Testa.ActualPosition, Target := TargetPreDepositoSollevatore, PosWin := Par_Sollevatore.ToleranceWindow);
      Sts.Sollevatore.InPrelievoPos := (SollevatoreCodaInPrelievoPos AND SollevatoreTestaInPrelievoPos);
      Sts.Sollevatore.InPrePrelievoPos := (SollevatoreCodaInPrePrelievoPos AND SollevatoreTestaInPrePrelievoPos);
      Sts.Sollevatore.InPosDeposito := (SollevatoreCodaInPosDeposito AND SollevatoreTestaInPosDeposito);
      Sts.Sollevatore.InPosPreDeposito := (SollevatoreCodaInPosPreDeposito AND SollevatoreTestaInPosPreDeposito);
   END_REGION

   REGION "Fasi Sollevatore"
      // Fasi Sollevatore : Il sollevatore si deve portare in posizione di preprelievo e quando il traslatore è in posizione di deposito e pronto a depositare allora posso salire e  prelevare il pezzo
// Quando raggiungo il numero max di layer passo alla fase di deposito

      Ctrl.Cycle.Sollevamento.Prelievo := (((((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND BTrk.A0304.Empty) OR ((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND NOT (BTrk.A0304.Empty)) AND CIn.Navetta.OutOfWorkspace)) AND BTrk.A0303.Transfert.Empty) AND (CIn.TraslazioneStrato.Ax_Testa.ActualPosition < -700.0)) OR (((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND BTrk.A0304.Empty) OR ((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND NOT (BTrk.A0304.Empty)) AND CIn.Navetta.OutOfWorkspace)) AND NOT (BTrk.A0303.Transfert.Empty)));
      IF (((((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND BTrk.A0304.Empty) OR ((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND NOT (BTrk.A0304.Empty)) AND CIn.Navetta.OutOfWorkspace)) AND BTrk.A0303.Transfert.Empty) AND (CIn.TraslazioneStrato.Ax_Testa.ActualPosition < -700.0)) OR (((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND BTrk.A0304.Empty) OR ((((((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND NOT (Sts.Sollevatore.InPrePrelievoPos)) OR ((((BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target) AND NOT (BTrk.A0303.Stacker.Completato)) AND Sts.TraslazioneStrato.DropRequest) AND NOT (Sts.Sollevatore.InPrelievoPos))) AND NOT (Ctrl.Cycle.Sollevamento.Deposito)) AND NOT (BTrk.A0304.Empty)) AND CIn.Navetta.OutOfWorkspace)) AND NOT (BTrk.A0303.Transfert.Empty))) THEN
         A04_HMI.Synoptic.Impilatore.Fase := 1;
      END_IF;
      Ctrl.Cycle.Sollevamento.Deposito := ((((CIn.Navetta.InPosizioneDiPrelievo AND (BTrk.A0303.Stacker.Layers_Qty >= BTrk.A0303.Stacker.Layers_Target)) OR (CIn.Navetta.InPosizioneDiPrelievo AND BTrk.A0303.Stacker.Completato)) AND (BTrk.A0303.Stacker.Layers_Target > 0)) AND NOT (Sts.Sollevatore.InPosDeposito));
      Ctrl.Cycle.Sollevamento.PreDeposito := (((((BTrk.A0303.Stacker.Layers_Qty >= BTrk.A0303.Stacker.Layers_Target) OR BTrk.A0303.Stacker.Completato) AND (BTrk.A0303.Stacker.Layers_Target > 0)) AND NOT (Sts.Sollevatore.InPosPreDeposito)) AND NOT (CIn.Navetta.InPosizioneDiPrelievo));
   END_REGION

   REGION "Sollevatore Ready To Recive"
      Sts.Sollevatore.ReadyToRecive := (((((CIn.Sollevamento.Ax_Coda.Standstill AND CIn.Sollevamento.Ax_Testa.Standstill) AND SollevatoreCodaInPrelievoPos) AND SollevatoreTestaInPrelievoPos) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato));
   END_REGION

   REGION "Sollevatore - COut Manager"
      COut.Sollevatore.OP.PRELIEVO := Ctrl.Cycle.Sollevamento.Prelievo;
      COut.Sollevatore.OP.DEPOSITO := Ctrl.Cycle.Sollevamento.Deposito;
      COut.Sollevatore.OP.PRE_DEPOSITO := Ctrl.Cycle.Sollevamento.PreDeposito;
      IF (((BTrk.A0303.Preparation.Beam_W_A <> -1.0) AND NOT (Sts.TraslazioneStrato.DropRequest)) AND (BTrk.A0303.Stacker.Layers_Qty <= BTrk.A0303.Stacker.Layers_Target)) THEN
         COut.Sollevatore.TargetPosition := TargetPrePositionSollevatore;
      END_IF;
      COut.Sollevatore.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Sollevatore.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Sollevatore.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Sollevatore.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Warning Mancanza Condizioni Trasporto"
      "BTrk_Presence"(
         en := TRUE,
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      "BTrk_Presence"(Item := BTrk.A0303.Transfert.Layer[1]);
      Warning.MissingCnd.SollevatoreNotReadyToRecive := ((NOT (Ctrl.Cycle.Trasferimento.Deposito) AND NOT (Ctrl.Cycle.Trasferimento.VaiADeposito)) AND NOT (Sts.Sollevatore.ReadyToRecive));
   END_REGION

   REGION "Ax Sostegno in posizione"
      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sostegno.Testa.Ax.ActualPosition,
         Target := Attrezzamento.TargetSostegno,
         PosWin := Par_SostegnoAntirib.ToleranceWindow,
         Ret_Val => Sts.SostegnoTesta.Ax.InCyclePos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sostegno.Testa.Ax.ActualPosition,
         Target := Par_SostegnoAntirib.RestPosition,
         PosWin := Par_SostegnoAntirib.ToleranceWindow,
         Ret_Val => Sts.SostegnoTesta.Ax.InRestPos
      );

      Sts.SostegnoTesta.Ax.InCyclePos := "TolWindow"(ActPos := CIn.Sostegno.Testa.Ax.ActualPosition, Target := Attrezzamento.TargetSostegno, PosWin := Par_SostegnoAntirib.ToleranceWindow);
      Sts.SostegnoTesta.Ax.InRestPos := "TolWindow"(ActPos := CIn.Sostegno.Testa.Ax.ActualPosition, Target := Par_SostegnoAntirib.RestPosition, PosWin := Par_SostegnoAntirib.ToleranceWindow);
   END_REGION

   REGION "Posizione PALETTI Antiribaltamento"
      "Pos_Antirib"(
         en := TRUE,
         PosSpalla := CIn.Spalle.Testa.Ax.ActualPosition,
         PosPaletto => Ctrl.Cycle.SostegnoAntirib_Testa.PalettoPos,
         Pos1Collisione => COut.Sostegno.Testa.Paletti.Pos1Collision,
         Pos2Collisione => COut.Sostegno.Testa.Paletti.Pos2Collision
      );

      "Pos_Antirib"(PosSpalla := CIn.Spalle.Testa.Ax.ActualPosition);
      Sts.SostegnoTesta.Paletto.InCyclePos := (Ctrl.Cycle.SostegnoAntirib_Testa.PalettoPos = CIn.Sostegno.Testa.Paletto.Pos);
   END_REGION

   REGION "Fasi sostegno antiribaltamento"
      Ctrl.Cycle.SostegnoAntirib_Testa.VaiALavoro := (((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND NOT (Sts.SostegnoTesta.Ax.InCyclePos)) OR ((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND (Ctrl.Cycle.SostegnoAntirib_Testa.PalettoPos <> CIn.Sostegno.Testa.Paletto.Pos)));
      IF (((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND NOT (Sts.SostegnoTesta.Ax.InCyclePos)) OR ((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND (Ctrl.Cycle.SostegnoAntirib_Testa.PalettoPos <> CIn.Sostegno.Testa.Paletto.Pos))) THEN
         A04_HMI.Synoptic.Antiribaltamento.Testa.Fase := 2;
      END_IF;
      Ctrl.Cycle.SostegnoAntirib_Testa.VaiARiposo := (((((((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND NOT (CycleWithShortPiece)) AND Sts.Sollevatore.InPosDeposito) OR (((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND CycleWithShortPiece) AND Sts.Sollevatore.InPosPreDeposito) OR NOT (Sts.SpallaTesta.InCyclePos)) AND NOT (Sts.SostegnoTesta.Ax.InRestPos)) OR (((((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND NOT (CycleWithShortPiece)) AND Sts.Sollevatore.InPosDeposito) OR (((((Sts.SpallaTesta.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaTesta.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND CycleWithShortPiece) AND Sts.Sollevatore.InPosPreDeposito) OR NOT (Sts.SpallaTesta.InCyclePos)) AND (Ctrl.Cycle.SostegnoAntirib_Testa.PalettoPos <> 0))) AND NOT (Ctrl.Cycle.SostegnoAntirib_Testa.VaiALavoro));
   END_REGION

   REGION "Sostegno Testa - COut Manager"
      COut.Sostegno.Testa.Phase.VAI_A_LAVORO := Ctrl.Cycle.SostegnoAntirib_Testa.VaiALavoro;
      COut.Sostegno.Testa.Phase.VAI_A_RIPOSO := Ctrl.Cycle.SostegnoAntirib_Testa.VaiARiposo;
      COut.Sostegno.Testa.Ax.Pos := Ctrl.Cycle.SostegnoAntirib_Testa.CyclePos;
      COut.Sostegno.Testa.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Sostegno.Testa.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Sostegno.Testa.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Sostegno.Testa.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Ax Sostegno in posizione"
      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sostegno.Coda.Ax.ActualPosition,
         Target := Attrezzamento.TargetSostegno,
         PosWin := Par_SostegnoAntirib.ToleranceWindow,
         Ret_Val => Sts.SostegnoCoda.Ax.InCyclePos
      );

      "TolWindow"(
         en := TRUE,
         ActPos := CIn.Sostegno.Coda.Ax.ActualPosition,
         Target := Par_SostegnoAntirib.RestPosition,
         PosWin := Par_SostegnoAntirib.ToleranceWindow,
         Ret_Val => Sts.SostegnoCoda.Ax.InRestPos
      );

      Sts.SostegnoCoda.Ax.InCyclePos := "TolWindow"(ActPos := CIn.Sostegno.Coda.Ax.ActualPosition, Target := Attrezzamento.TargetSostegno, PosWin := Par_SostegnoAntirib.ToleranceWindow);
      Sts.SostegnoCoda.Ax.InRestPos := "TolWindow"(ActPos := CIn.Sostegno.Coda.Ax.ActualPosition, Target := Par_SostegnoAntirib.RestPosition, PosWin := Par_SostegnoAntirib.ToleranceWindow);
   END_REGION

   REGION "Posizione PALETTI Antiribaltamento"
      "Pos_Antirib"(
         en := TRUE,
         PosSpalla := CIn.Spalle.Coda.Ax.ActualPosition,
         PosPaletto => Ctrl.Cycle.SostegnoAntirib_Coda.PalettoPos,
         Pos1Collisione => COut.Sostegno.Coda.Paletti.Pos1Collision,
         Pos2Collisione => COut.Sostegno.Coda.Paletti.Pos2Collision
      );

      "Pos_Antirib"(PosSpalla := CIn.Spalle.Coda.Ax.ActualPosition);
      Sts.SostegnoCoda.Paletto.InCyclePos := (Ctrl.Cycle.SostegnoAntirib_Coda.PalettoPos = CIn.Sostegno.Coda.Paletto.Pos);
   END_REGION

   REGION "Fasi sostegno antiribaltamento"
      Ctrl.Cycle.SostegnoAntirib_Coda.VaiALavoro := ((((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND NOT (Sts.SostegnoCoda.Ax.InCyclePos)) OR ((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND (Ctrl.Cycle.SostegnoAntirib_Coda.PalettoPos <> CIn.Sostegno.Testa.Paletto.Pos))) AND NOT (Ctrl.Cycle.SostegnoAntirib_Coda.VaiARiposo));
      IF ((((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND NOT (Sts.SostegnoCoda.Ax.InCyclePos)) OR ((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND NOT (CIn.Navetta.RequestDeposito)) OR (((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target)) AND NOT (BTrk.A0303.Stacker.Completato))) AND (Ctrl.Cycle.SostegnoAntirib_Coda.PalettoPos <> CIn.Sostegno.Testa.Paletto.Pos))) AND NOT (Ctrl.Cycle.SostegnoAntirib_Coda.VaiARiposo)) THEN
         A04_HMI.Synoptic.Antiribaltamento.Coda.Fase := 2;
      END_IF;
      Ctrl.Cycle.SostegnoAntirib_Coda.VaiARiposo := (((((((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND NOT (CycleWithShortPiece)) AND Sts.Sollevatore.InPosDeposito) OR (((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND CycleWithShortPiece) AND Sts.Sollevatore.InPosPreDeposito) OR NOT (Sts.SpallaCoda.InCyclePos)) AND NOT (Sts.SostegnoCoda.Ax.InRestPos)) OR (((((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND NOT (CycleWithShortPiece)) AND Sts.Sollevatore.InPosDeposito) OR (((((Sts.SpallaCoda.InCyclePos AND NOT (CycleWithShortPiece)) AND CIn.Navetta.RequestDeposito) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND (BTrk.A0303.Stacker.Layers_Qty = BTrk.A0303.Stacker.Layers_Target)) OR ((Sts.SpallaCoda.InCyclePos AND CycleWithShortPiece) AND BTrk.A0303.Stacker.Completato)) AND CycleWithShortPiece) AND Sts.Sollevatore.InPosPreDeposito) OR NOT (Sts.SpallaCoda.InCyclePos)) AND (Ctrl.Cycle.SostegnoAntirib_Coda.PalettoPos <> 0))) AND NOT (Ctrl.Cycle.SostegnoAntirib_Coda.VaiALavoro));
   END_REGION

   REGION "Sostegno Coda - COut Manager"
      COut.Sostegno.Coda.Phase.VAI_A_LAVORO := Ctrl.Cycle.SostegnoAntirib_Coda.VaiALavoro;
      COut.Sostegno.Coda.Phase.VAI_A_RIPOSO := Ctrl.Cycle.SostegnoAntirib_Coda.VaiARiposo;
      COut.Sostegno.Coda.Ax.Pos := Ctrl.Cycle.SostegnoAntirib_Coda.CyclePos;
      COut.Sostegno.Coda.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Sostegno.Coda.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Sostegno.Coda.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Sostegno.Coda.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Richiesta Movimento da B a Layer 1"
      "BTrk_Presence"(
         en := TRUE,
         Item := BTrk.A0303.Preparation.B
      );

      "BTrk_Presence"(
         en := TRUE,
         Item := BTrk.A0303.Preparation.B
      );

      "BTrk_Presence"(
         en := ((((((CIn.Spintore.Vrt.Work AND CIn.Spintore.Orz.Work) AND CIn.TraslazioneStrato.SostegnoVrt.Work) AND PE_Engaged_Coda) AND NE_Engaged_Coda) AND PE_Engaged_Testa) AND NE_Engaged_Testa),
         Item := BTrk.A0303.Preparation.B
      );

      "BTrk_Presence"(Item := BTrk.A0303.Preparation.B);
      IF ((BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target) AND PE.LsPosition1_Coda) THEN
         PE_Engaged_Coda := TRUE;
      END_IF;
      IF ((BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target) AND PE.LsPosition1_Testa) THEN
         PE_Engaged_Testa := TRUE;
      END_IF;
      IF ((BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target) AND NE.LsPosition1_Coda) THEN
         NE_Engaged_Coda := TRUE;
      END_IF;
      IF ((BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target) AND NE.LsPosition1_Testa) THEN
         NE_Engaged_Testa := TRUE;
      END_IF;
      Ctrl.BTrk.B3ToLayer1 := TRUE;
   END_REGION

   REGION "Movimento BTRK da B0 == a ==> Layer 1 + shift a destra dei layer"
      IF BTrk.A0303.Preparation.BeamsPerLayer_Target <> 0 THEN
          
          IF Ctrl.BTrk.B3ToLayer1 THEN
              
              IF BTrk.A0303.Preparation.Beam_Qty < BTrk.A0303.Preparation.BeamsPerLayer_Target THEN
                  
                  //Controllo che non sia gia pieno altrimenti allarme
                  //
                  IF BTrk.A0303.Preparation.Beam_Qty > 0 THEN
                      // Cerco se ci sono degli spazi vuoti dovuti da un delete del trk manuale
                      // 
                      FOR i := 1 TO BTrk.A0303.Preparation.Beam_Qty  DO
                          IF BTrk.A0303.Preparation.Layer[i].B_ID = 0 THEN
                              EmptyNFound := i;
                              EXIT;
                          END_IF;
                          EmptyNFound := 0;

                      END_FOR;
                  END_IF;
                  IF EmptyNFound > 0 THEN
                      ShiftN := EmptyNFound;
                  ELSE
                      ShiftN := BTrk.A0303.Preparation.BeamsPerLayer_Target;
                  END_IF;
                  
                  
                  ShiftArrayOk := (
                                              SRC := BTrk.A0303.Preparation.Layer,
                                              COUNT := ShiftN - 1,// numero di elementi da spostare
                                              SRC_INDEX := 0,
                                              DEST_INDEX := 1,
                                              DEST => BTrk.A0303.Preparation.Layer);
                  
                  
                  
                  // Inserimento nuovo valore nel primo layer
                  BTrk.A0303.Preparation.Layer[1] := BTrk.A0303.Preparation.B;
                  
                  // Svuotamento B2
                  BTrk.A0303.Preparation.B := BTrk.Empty;
                  
              ELSE
                  Alarm.TrkPreparationAlreadyFull := TRUE;
                  
              END_IF;
              PE_Engaged_Coda := FALSE;
              NE_Engaged_Coda := FALSE;
              PE_Engaged_Testa := FALSE;
              NE_Engaged_Testa := FALSE;


          END_IF;
      END_IF;

   END_REGION

   REGION "Pacco Preparation completato / vuoto / conteggio pezzi"
      // Conteggio Pezzi
      ConteggioPezzi_Preparation := 0;
      FOR i := 1 TO BTrk.A0303.Preparation.BeamsPerLayer_Target DO
          IF BTrk.A0303.Preparation.Layer[i].B_ID > 0 THEN
              ConteggioPezzi_Preparation += 1;
          END_IF;
      END_FOR;

      BTrk.A0303.Preparation.Beam_Qty := ConteggioPezzi_Preparation;

      // pallet empty/full
      BTrk.A0303.Preparation.Empty := ConteggioPezzi_Preparation = 0;

      IF BTrk.A0303.Preparation.Empty THEN
          BTrk.A0303.Preparation.Completato := FALSE;
      END_IF;

   END_REGION

   REGION "Tracking from Preparation to Transfer"
      IF PE.TrkToTransfer THEN
         BTrk.A0303.Transfert.Layer := BTrk.A0303.Preparation.Layer;
      END_IF;
   END_REGION

   REGION "Transfert vuoto / conteggio pezzi"
      // Conteggio Pezzi
      ConteggioPezzi_Transfert := 0;
      FOR i := 1 TO BTrk.A0303.Transfert.BeamsPerLayer_Target DO
          IF  BTrk.A0303.Transfert.Layer[i].B_ID> 0 THEN
              ConteggioPezzi_Transfert += 1;
          END_IF;
      END_FOR;

      BTrk.A0303.Transfert.Beams_Qty:= ConteggioPezzi_Transfert;

      // pallet empty/full
      BTrk.A0303.Transfert.Empty := ConteggioPezzi_Transfert = 0;


   END_REGION

   REGION "Request Tracking from  Transfer to Stacker"
      "BTrk_Presence"(
         en := NOT (BTrk.A0303.Transfert.Empty),
         Item := BTrk.A0303.Transfert.Layer[1]
      );

      IF NOT (BTrk.A0303.Transfert.Empty) THEN
         "BTrk_Presence"(Item := BTrk.A0303.Transfert.Layer[1]);
      END_IF;
      Ctrl.BTrk.TransferToStacker := ((((TrasportoTestaInPosDeposito AND TrasportoCodaInPosDeposito) AND CIn.TraslazioneStrato.Manip_Pareggiatore.Rest) AND CIn.TraslazioneStrato.Manip_Sostegno.Rest) AND Sts.Sollevatore.ReadyToRecive);
   END_REGION

   REGION "Pacco Stacker completato / vuoto / conteggio pezzi"
      // Conteggio Pezzi
      ConteggioPezzi_Stacker := 0;
      FOR i := 1 TO BTrk.A0303.Stacker.Layers_Target DO
          IF  BTrk.A0303.Stacker.Layers[i].Layer[1].B_ID> 0 THEN
              ConteggioPezzi_Stacker += 1;
          END_IF;
      END_FOR;

      BTrk.A0303.Stacker.Layers_Qty:= ConteggioPezzi_Stacker;

      // pallet empty/full
      BTrk.A0303.Stacker.Empty := ConteggioPezzi_Stacker = 0;

      IF BTrk.A0303.Stacker.Empty THEN
          BTrk.A0303.Stacker.Completato := FALSE;
      END_IF;
          


   END_REGION

   REGION "Tracking from Transfer to Stacker"
      // Metto sempre l'ultimo strato depositato nel Layer 1 e shifto a destra gli altri elementi

      IF Ctrl.BTrk.TransferToStacker THEN
          
          IF BTrk.A0303.Stacker.Layers_Qty < BTrk.A0303.Stacker.Layers_Target THEN  //Controllo che non sia gia pieno altrimenti allarme
              
              FOR i := BTRK_LAYER_ITEMS - 1 TO 1 BY -1 DO
                  ShiftArrayOk := (
                                                    SRC := BTrk.A0303.Stacker.Layers[i].Layer,
                                                    COUNT := 12,
                                                    SRC_INDEX := 0,
                                                    DEST_INDEX := 0,
                                                    DEST => BTrk.A0303.Stacker.Layers[i + 1].Layer);
              END_FOR;
              
              // Copia nuovo layer in Layers[1]
              // 
              IF ShiftArrayOk = 0 THEN
                  TrkToStackerOk := (
                                                      SRC := BTrk.A0303.Transfert.Layer,
                                                      COUNT := 12,
                                                      SRC_INDEX := 0,
                                                      DEST_INDEX := 0,
                                                      DEST => BTrk.A0303.Stacker.Layers[1].Layer);
                  
                  IF TrkToStackerOk = 0 THEN
                      BTrk.A0303.Transfert.Layer := BTrk.EmptyLayer;
                  END_IF;
                  
              END_IF;
              
          ELSE
              Alarm.TrkStackerAlreadyFull := TRUE;
          END_IF;
      END_IF;

   END_REGION

   REGION "Tracking from  Stacker to Shuttle"
      IF PE.TrkToShuttle THEN
         BTrk.A0304.Layers := BTrk.A0303.Stacker.Layers;
      END_IF;
   END_REGION

   REGION "<<< OP CAN MOVE FREELY >>>"
      "BTrk_Absence"(
         en := TRUE,
         Item := BTrk.A0303.Preparation.B
      );

      "BTrk_Absence"(Item := BTrk.A0303.Preparation.B);
      COut.Spintore.CanMoveFreely := TRUE;
      COut.Trasporto.CanMoveFreely := (BTrk.A0303.Transfert.Empty OR NOT (Sys.ByPass));
      COut.Sollevatore.CanMoveFreely := (BTrk.A0303.Stacker.Empty OR NOT (Sys.ByPass));
      COut.Sostegno.Testa.CanMoveFreely := (BTrk.A0303.Stacker.Empty OR NOT (Sys.ByPass));
      COut.Sostegno.Coda.CanMoveFreely := (BTrk.A0303.Stacker.Empty OR NOT (Sys.ByPass));
   END_REGION

   REGION "Stop Cycle"
      #TON_Stop(
         IN := ((AreaInterface.StopProgrammed OR CIn.ProdManager.STOP_FineTurno OR CIn.ProdManager.STOP_ControlloQualita OR AreaInterface.StopInPhase) AND Sts.IsStandstill),
         PT := T#1s
      );

      #TON_StopPerInattivita(
         IN := Warning.IsWaiting_NoPiecesBefore,
         PT := T#1M
      );

      #TON_Stop.Q;
      Ctrl.Stop := #TON_Stop.Q;
      IF ((#TON_Stop.Q AND CIn.ProdManager.STOP_FineTurno) AND AreaInterface.Cycle) THEN
         Alarm.STOP_FineTurno := TRUE;
      END_IF;
      Warning.STOP_FineTurno := ((#TON_Stop.Q AND CIn.ProdManager.STOP_FineTurno) AND NOT (AreaInterface.Cycle));
      IF ((#TON_Stop.Q AND CIn.ProdManager.STOP_ControlloQualita) AND AreaInterface.Cycle) THEN
         Alarm.STOP_ControlloQualita := TRUE;
      END_IF;
      Warning.STOP_ControlloQualita := ((#TON_Stop.Q AND CIn.ProdManager.STOP_ControlloQualita) AND NOT (AreaInterface.Cycle));
      IF (Warning.IsWaiting_NoPiecesBefore AND CIn.ProdManager.STOP_End_Of_Production) THEN
         Alarm.STOP_End_Of_Proroduction := TRUE;
      END_IF;
      #TON_StopPerInattivita.Q;
      IF #TON_StopPerInattivita.Q THEN
         Alarm.STOP_Inattività := TRUE;
      END_IF;
   END_REGION

   REGION "SYNOPTIC"
   END_REGION

   REGION "All motions standstill"
      Sts.IsStandstill := ((((((((((((CIn.Spalle.Coda.Ax.Standstill AND CIn.Spalle.Testa.Ax.Standstill) AND CIn.TraslazioneStrato.Ax_Coda.Standstill) AND CIn.TraslazioneStrato.Ax_Testa.Standstill) AND CIn.Sollevamento.Ax_Coda.Standstill) AND CIn.Sollevamento.Ax_Testa.Standstill) AND CIn.Sostegno.Coda.Ax.Standstill) AND CIn.Sostegno.Testa.Ax.Standstill) AND CIn.TraslazioneStrato.Manip_Pareggiatore.Standstill) AND CIn.TraslazioneStrato.Manip_Sostegno.Standstill) AND CIn.TraslazioneStrato.SostegnoVrt.Standstill) AND CIn.Sostegno.Coda.Paletto.Standstill) AND CIn.Sostegno.Testa.Paletto.Standstill);
   END_REGION

   REGION "Alarms presence"
      Sts.AlarmsPresence := NOT (((((((NOT (Alarm.TrkPassaggioPezzo) AND NOT (Alarm.TrkPreparationAlreadyFull)) AND NOT (Alarm.TrkPreparationAlreadyFull)) AND NOT (Alarm.PaccoOltreLimiteMax)) AND NOT (Alarm.STOP_End_Of_Proroduction)) AND NOT (Alarm.STOP_ControlloQualita)) AND NOT (Alarm.STOP_FineTurno)));
   END_REGION

   REGION "Warnings presence"
      Sts.WarningsPresence := NOT (((((((NOT (Warning.IsWaiting_NoPiecesBefore) AND NOT (Warning.IsWaiting_ShuttleUnload)) AND NOT (Warning.MissingCnd.SollevatoreNotReadyToRecive)) AND NOT (Warning.IsWaiting_PezziDaRintegrare)) AND NOT (Warning.STOP_ControlloQualita)) AND NOT (Warning.STOP_End_Of_Proroduction)) AND NOT (Warning.STOP_FineTurno)));
   END_REGION

   REGION "Collect machine to area interface"
      MachineInterface.AlarmsPresence := Sts.AlarmsPresence;

      MachineInterface.WarningPresence := Sts.WarningsPresence;

      MachineInterface.MotionsStandStill := Sts.IsStandstill;

      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmsPresence;


      MachineInterface.AckStopInPhase := AreaInterface.StopInPhase AND Ctrl.Stop;

      MachineInterface.AckStopProgrammed := AreaInterface.StopProgrammed AND Ctrl.Stop;


      MachineInterface.Aborting := AreaInterface.Aut AND Sts.AlarmsPresence;


   END_REGION


END_FUNCTION_BLOCK
