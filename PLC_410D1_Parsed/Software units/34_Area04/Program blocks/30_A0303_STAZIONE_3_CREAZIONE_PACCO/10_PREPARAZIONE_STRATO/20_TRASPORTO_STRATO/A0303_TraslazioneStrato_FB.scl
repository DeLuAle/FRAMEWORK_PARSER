// Block: A0303_TraslazioneStrato_FB
// Title: Reset allarmi 

FUNCTION_BLOCK "A0303_TraslazioneStrato_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Reset allarmi 
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI_Feed_Testa : udt_DeviceSafetyInterface;
      DSI_Feed_Coda : udt_DeviceSafetyInterface;
      DSI_Valve : udt_DeviceSafetyInterface;
      DataIn : Struct
         OP_Vai_A_Prelievo : Bool;
         OP_Prelievo : Bool;
         OP_Vai_A_Deposito : Bool;
         OP_Deposito : Bool;
         LsSensor1 : Bool;
         LsSensor2 : Bool;
         StratoDepositato_Testa_AnalSens : Int;
         StratoDepositato_Coda_AnalSens : Int;
      END_STRUCT;
      CIn : Struct
         SemiAut_Pb : Bool;
         Manager : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            CanMoveFreely : Bool;
            OP : Struct
               VAI_A_PRELIEVO : Bool;
               PRELIEVO : Bool;
               VAI_A_DEPOSITO : Bool;
               DEPOSITO : Bool;
            END_STRUCT;
         END_STRUCT;
         Sollevatore : Struct
            OutOfWorkspace : Bool;
            ActualPos_Testa : LReal;
            ActualPos_Coda : LReal;
         END_STRUCT;
         Antiribaltamento : Struct
            InRestPos : Bool;
            InPos0 : Bool;
         END_STRUCT;
      END_STRUCT;
      Config : Struct
         Testa : Struct
            Ax : Positioning_EPOS_Machine_Config_NEW;
            Manip_Sostegno : ValveMachine_Config;
            Manip_Pareggiatore : ValveMachine_Config;
            SostegnoVrt : ValveMachine_Config;
         END_STRUCT;
         Coda : Struct
            Ax : Positioning_EPOS_Machine_Config_NEW;
            Manip_Sostegno : ValveMachine_Config;
            Manip_Pareggiatore : ValveMachine_Config;
            SostegnoVrt : ValveMachine_Config;
            DelayMissingCondition : Time;
         END_STRUCT;
         DelayMissingCondition : Time;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      COut : Struct
         Testa : Struct
            Ax : Positioning_EPOS_Machine_COut;
            Manip_Sostegno : ValveMachine_COut;
            Manip_Pareggiatore : ValveMachine_COut;
            SostegnoVrt : ValveMachine_COut;
         END_STRUCT;
         Coda : Struct
            Ax : Positioning_EPOS_Machine_COut;
            Manip_Sostegno : ValveMachine_COut;
            Manip_Pareggiatore : ValveMachine_COut;
            SostegnoVrt : ValveMachine_COut;
         END_STRUCT;
         Cumulativo : Struct
            Manip_Sostegno : ValveMachine_COut;
            Manip_Pareggiatore : ValveMachine_COut;
            SostegnoVrt : ValveMachine_COut;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         Ax_Man : Positioning_EPOS_Machine_Par;
         Ax_Aut : Mach_Speed_Par;
         ToleranceHeight : LReal;
         TimeoutTolerance : Time;
         Pers_Data_Testa : Struct
            EncoderAbsolute_Preset_OK : Bool;
            Persistent_ActualPosition : LReal;
         END_STRUCT;
         Pers_Data_Coda : Struct
            EncoderAbsolute_Preset_OK : Bool;
            Persistent_ActualPosition : LReal;
         END_STRUCT;
         Sens_Testa : Analogic_SensorManagement_Par;
         Sens_Coda : Analogic_SensorManagement_Par;
      END_STRUCT;
      Par_Mach : Struct
         PosPrelievo : LReal;
         PosDeposito : LReal;
         ToleranceWindow : LReal;
      END_STRUCT;
      Data_Testa : Analogic_SensorManagement_Data;
      Data_Coda : Analogic_SensorManagement_Data;
   END_VAR

   VAR
      Alarm : Struct
         Testa : Struct
            Ax : Positioning_EPOS_Machine_Alr;
            Manip_Sostegno : ValveAlr;
            Manip_Pareggiatore : ValveAlr;
            SostegnoVrt : ValveAlr;
         END_STRUCT;
         Coda : Struct
            Ax : Positioning_EPOS_Machine_Alr;
            Manip_Sostegno : ValveAlr;
            Manip_Pareggiatore : ValveAlr;
            SostegnoVrt : ValveAlr;
         END_STRUCT;
         StratoDepositatoNoOk : Bool;
         CheckBothAxMove : Bool;
      END_STRUCT;
      Warning : Struct
         Testa : Struct
            Ax : Positioning_EPOS_Machine_Wng;
            Manip_Sostegno : ValveMachine_Wng;
            Manip_Pareggiatore : ValveMachine_Wng;
            SostegnoVrt : ValveMachine_Wng;
         END_STRUCT;
         Coda : Struct
            Ax : Positioning_EPOS_Machine_Wng;
            Manip_Sostegno : ValveMachine_Wng;
            Manip_Pareggiatore : ValveMachine_Wng;
            SostegnoVrt : ValveMachine_Wng;
         END_STRUCT;
         Sens_Testa : Analogic_SensorManagement_Warning;
         Sens_Coda : Analogic_SensorManagement_Warning;
         MissingCnd : Struct
            OP_VAI_A_PRELIEVO : Bool;
            OP_PRELIEVO : Bool;
            OP_DEPOSITO : Bool;
            OP_VAI_A_DEPOSITO : Bool;
            SollevatoreInWorkspace : Bool;
         END_STRUCT;
      END_STRUCT;
      HMI : Struct
         Selection : Struct
            Ax : Int;
            Manip_Sostegno : Int;
            Manip_Pareggiatore : Int;
            SostegnoVrt : Int;
         END_STRUCT;
         AnalogSensor_Testa : HMI_Preset;
         AnalogSensor_Coda : HMI_Preset;
         Testa : Struct
            PbPreset : Bool;
            PresetValue : LReal;
         END_STRUCT;
         Coda : Struct
            PbPreset : Bool;
            PresetValue : LReal;
         END_STRUCT;
         AltezzaPaccoTesta : Struct
            Target : LReal;
            AltezzaMassimaRilevata : LReal;
            AltezzaMedia : LReal;
            FuoriTolleranza : Bool;
         END_STRUCT;
         AltezzaPaccoCoda : Struct
            Target : LReal;
            AltezzaMassimaRilevata : LReal;
            AltezzaMedia : LReal;
            FuoriTolleranza : Bool;
         END_STRUCT;
      END_STRUCT;
      Sts : Struct
         OP_CanMoveFreely : Bool;
         OP_Vai_A_Prelievo_Cnd : Bool;
         OP_Prelievo_Cnd : Bool;
         OP_Deposito_Cnd : Bool;
         OP_Vai_A_Deposito_Cnd : Bool;
         Coda_PermessoDaSynchOk : Bool;
         Testa_PermessoDaSynchOk : Bool;
         HeightStackerLayer_Testa : LReal;
         HeightStackerLayer_Coda : LReal;
         ActPosPhcTesta : LReal;
         ActPosPhcCoda : LReal;
         MaxHeightDetectedCoda : LReal;
         MaxHeightDetectedTesta : LReal;
      END_STRUCT;
      Ctrl : Struct
         Man : Struct
            OP_Vai_A_Prelievo : Bool;
            OP_Prelievo : Bool;
            OP_Deposito : Bool;
            OP_Vai_A_Deposito : Bool;
         END_STRUCT;
         Aut : Struct
            OP_Vai_A_Prelievo : Bool;
            OP_Prelievo : Bool;
            OP_Deposito : Bool;
            OP_Vai_A_Deposito : Bool;
         END_STRUCT;
         OP_Vai_A_Prelievo : Bool;
         OP_Prelievo : Bool;
         OP_Deposito : Bool;
         OP_Vai_A_Deposito : Bool;
      END_STRUCT;
      Ax_Testa : Positioning_EPOS_Machine_FB_NEW;
      Ax_Coda : Positioning_EPOS_Machine_FB_NEW;
      ValueVelOvr : Array[1..10] of Real;
      Manip_Sostegno_Testa : ValveMachine_FB;
      Manip_Sostegno_Coda : ValveMachine_FB;
      Manip_Pareggiatore_Testa : ValveMachine_FB;
      Manip_Pareggiatore_Coda : ValveMachine_FB;
      SostegnoVrt_Testa : ValveMachine_FB;
      SostegnoVrt_Coda : ValveMachine_FB;
      StratoDepositato_Testa : Analogic_SensorManagement;
      StratoDepositato_Coda : Analogic_SensorManagement;
      ControlloStrato_Testa : Struct
         Enable : Bool;
         InsideCheckWindow : Bool;
         OutOfTolerance : Bool;
      END_STRUCT;
      ControlloStrato_Coda : Struct
         Enable : Bool;
         InsideCheckWindow : Bool;
         OutOfTolerance : Bool;
      END_STRUCT;
      AUX : Struct
         OP_Vai_A_Prelievo : Bool;
         OP_Prelievo : Bool;
         OP_Deposito : Bool;
         OP_Vai_A_Deposito : Bool;
      END_STRUCT;
      TON_OP_VAI_A_PRELIEVO_MissingCnd : IEC_TIMER;
      TON_OP_VAI_A_DEPOSITO_MissingCnd : IEC_TIMER;
      TON_OP_PRELIEVO_MissingCnd : IEC_TIMER;
      TON_OP_DEPOSITO_MissingCnd : IEC_TIMER;
      TON_StratoDepositatoAlarm : IEC_TIMER;
      TON_CheckAxMove : IEC_TIMER;
      CheckAxisSynch : CheckAxisSynch;
      BufferHeight : Array[1..9] of LReal;
   END_VAR

   VAR_TEMP
      PE : Struct
         OP_Vai_A_Prelievo : Bool;
         OP_Prelievo : Bool;
         OP_Deposito : Bool;
         OP_Vai_A_Deposito : Bool;
         LsPosition1 : Bool;
      END_STRUCT;
      AxTesta_InPosDeposito : Bool;
      AxCoda_InPosDeposito : Bool;
      AxTesta_InPosPrelievo : Bool;
      AxCoda_InPosPrelievo : Bool;
      PosDiff : LReal;
      Axis_Testa_Behind : Bool;
      Axis_Coda_Behind : Bool;
      VelOvr_Max : Real;
      i : Int;
      HeightStackerLayer : LReal;
      nSampling : Int;
      spaceSampling : LReal;
   END_VAR

   VAR CONSTANT
      Ax_Fuori_Ingombro : LReal;
      MaxDistance : LReal;
      MinDistance : LReal;
      POS_STOP_CONTROLLO_STRATO : LReal;
      INTERASSE_PHC : LReal;
   END_VAR


BEGIN
   REGION "Reset allarmi"
      IF AreaInterface.RstAlarms THEN
          Alarm.StratoDepositatoNoOk := FALSE;
          Alarm.CheckBothAxMove := FALSE;
          Warning.MissingCnd.SollevatoreInWorkspace := FALSE;
      END_IF;

   END_REGION

   REGION "Operazione può muoversi liberamente perchè non sposta nessun BEAM"
      Sts.OP_CanMoveFreely := CIn.Manager.CanMoveFreely;
   END_REGION

   REGION "Comando Operazione fasi (AUT)"
      Ctrl.Aut.OP_Vai_A_Prelievo := (CIn.Manager.Control_ON AND CIn.Manager.OP.VAI_A_PRELIEVO);
      Ctrl.Aut.OP_Prelievo := (CIn.Manager.Control_ON AND CIn.Manager.OP.PRELIEVO);
      Ctrl.Aut.OP_Vai_A_Deposito := (CIn.Manager.Control_ON AND CIn.Manager.OP.VAI_A_DEPOSITO);
      Ctrl.Aut.OP_Deposito := (CIn.Manager.Control_ON AND CIn.Manager.OP.DEPOSITO);
   END_REGION

   REGION "Comando Operazione vai a Prelievo (MAN)"
      PE.OP_Vai_A_Prelievo := PosEdge(DataIn.OP_Vai_A_Prelievo);
      Ctrl.Man.OP_Vai_A_Prelievo := (((((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND PE.OP_Vai_A_Prelievo) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Ctrl.OP_Vai_A_Prelievo)) AND DataIn.OP_Vai_A_Prelievo) AND NOT (DataIn.OP_Prelievo)) AND NOT (DataIn.OP_Vai_A_Deposito)) AND NOT (DataIn.OP_Deposito));
   END_REGION

   REGION "Comando Operazione Prelievo (MAN)"
      PE.OP_Prelievo := PosEdge(DataIn.OP_Prelievo);
      Ctrl.Man.OP_Prelievo := (((((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND PE.OP_Prelievo) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Ctrl.OP_Prelievo)) AND DataIn.OP_Prelievo) AND NOT (DataIn.OP_Vai_A_Prelievo)) AND NOT (DataIn.OP_Vai_A_Deposito)) AND NOT (DataIn.OP_Vai_A_Deposito));
   END_REGION

   REGION "Comando Operazione vai a Deposito (MAN)"
      PE.OP_Vai_A_Deposito := PosEdge(DataIn.OP_Vai_A_Deposito);
      Ctrl.Man.OP_Vai_A_Deposito := (((((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND PE.OP_Vai_A_Deposito) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Ctrl.OP_Vai_A_Deposito)) AND DataIn.OP_Vai_A_Deposito) AND NOT (DataIn.OP_Vai_A_Prelievo)) AND NOT (DataIn.OP_Prelievo)) AND NOT (DataIn.OP_Deposito));
   END_REGION

   REGION "Comando Operazione Deposito (MAN)"
      PE.OP_Deposito := PosEdge(DataIn.OP_Deposito);
      Ctrl.Man.OP_Deposito := (((((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND PE.OP_Deposito) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Ctrl.OP_Deposito)) AND DataIn.OP_Deposito) AND NOT (DataIn.OP_Vai_A_Prelievo)) AND NOT (DataIn.OP_Prelievo)) AND NOT (DataIn.OP_Vai_A_Deposito));
   END_REGION

   REGION "Cumulativo Operazione Lavoro / Riposo (ALL)"
      Ctrl.OP_Vai_A_Prelievo := NOT ((NOT (Ctrl.Man.OP_Vai_A_Prelievo) AND NOT (Ctrl.Aut.OP_Vai_A_Prelievo)));
      Ctrl.OP_Prelievo := NOT ((NOT (Ctrl.Man.OP_Prelievo) AND NOT (Ctrl.Aut.OP_Prelievo)));
      Ctrl.OP_Vai_A_Deposito := NOT ((NOT (Ctrl.Man.OP_Vai_A_Deposito) AND NOT (Ctrl.Aut.OP_Vai_A_Deposito)));
      Ctrl.OP_Deposito := NOT ((NOT (Ctrl.Man.OP_Deposito) AND NOT (Ctrl.Aut.OP_Deposito)));
   END_REGION

   REGION "Condizioni movimento Operazione a Lavoro / Riposo"
      Sts.OP_Vai_A_Prelievo_Cnd := (CIn.Manager.OP.VAI_A_PRELIEVO OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Sts.OP_Prelievo_Cnd := (CIn.Manager.OP.PRELIEVO OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Sts.OP_Vai_A_Deposito_Cnd := (CIn.Manager.OP.VAI_A_DEPOSITO OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Sts.OP_Deposito_Cnd := (CIn.Manager.OP.DEPOSITO OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "RIFERIMENTI [AX] - Positioning Manager"
      // ******************************************************************************************
      REGION // TRASFERIMENTO DELLE RAMPE
          
          //  = Rampe in Automatico o Semi-Automatico
          IF AreaInterface.Aut THEN
              Ax_Testa.CIn.Manager.Acc := Ax_Coda.CIn.Manager.Acc := Par.Ax_Aut.Aut_Acc;
              Ax_Testa.CIn.Manager.Dec := Ax_Coda.CIn.Manager.Dec := Par.Ax_Aut.Aut_Dec;
              
              
          END_IF;
          
          // Rampe in Manuale
          IF AreaInterface.Man THEN
              Ax_Testa.CIn.Manager.Acc := Ax_Coda.CIn.Manager.Acc := Par.Ax_Man.Man_Acc;
              Ax_Testa.CIn.Manager.Dec := Ax_Coda.CIn.Manager.Dec :=  Par.Ax_Man.Man_Dec;
          END_IF;
      END_REGION

      // ******************************************************************************************
      REGION // // CALCOLO DELLA VELOCITA' TRASFERITA DALL'IMPIANTO IN BASE ALLA LUNGHEZZA DEL PEZZO
          
          // Inizializzo variabile di appoggio controllo overide massimo a un valore basso rispetto setpoint
          IF Sys.AuxFirstPLCCycle THEN
              VelOvr_Max := 100.0;
          END_IF;
          
          // Trasferisco le varibili su un array
          ValueVelOvr[1] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_1000;
          ValueVelOvr[2] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_1500;
          ValueVelOvr[3] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_2000;
          ValueVelOvr[4] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_2500;
          ValueVelOvr[5] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_3000;
          ValueVelOvr[6] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_3500;
          ValueVelOvr[7] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_4000;
          ValueVelOvr[8] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_4500;
          ValueVelOvr[9] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_5000;
          ValueVelOvr[10] := PPrf_MAIN.ON_WORK.A0303_A0304.Trasporto.VelOvr_PLen_UpTo_5500;
          
          // Ciclo per verificare la variabile maggiore per prenderla in lavoro
          FOR i := 1 TO 10 DO
              IF ValueVelOvr[i] >= VelOvr_Max THEN
                  VelOvr_Max := ValueVelOvr[i];
              END_IF;
          END_FOR;// 
          
          IF VelOvr_Max <= 0 THEN
              VelOvr_Max := 100;
          END_IF;
      END_REGION ;

      // *****************************************************************************************
      REGION // CALCOLO DELLA VELOCITA' E TRASFERIMENTO IN BASE ALLO STATO IMPIANTO
          //
          
          IF CIn.Manager.Control_ON THEN
              // CALCOLO VELOCITA' IN BASE ALL'OVERIDE
              IF AreaInterface.Aut THEN
                  Ax_Testa.CIn.Manager.Vel := Ax_Coda.CIn.Manager.Vel := (Par.Ax_Aut.Aut_Vel * VelOvr_Max) / 100;
                  
              ELSIF CIn.SemiAut_Pb THEN
                  Ax_Testa.CIn.Manager.Vel := Ax_Coda.CIn.Manager.Vel := (Par.Ax_Aut.SemiAut_Vel * VelOvr_Max) / 100;
              END_IF;
          END_IF;
      END_REGION ;


   END_REGION

   REGION "Ax Trasporto in posizione"
   END_REGION

   REGION "Sincronizzazione tra asse testa e asse coda"
      CheckAxisSynch(Ax1_Pos := Ax_Testa.Sts.ActualPosition,
                      Ax2_Pos := Ax_Coda.Sts.ActualPosition,
                      TargetPos := Ax_Testa.Ctrl.Pos,
                      MaxDistance := MaxDistance,
                      MinDistance := MinDistance,
                      Ax1_SynchOk => Sts.Testa_PermessoDaSynchOk,
                      Ax2_SynchOk => Sts.Coda_PermessoDaSynchOk);

   END_REGION

   REGION "CIn Abilitazioni Manager"
      //Stop Door Opening Request
      Ax_Testa.CIn.Manager.EnableStopDoorOpeningReq := Ax_Coda.CIn.Manager.EnableStopDoorOpeningReq :=
      Manip_Sostegno_Testa.Cin.Manager.EnableStopDoorOpeningReq := Manip_Sostegno_Coda.Cin.Manager.EnableStopDoorOpeningReq :=
      Manip_Pareggiatore_Testa.Cin.Manager.EnableStopDoorOpeningReq := Manip_Pareggiatore_Coda.Cin.Manager.EnableStopDoorOpeningReq :=
      SostegnoVrt_Testa.Cin.Manager.EnableStopDoorOpeningReq := SostegnoVrt_Coda.Cin.Manager.EnableStopDoorOpeningReq := CIn.Manager.EnableStopDoorOpeningReq;

      //Stop In Phase
      Ax_Testa.CIn.Manager.EnableStopInPhase := Ax_Coda.CIn.Manager.EnableStopInPhase :=
      Manip_Sostegno_Testa.Cin.Manager.EnableStopInPhase := Manip_Sostegno_Coda.Cin.Manager.EnableStopInPhase :=
      Manip_Pareggiatore_Testa.Cin.Manager.EnableStopInPhase := Manip_Pareggiatore_Coda.Cin.Manager.EnableStopInPhase :=
      SostegnoVrt_Testa.Cin.Manager.EnableStopInPhase := SostegnoVrt_Coda.Cin.Manager.EnableStopInPhase := CIn.Manager.EnableStopInPhase;

      //Stop Programmed
      Ax_Testa.CIn.Manager.EnableStopProgrammed := Ax_Coda.CIn.Manager.EnableStopProgrammed :=
      Manip_Sostegno_Testa.Cin.Manager.EnableStopProgrammed := Manip_Sostegno_Coda.Cin.Manager.EnableStopProgrammed :=
      Manip_Pareggiatore_Testa.Cin.Manager.EnableStopProgrammed := Manip_Pareggiatore_Coda.Cin.Manager.EnableStopProgrammed :=
      SostegnoVrt_Testa.Cin.Manager.EnableStopProgrammed := SostegnoVrt_Coda.Cin.Manager.EnableStopProgrammed := CIn.Manager.EnableStopProgrammed;

   END_REGION

   REGION "Cin Manager (Esecuzione sequenza comandi)"
      //CTRL ON
      Ax_Testa.CIn.Manager.Control_ON := Ax_Coda.CIn.Manager.Control_ON :=
      Manip_Sostegno_Testa.Cin.Manager.Control_ON := Manip_Sostegno_Coda.Cin.Manager.Control_ON :=
      Manip_Pareggiatore_Testa.Cin.Manager.Control_ON := Manip_Pareggiatore_Coda.Cin.Manager.Control_ON :=
      SostegnoVrt_Testa.Cin.Manager.Control_ON := SostegnoVrt_Coda.Cin.Manager.Control_ON := Ctrl.OP_Vai_A_Prelievo OR Ctrl.OP_Prelievo OR Ctrl.OP_Vai_A_Deposito OR Ctrl.OP_Deposito;

      // X prima cosa controllo che siano entrambi alla stessa posizione perche si devono muovere insieme
      IF (Ax_Testa.Sts.ActualPosition - Ax_Coda.Sts.ActualPosition)> MaxDistance AND Ctrl.OP_Vai_A_Prelievo THEN
          
          IF Ax_Testa.Sts.ActualPosition > Ax_Coda.Sts.ActualPosition THEN
              Ax_Testa.CIn.Manager.Pos := Ax_Coda.Sts.ActualPosition;
              Ax_Testa.CIn.Manager.MoveToPos := TRUE;
          ELSE
              Ax_Coda.CIn.Manager.Pos := Ax_Testa.Sts.ActualPosition;
              Ax_Coda.CIn.Manager.MoveToPos := TRUE;
          END_IF;
          
      ELSIF (Ax_Testa.Sts.ActualPosition - Ax_Coda.Sts.ActualPosition)> MaxDistance AND Ctrl.OP_Vai_A_Deposito THEN
              
              IF Ax_Testa.Sts.ActualPosition > Ax_Coda.Sts.ActualPosition THEN
                  Ax_Coda.CIn.Manager.Pos := Ax_Testa.Sts.ActualPosition;
                  Ax_Coda.CIn.Manager.MoveToPos := TRUE;
              ELSE
                  Ax_Testa.CIn.Manager.Pos := Ax_Coda.Sts.ActualPosition;
                  Ax_Testa.CIn.Manager.MoveToPos := TRUE;

              END_IF;
              
      ELSIF Ctrl.OP_Vai_A_Prelievo AND Sts.OP_Vai_A_Prelievo_Cnd THEN
          
          Ax_Testa.CIn.Manager.MoveToPos := Ax_Coda.CIn.Manager.MoveToPos := FALSE;
          
          // Sostegno Verticale a Lavoro (Alto)
          SostegnoVrt_Testa.Cin.Manager.Work := NOT SostegnoVrt_Testa.COut.Work;
          SostegnoVrt_Coda.Cin.Manager.Work := NOT SostegnoVrt_Coda.COut.Work;
          
          // Sostegno "L" a Riposo
          Manip_Sostegno_Testa.Cin.Manager.Rest := NOT Manip_Sostegno_Testa.COut.Rest;
          Manip_Sostegno_Coda.Cin.Manager.Rest := NOT Manip_Sostegno_Coda.COut.Rest;
          
          // Pareggiatore a Riposo
          Manip_Pareggiatore_Testa.Cin.Manager.Rest := NOT Manip_Pareggiatore_Testa.COut.Rest AND Manip_Sostegno_Testa.COut.Rest;
          Manip_Pareggiatore_Coda.Cin.Manager.Rest := NOT Manip_Pareggiatore_Coda.COut.Rest AND Manip_Sostegno_Coda.COut.Rest;
          

          // Trasporto in posizione di Prelievo
          Ax_Testa.CIn.Manager.MoveToPos :=  NOT AxTesta_InPosPrelievo AND  (SostegnoVrt_Testa.COut.Work AND SostegnoVrt_Coda.COut.Work ) AND  (Manip_Pareggiatore_Testa.COut.Rest AND Manip_Pareggiatore_Coda.COut.Rest) AND (Manip_Sostegno_Testa.COut.Rest AND Manip_Sostegno_Coda.COut.Rest)  ;
          Ax_Coda.CIn.Manager.MoveToPos := NOT AxCoda_InPosPrelievo AND (SostegnoVrt_Testa.COut.Work AND SostegnoVrt_Coda.COut.Work) AND (Manip_Pareggiatore_Testa.COut.Rest AND Manip_Pareggiatore_Coda.COut.Rest) AND (Manip_Sostegno_Testa.COut.Rest AND Manip_Sostegno_Coda.COut.Rest);;
          
          Ax_Coda.CIn.Manager.Pos := Ax_Testa.CIn.Manager.Pos := Par_Mach.PosPrelievo;
          
          
          
      ELSIF Ctrl.OP_Prelievo AND Sts.OP_Prelievo_Cnd THEN
          
          // Pareggiatore a Lavoro
          Manip_Pareggiatore_Testa.Cin.Manager.Work := SostegnoVrt_Testa.COut.Work AND NOT Manip_Pareggiatore_Testa.COut.Work;
          
          Manip_Pareggiatore_Coda.Cin.Manager.Work := SostegnoVrt_Coda.COut.Work AND NOT Manip_Pareggiatore_Coda.COut.Work;
          
          // Sostegno "L" a Lavoro
          Manip_Sostegno_Testa.Cin.Manager.Work := NOT Manip_Sostegno_Testa.COut.Work AND (Manip_Pareggiatore_Testa.COut.Work AND  Manip_Pareggiatore_Coda.COut.Work);
          Manip_Sostegno_Coda.Cin.Manager.Work := NOT Manip_Sostegno_Coda.COut.Work AND (Manip_Pareggiatore_Testa.COut.Work AND  Manip_Pareggiatore_Coda.COut.Work);
          
          
          // Sostegno Verticale a Riposo
          SostegnoVrt_Testa.Cin.Manager.Rest := NOT SostegnoVrt_Testa.COut.Rest  AND (Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work) ;
          SostegnoVrt_Coda.Cin.Manager.Rest := NOT SostegnoVrt_Coda.COut.Rest AND (Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work);
          
          
      ELSIF Ctrl.OP_Vai_A_Deposito AND Sts.OP_Vai_A_Deposito_Cnd THEN

          Ax_Testa.CIn.Manager.MoveToPos := Ax_Coda.CIn.Manager.MoveToPos := FALSE;
          
          // Sostegno Verticale 
          IF ((Ax_Coda.Sts.ActualPosition > Ax_Fuori_Ingombro) AND (Ax_Testa.Sts.ActualPosition > Ax_Fuori_Ingombro)) THEN
              SostegnoVrt_Testa.Cin.Manager.Work := NOT SostegnoVrt_Testa.COut.Work;
              SostegnoVrt_Coda.Cin.Manager.Work := NOT SostegnoVrt_Coda.COut.Work;
              
          ELSE
              SostegnoVrt_Testa.Cin.Manager.Rest := NOT SostegnoVrt_Testa.COut.Rest AND (Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work);
              SostegnoVrt_Coda.Cin.Manager.Rest := NOT SostegnoVrt_Coda.COut.Rest AND (Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work);
              
          END_IF;
          
          
          // Trasporto in posizione di Trasporto
          Ax_Testa.CIn.Manager.MoveToPos := (NOT AxTesta_InPosDeposito AND ((Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work)
                                           AND (Manip_Pareggiatore_Coda.COut.Work AND  Manip_Pareggiatore_Testa.COut.Work))
                                           AND ((SostegnoVrt_Coda.COut.Rest AND SostegnoVrt_Testa.COut.Rest)OR((Ax_Coda.Sts.ActualPosition > Ax_Fuori_Ingombro) AND (Ax_Testa.Sts.ActualPosition > Ax_Fuori_Ingombro))));
                                          
          Ax_Coda.CIn.Manager.MoveToPos := (NOT AxCoda_InPosDeposito AND ((Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work)
                                           AND (Manip_Pareggiatore_Coda.COut.Work AND Manip_Pareggiatore_Testa.COut.Work))
                                           AND ((SostegnoVrt_Coda.COut.Rest AND SostegnoVrt_Testa.COut.Rest) OR ((Ax_Coda.Sts.ActualPosition > Ax_Fuori_Ingombro) AND (Ax_Testa.Sts.ActualPosition > Ax_Fuori_Ingombro))));
                                           
          Ax_Coda.CIn.Manager.Pos := Ax_Testa.CIn.Manager.Pos := Par_Mach.PosDeposito;
          

          
      ELSIF Ctrl.OP_Deposito AND Sts.OP_Deposito_Cnd THEN
          
          IF ((Ax_Coda.Sts.ActualPosition > Ax_Fuori_Ingombro) AND (Ax_Testa.Sts.ActualPosition > Ax_Fuori_Ingombro)) THEN
              
              // Sostegno Verticale a Lavoro
              SostegnoVrt_Testa.Cin.Manager.Work := NOT SostegnoVrt_Testa.COut.Work;
              SostegnoVrt_Coda.Cin.Manager.Work := NOT SostegnoVrt_Coda.COut.Work;
              
          END_IF;
          
          Ax_Testa.CIn.Manager.MoveToPos := FALSE;
          Ax_Coda.CIn.Manager.MoveToPos := FALSE;
          
          // Sostegno "L" a Riposo
          Manip_Sostegno_Testa.Cin.Manager.Rest := NOT Manip_Sostegno_Testa.COut.Rest AND (Ax_Testa.COut.Standstill AND Ax_Coda.COut.Standstill) ;
          Manip_Sostegno_Coda.Cin.Manager.Rest := NOT Manip_Sostegno_Coda.COut.Rest AND (Ax_Testa.COut.Standstill AND Ax_Coda.COut.Standstill);
          
          // Pareggiatore a Riposo
          Manip_Pareggiatore_Testa.Cin.Manager.Rest :=  NOT Manip_Pareggiatore_Testa.COut.Rest AND (Manip_Sostegno_Testa.COut.Rest AND Manip_Sostegno_Coda.COut.Rest);
          Manip_Pareggiatore_Coda.Cin.Manager.Rest :=  NOT Manip_Pareggiatore_Coda.COut.Rest AND (Manip_Sostegno_Testa.COut.Rest AND Manip_Sostegno_Coda.COut.Rest);
         
          
      ELSE
          // Reset Cmd
          Ax_Testa.CIn.Manager.MoveToPos := FALSE;
          Ax_Coda.CIn.Manager.MoveToPos := FALSE;
          SostegnoVrt_Testa.Cin.Manager.Work := FALSE;
          SostegnoVrt_Testa.Cin.Manager.Rest := FALSE;
          SostegnoVrt_Coda.Cin.Manager.Work := FALSE;
          SostegnoVrt_Coda.Cin.Manager.Rest := FALSE;
          Manip_Sostegno_Testa.Cin.Manager.Work := FALSE;
          Manip_Sostegno_Testa.Cin.Manager.Rest := FALSE;
          Manip_Sostegno_Coda.Cin.Manager.Work := FALSE;
          Manip_Sostegno_Coda.Cin.Manager.Rest := FALSE;
          Manip_Pareggiatore_Testa.Cin.Manager.Work := FALSE;
          Manip_Pareggiatore_Testa.Cin.Manager.Rest := FALSE;
          Manip_Pareggiatore_Coda.Cin.Manager.Work := FALSE;
          Manip_Pareggiatore_Coda.Cin.Manager.Rest := FALSE;
          
          
      END_IF;

   END_REGION

   REGION "Warning manacanza condizioni esecuzione OperazionI"
      #TON_OP_VAI_A_PRELIEVO_MissingCnd(
         IN := Ctrl.OP_Vai_A_Prelievo,
         PT := Config.DelayMissingCondition
      );

      #TON_OP_PRELIEVO_MissingCnd(
         IN := Ctrl.OP_Prelievo,
         PT := Config.DelayMissingCondition
      );

      #TON_OP_VAI_A_DEPOSITO_MissingCnd(
         IN := Ctrl.OP_Vai_A_Deposito,
         PT := Config.DelayMissingCondition
      );

      #TON_OP_DEPOSITO_MissingCnd(
         IN := Ctrl.OP_Deposito,
         PT := Config.DelayMissingCondition
      );

      IF (Sts.OP_Vai_A_Prelievo_Cnd OR Ctrl.OP_Vai_A_Prelievo OR AreaInterface.RstAlarms) THEN
         Warning.MissingCnd.OP_VAI_A_PRELIEVO := FALSE;
      ELSIF #TON_OP_VAI_A_PRELIEVO_MissingCnd.Q THEN
         Warning.MissingCnd.OP_VAI_A_PRELIEVO := TRUE;
      END_IF;
      IF (Sts.OP_Prelievo_Cnd OR Ctrl.OP_Prelievo OR AreaInterface.RstAlarms) THEN
         Warning.MissingCnd.OP_PRELIEVO := FALSE;
      ELSIF #TON_OP_PRELIEVO_MissingCnd.Q THEN
         Warning.MissingCnd.OP_PRELIEVO := TRUE;
      END_IF;
      IF (Sts.OP_Vai_A_Deposito_Cnd OR Ctrl.OP_Vai_A_Deposito OR AreaInterface.RstAlarms) THEN
         Warning.MissingCnd.OP_VAI_A_DEPOSITO := FALSE;
      ELSIF #TON_OP_VAI_A_DEPOSITO_MissingCnd.Q THEN
         Warning.MissingCnd.OP_VAI_A_DEPOSITO := TRUE;
      END_IF;
      IF (Sts.OP_Deposito_Cnd OR Ctrl.OP_Deposito OR AreaInterface.RstAlarms) THEN
         Warning.MissingCnd.OP_DEPOSITO := FALSE;
      ELSIF #TON_OP_DEPOSITO_MissingCnd.Q THEN
         Warning.MissingCnd.OP_DEPOSITO := TRUE;
      END_IF;
   END_REGION

   REGION "Warning Sollevatore nello spazio di lavoro"
      IF ((NOT (CIn.Sollevatore.OutOfWorkspace) AND Ax_Testa.COut.PlusCheckNext) OR (NOT (CIn.Sollevatore.OutOfWorkspace) AND Ax_Coda.COut.PlusCheckNext)) THEN
         Warning.MissingCnd.SollevatoreInWorkspace := TRUE;
      END_IF;
   END_REGION

   REGION "Check axis Movement"
      #TON_CheckAxMove(
         IN := ((((AreaInterface.Cycle OR (Ctrl.OP_Vai_A_Deposito AND Ctrl.OP_Vai_A_Prelievo)) AND Ax_Coda.COut.Standstill) AND NOT (Ax_Testa.COut.Standstill)) OR (((AreaInterface.Cycle OR (Ctrl.OP_Vai_A_Deposito AND Ctrl.OP_Vai_A_Prelievo)) AND NOT (Ax_Coda.COut.Standstill)) AND Ax_Testa.COut.Standstill)),
         PT := T#2S
      );

      IF #TON_CheckAxMove.Q THEN
         Alarm.CheckBothAxMove := TRUE;
      END_IF;
   END_REGION

   REGION "Dynamic Limit (AXIS SYNCH)"
      Ax_Testa.CIn.PositionLimits.EnableMin := FALSE;
      Ax_Testa.CIn.PositionLimits.EnableMax := FALSE;
      Ax_Coda.CIn.PositionLimits.EnableMin := FALSE;
      Ax_Coda.CIn.PositionLimits.EnableMax := FALSE;
      Ax_Coda.CIn.VelocityOverride.Enable := FALSE;
      Ax_Testa.CIn.VelocityOverride.Enable := FALSE;
      IF FALSE THEN
         Ax_Coda.CIn.PositionLimits.PosMax := Ax_Testa.COut.ActualPosition;
      END_IF;
   END_REGION

   REGION "Analogic Position Testa"
      #StratoDepositato_Testa(
         en := TRUE,
         Preset_Conditions := AreaInterface.Man,
         AnalogSensor := DataIn.StratoDepositato_Testa_AnalSens,
         Filter_Tau := T#100MS,
         Par := Par.Sens_Testa,
         Data := Data_Testa,
         HMI := HMI.AnalogSensor_Testa,
         Warning := Warning.Sens_Testa
      );

   END_REGION

   REGION "Analogic Position Coda"
      #StratoDepositato_Coda(
         en := TRUE,
         Preset_Conditions := AreaInterface.Man,
         AnalogSensor := DataIn.StratoDepositato_Coda_AnalSens,
         Filter_Tau := T#100mS,
         Par := Par.Sens_Coda,
         Data := Data_Coda,
         HMI := HMI.AnalogSensor_Coda,
         Warning := Warning.Sens_Testa
      );

   END_REGION

   REGION "Controllo Altezza Layer depositati ok"
      //Calcolo l'altezza teorica attuale del Layer depositato sul sollevatore dell'impilamento per verificare che sia stato depositato correttamente
      CalcAltezza_Layer(Layers_Qty:=BTrk.A0303.Stacker.Layers_Qty,Beams_W_A:=BTrk.A0303.Stacker.Beams_W_A,Height=>HeightStackerLayer);

      Sts.HeightStackerLayer_Testa := CIn.Sollevatore.ActualPos_Testa - HeightStackerLayer;
      Sts.HeightStackerLayer_Coda := CIn.Sollevatore.ActualPos_Coda - HeightStackerLayer;

      Sts.ActPosPhcTesta := Ax_Testa.COut.ActualPosition + INTERASSE_PHC;
      Sts.ActPosPhcCoda := Ax_Coda.COut.ActualPosition + INTERASSE_PHC;


      // Il sensore analogico mi deve rilevare se l'altezza rilevata è piu alta di quella teorica perche starebbe a significare che il pezzo si e messo storto
      // Il controllo viene fatto quando Il traslatore torna nella posizione di prelievo
      // 
      ControlloStrato_Testa.InsideCheckWindow := (Sts.ActPosPhcTesta > POS_STOP_CONTROLLO_STRATO) AND (Sts.ActPosPhcTesta < (BTrk.A0303.Preparation.Beam_H_B * BTrk.A0303.Preparation.BeamsPerLayer_Target));
      ControlloStrato_Coda.InsideCheckWindow := (Sts.ActPosPhcCoda > POS_STOP_CONTROLLO_STRATO) AND (Sts.ActPosPhcCoda < (BTrk.A0303.Preparation.Beam_H_B * BTrk.A0303.Preparation.BeamsPerLayer_Target));


      ControlloStrato_Testa.Enable :=Par.Sens_Testa.Enable AND Ctrl.OP_Vai_A_Prelievo  AND ControlloStrato_Testa.InsideCheckWindow AND NOT BTrk.A0303.Stacker.Empty AND BTrk.A0303.Stacker.Layers_Qty<BTrk.A0303.Stacker.Layers_Target ;
      ControlloStrato_Coda.Enable :=Par.Sens_Coda.Enable AND Ctrl.OP_Vai_A_Prelievo  AND ControlloStrato_Coda.InsideCheckWindow AND NOT BTrk.A0303.Stacker.Empty AND BTrk.A0303.Stacker.Layers_Qty<BTrk.A0303.Stacker.Layers_Target;

      // Controllo che l'altezza rilevata non vada oltre a quella teorica
      IF (StratoDepositato_Testa.ScaleValue < (Sts.HeightStackerLayer_Testa - Par.ToleranceHeight)) AND ControlloStrato_Testa.Enable THEN
          ControlloStrato_Testa.OutOfTolerance := TRUE;
      END_IF;

      // Controllo che l'altezza rilevata non vada oltre a quella teorica
      IF (StratoDepositato_Coda.ScaleValue < (Sts.HeightStackerLayer_Coda - Par.ToleranceHeight)) AND ControlloStrato_Coda.Enable THEN
          ControlloStrato_Coda.OutOfTolerance := TRUE;
      END_IF;



      TON_StratoDepositatoAlarm.(IN:= ControlloStrato_Testa.OutOfTolerance OR ControlloStrato_Coda.OutOfTolerance,PT:=Par.TimeoutTolerance);

      IF TON_StratoDepositatoAlarm.Q AND (AxTesta_InPosPrelievo OR AxCoda_InPosPrelievo) THEN
          Alarm.StratoDepositatoNoOk := TRUE;
          ControlloStrato_Testa.OutOfTolerance := FALSE;
          ControlloStrato_Coda.OutOfTolerance := FALSE;
      END_IF;
          
          
      // Status per HMI
      // 
      IF ControlloStrato_Coda.Enable THEN
          
          HMI.AltezzaPaccoCoda.Target := (IN := Sts.HeightStackerLayer_Coda);
          
          IF StratoDepositato_Coda.ScaleValue < Sts.MaxHeightDetectedCoda THEN
              Sts.MaxHeightDetectedCoda := StratoDepositato_Coda.ScaleValue;
              HMI.AltezzaPaccoCoda.AltezzaMassimaRilevata := (IN := Sts.MaxHeightDetectedCoda);
          END_IF;
          
          HMI.AltezzaPaccoCoda.FuoriTolleranza := ControlloStrato_Coda.OutOfTolerance;
          
      ELSE
          Sts.MaxHeightDetectedCoda := 9999.0;
      END_IF;

      IF ControlloStrato_Testa.Enable THEN
          
          HMI.AltezzaPaccoTesta.Target := (IN := Sts.HeightStackerLayer_Coda);
          
          IF StratoDepositato_Testa.ScaleValue < Sts.MaxHeightDetectedTesta THEN
              Sts.MaxHeightDetectedTesta := StratoDepositato_Testa.ScaleValue;
              HMI.AltezzaPaccoTesta.AltezzaMassimaRilevata := (IN := Sts.MaxHeightDetectedTesta);
          END_IF;
          
          HMI.AltezzaPaccoTesta.FuoriTolleranza := ControlloStrato_Testa.OutOfTolerance;
          
      ELSE
          Sts.MaxHeightDetectedTesta := 9999.0;
      END_IF;






          
          

   END_REGION

   REGION "[Ax] CIn External alarm"
      Ax_Testa.CIn.ExternalAlarms := Alarm.CheckBothAxMove;
   END_REGION

   REGION "[Ax] Cin Ext Enable"
      Ax_Testa.CIn.Minus_ExtEnable := (CIn.Manager.Control_ON OR Ctrl.OP_Vai_A_Prelievo OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely) AND NOT (Ctrl.OP_Vai_A_Prelievo)));
      Ax_Testa.CIn.Plus_ExtEnable := ((((CIn.Manager.Control_ON OR Ctrl.OP_Vai_A_Deposito OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely) AND NOT (Ctrl.OP_Vai_A_Deposito))) AND CIn.Sollevatore.OutOfWorkspace) AND NOT (CIn.Antiribaltamento.InPos0)) OR (((CIn.Manager.Control_ON OR Ctrl.OP_Vai_A_Deposito OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely) AND NOT (Ctrl.OP_Vai_A_Deposito))) AND CIn.Sollevatore.OutOfWorkspace) AND CIn.Antiribaltamento.InRestPos));
   END_REGION

   REGION "[Ax] HMI preset position"
      Ax_Testa.HMI.B_Preset := (HMI.Testa.PbPreset AND Ax_Testa.Sts.Preset_Cnd);
      Ax_Testa.HMI.PresetPosition := HMI.Testa.PresetValue;
   END_REGION

   REGION "[Ax] Axis Manger"
      #Ax_Testa(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Feed_Testa,
         Config := Config.Testa.Ax,
         Par := Par.Ax_Man,
         Pers_Data := Par.Pers_Data_Testa,
         Warning := Warning.Testa.Ax,
         Alarm := Alarm.Testa.Ax,
         COut => COut.Testa.Ax
      );

   END_REGION

   REGION "Manip Sostegno - CIn External alarm"
      Manip_Sostegno_Testa.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "Manip Sostegno - Cin Ext Enable"
      Manip_Sostegno_Testa.Cin.Rest_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Manip_Sostegno_Testa.Cin.Work_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Valve Manager"
      #Manip_Sostegno_Testa(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Testa.Manip_Sostegno,
         Alarm := Alarm.Testa.Manip_Sostegno,
         Warning := Warning.Testa.Manip_Sostegno,
         COut => COut.Testa.Manip_Sostegno
      );

   END_REGION

   REGION "Manip Pareggiatore - CIn External alarm"
      Manip_Pareggiatore_Testa.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "Manip Pareggiatore - Cin Ext Enable"
      Manip_Pareggiatore_Testa.Cin.Rest_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Manip_Pareggiatore_Testa.Cin.Work_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Valve Manager"
      #Manip_Pareggiatore_Testa(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Testa.Manip_Pareggiatore,
         Alarm := Alarm.Testa.Manip_Pareggiatore,
         Warning := Warning.Testa.Manip_Pareggiatore,
         COut => COut.Testa.Manip_Pareggiatore
      );

   END_REGION

   REGION "Sostegno Verticale - CIn External alarm"
      SostegnoVrt_Testa.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "Sostegno Verticale  - Cin Ext Enable"
      SostegnoVrt_Testa.Cin.Rest_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      SostegnoVrt_Testa.Cin.Work_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Valve Manager"
      #SostegnoVrt_Testa(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Testa.SostegnoVrt,
         Alarm := Alarm.Testa.SostegnoVrt,
         Warning := Warning.Testa.SostegnoVrt,
         COut => COut.Testa.SostegnoVrt
      );

   END_REGION

   REGION "[Ax]  CIn External alarm"
      Ax_Coda.CIn.ExternalAlarms := Alarm.CheckBothAxMove;
   END_REGION

   REGION "[Ax]  Cin Ext Enable"
      Ax_Coda.CIn.Minus_ExtEnable := (CIn.Manager.Control_ON OR Ctrl.OP_Vai_A_Prelievo OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely) AND NOT (Ctrl.OP_Vai_A_Prelievo)));
      Ax_Coda.CIn.Plus_ExtEnable := ((((CIn.Manager.Control_ON OR Ctrl.OP_Vai_A_Deposito OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely) AND NOT (Ctrl.OP_Vai_A_Deposito))) AND CIn.Sollevatore.OutOfWorkspace) AND NOT (CIn.Antiribaltamento.InPos0)) OR (((CIn.Manager.Control_ON OR Ctrl.OP_Vai_A_Deposito OR (((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely) AND NOT (Ctrl.OP_Vai_A_Deposito))) AND CIn.Sollevatore.OutOfWorkspace) AND CIn.Antiribaltamento.InRestPos));
   END_REGION

   REGION "[Ax] HMI preset position"
      Ax_Coda.HMI.B_Preset := (HMI.Coda.PbPreset AND Ax_Coda.Sts.Preset_Cnd);
      Ax_Coda.HMI.PresetPosition := HMI.Coda.PresetValue;
   END_REGION

   REGION "[Ax] Axis Manger"
      #Ax_Coda(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Feed_Coda,
         Config := Config.Coda.Ax,
         Par := Par.Ax_Man,
         Pers_Data := Par.Pers_Data_Coda,
         Warning := Warning.Coda.Ax,
         Alarm := Alarm.Coda.Ax,
         COut => COut.Coda.Ax
      );

   END_REGION

   REGION "Sostegno - CIn External alarm"
      Manip_Sostegno_Coda.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "Sostegno - Cin Ext Enable"
      Manip_Sostegno_Coda.Cin.Rest_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Manip_Sostegno_Coda.Cin.Work_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Valve Manager"
      #Manip_Sostegno_Coda(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Coda.Manip_Sostegno,
         Alarm := Alarm.Coda.Manip_Sostegno,
         Warning := Warning.Coda.Manip_Sostegno,
         COut => COut.Coda.Manip_Sostegno
      );

   END_REGION

   REGION "Pareggiatore - CIn External alarm"
      Manip_Pareggiatore_Coda.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "Pareggiatore - Cin Ext Enable"
      Manip_Pareggiatore_Coda.Cin.Rest_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Manip_Pareggiatore_Coda.Cin.Work_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Valve Manager"
      #Manip_Pareggiatore_Coda(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Coda.Manip_Pareggiatore,
         Alarm := Alarm.Coda.Manip_Pareggiatore,
         Warning := Warning.Coda.Manip_Pareggiatore,
         COut => COut.Coda.Manip_Pareggiatore
      );

   END_REGION

   REGION "Sostegno Verticale - CIn External alarm"
      SostegnoVrt_Coda.Cin.ExternalAlarms := FALSE;
   END_REGION

   REGION "Sostegno Verticale  - Cin Ext Enable"
      SostegnoVrt_Coda.Cin.Rest_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      SostegnoVrt_Coda.Cin.Work_ExtEnable := (CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Valve Manager"
      #SostegnoVrt_Coda(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI_Valve,
         Config := Config.Coda.SostegnoVrt,
         Alarm := Alarm.Coda.SostegnoVrt,
         Warning := Warning.Coda.SostegnoVrt,
         COut => COut.Coda.SostegnoVrt
      );

   END_REGION

   REGION "Sostegno - COut"
      COut.Cumulativo.Manip_Sostegno.Rest := (Manip_Sostegno_Testa.COut.Rest AND Manip_Sostegno_Coda.COut.Rest);
      COut.Cumulativo.Manip_Sostegno.Work := (Manip_Sostegno_Testa.COut.Work AND Manip_Sostegno_Coda.COut.Work);
      COut.Cumulativo.Manip_Sostegno.Standstill := (Manip_Sostegno_Testa.COut.Standstill AND Manip_Sostegno_Coda.COut.Standstill);
   END_REGION

   REGION "Manip Pareggiatore - COut"
      COut.Cumulativo.Manip_Pareggiatore.Rest := (Manip_Pareggiatore_Testa.COut.Rest AND Manip_Pareggiatore_Coda.COut.Rest);
      COut.Cumulativo.Manip_Pareggiatore.Work := (Manip_Pareggiatore_Testa.COut.Work AND Manip_Pareggiatore_Coda.COut.Work);
      COut.Cumulativo.Manip_Pareggiatore.Standstill := (Manip_Pareggiatore_Testa.COut.Standstill AND Manip_Pareggiatore_Coda.COut.Standstill);
   END_REGION

   REGION "Sostegno Verticale - COut"
      COut.Cumulativo.SostegnoVrt.Rest := (SostegnoVrt_Testa.COut.Rest AND SostegnoVrt_Coda.COut.Rest);
      COut.Cumulativo.SostegnoVrt.Work := (SostegnoVrt_Testa.COut.Work AND SostegnoVrt_Coda.COut.Work);
      COut.Cumulativo.SostegnoVrt.Standstill := (Manip_Pareggiatore_Testa.COut.Standstill AND Manip_Pareggiatore_Coda.COut.Standstill);
   END_REGION

   REGION "Collect machine to zone interface (internal machines OR)"
   END_REGION


END_FUNCTION_BLOCK
