// Block: A0303_Spalla_FB
// Title: Operazione può muoversi liberamente perchè non sposta nessun BEAM

FUNCTION_BLOCK "A0303_Spalla_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Operazione può muoversi liberamente perchè non sposta nessun BEAM
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI : udt_DeviceSafetyInterface;
      DataIn : Struct
         OP_Pos : Bool;
         FC_Aticoll_Paregg : Bool;
      END_STRUCT;
      CIn : Struct
         Manager : Positioning_DOL_Machine_Manager;
         Antiribaltamento : Struct
            OutOfWorkspace : Bool;
         END_STRUCT;
         Pareggiatore : Struct
            ActualPosition : LReal;
         END_STRUCT;
      END_STRUCT;
      Config : Struct
         Ax : Positioning_DOL_Machine_Config;
         DelayMissingCondition : Time;
      END_STRUCT;
      HWID : Struct
         Ax_TEL1 : HW_SUBMODULE;
         Enc_IO : HW_SUBMODULE;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      COut : Struct
         Ax : Positioning_DOL_Machine_COut;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         Ax : Positioning_DOL_Machine_Par;
         Ax_Pers : Positioning_DOL_Machine_Pers_Data;
         Enc : PosFbk_RTN;
      END_STRUCT;
      Par_Mach : Struct
         MinDistanzaConParegg : LReal;
         ToleranceWindow : LReal;
      END_STRUCT;
   END_VAR

   VAR
      Alarm : Struct
         Ax : Positioning_DOL_Machine_Alr;
         Enc : PosFbk_Encoder_Alr;
      END_STRUCT;
      Warning : Struct
         Ax : Positioning_DOL_Machine_Wng;
         SW_Limit_AntiCollision : Bool;
         OP_POS_MissingCnd : Bool;
      END_STRUCT;
      HMI : Struct
         PbPreset : Bool;
         B_Preset_UM2 : Bool;
         PresetValue : LReal;
      END_STRUCT;
      Sts : Struct
         AlarmsPresence : Bool;
         WarningsPresence : Bool;
         OP_CanMoveFreely : Bool;
         OP_Pos_Cnd : Bool;
      END_STRUCT;
      Ctrl : Struct
         OP_Pos_Aut : Bool;
         OP_Pos_Run : Bool;
         OP_Pos_Man : Bool;
         OP_Pos : Bool;
      END_STRUCT;
      Ax : Positioning_DOL_Machine_FB;
      Enc : PosFbk_SickAFM60;
      Enc_ITF : PosFbk_ITF;
      AUX : Struct
         OP_Pos_PB : Bool;
      END_STRUCT;
      TON_OP_POS_MissingCnd : IEC_TIMER;
      TON_DistanzaOK : IEC_TIMER;
   END_VAR

   VAR_TEMP
      PE : Struct
         OP_Pos_PB : Bool;
      END_STRUCT;
      ActualDifference : LReal;
   END_VAR


BEGIN
   REGION "Operazione può muoversi liberamente perchè non sposta nessun BEAM"
      Sts.OP_CanMoveFreely := TRUE;
   END_REGION

   REGION "Comando Operazione Avanti / Indietro (AUT)"
      Ctrl.OP_Pos_Aut := (CIn.Manager.Control_ON AND CIn.Manager.MoveToPos);
   END_REGION

   REGION "Comando Operazione Posiziona (MAN)"
      PE.OP_Pos_PB := PosEdge(DataIn.OP_Pos);
      Ctrl.OP_Pos_Man := ((((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND PE.OP_Pos_PB) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Ctrl.OP_Pos_Man)) AND DataIn.OP_Pos);
   END_REGION

   REGION "Cumulativo Operazione Lavoro / Riposo (ALL)"
      Ctrl.OP_Pos := NOT ((NOT (Ctrl.OP_Pos_Aut) AND NOT (Ctrl.OP_Pos_Man)));
   END_REGION

   REGION "Condizioni movimento Operazione a Lavoro / Riposo"
      Sts.OP_Pos_Cnd := ((CIn.Manager.Control_ON AND CIn.Manager.MoveToPos) OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "Cin Manager Comando posizionamento"
      // CIn Manager  Control ON se ho un richiesta di comando attiva
      Ax.CIn.Manager.Control_ON := Ctrl.OP_Pos;
      Ax.CIn.Manager.Speed := CIn.Manager.Speed;

      // Resetto i comandi se non c'è nessuna richiesta attiva
      IF NOT Ax.CIn.Manager.Control_ON THEN
          Ax.CIn.Manager.MoveToPos := FALSE;
      END_IF;

      IF Ctrl.OP_Pos AND Sts.OP_Pos_Cnd THEN
          //In posizione di attrezzaggio
          //
          Ax.CIn.Manager.MoveToPos := CIn.Manager.MoveToPos;
          Ax.CIn.Manager.Pos := CIn.Manager.Pos;
      ELSE
          Ax.CIn.Manager.MoveToPos := FALSE;
      END_IF;

   END_REGION

   REGION "CIn Abilitazioni Stop Manager"
      // CIn Manager Stop per richiesta apertura safety
      // 
      Ax.CIn.Manager.EnableStopDoorOpeningReq := CIn.Manager.EnableStopDoorOpeningReq;

      // CIn Manager Stop in fase delle macchine precedenti
      // 
      Ax.CIn.Manager.EnableStopInPhase := CIn.Manager.EnableStopInPhase;
       
      // CIn Manager Stop programmato configurabile a piacere
      // 
      Ax.CIn.Manager.EnableStopProgrammed := CIn.Manager.EnableStopProgrammed;


   END_REGION

   REGION "Warning manacanza condizioni esecuzione Operazione RIPOSO / LAVORO"
      #TON_OP_POS_MissingCnd(
         IN := Ctrl.OP_Pos_Run,
         PT := Config.DelayMissingCondition
      );

      IF (Sts.OP_Pos_Cnd OR AreaInterface.RstAlarms) THEN
         Warning.OP_POS_MissingCnd := FALSE;
      ELSIF #TON_OP_POS_MissingCnd.Q THEN
         Warning.OP_POS_MissingCnd := TRUE;
      END_IF;
   END_REGION

   REGION "[Ax] -  Cin Ext Enable"
      Ax.CIn.MinusExtEnable := ((((((CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely)) AND NOT (DataIn.FC_Aticoll_Paregg)) AND BTrk.A0303.Preparation.Empty) AND BTrk.A0303.Transfert.Empty) AND BTrk.A0303.Stacker.Empty) AND CIn.Antiribaltamento.OutOfWorkspace);
      Ax.CIn.PlusExtEnable := (((((CIn.Manager.Control_ON OR ((AreaInterface.Man AND NOT (CIn.Manager.Control_ON)) AND Sts.OP_CanMoveFreely)) AND BTrk.A0303.Preparation.Empty) AND BTrk.A0303.Transfert.Empty) AND BTrk.A0303.Stacker.Empty) AND CIn.Antiribaltamento.OutOfWorkspace);
   END_REGION

   REGION "[Ax] - CIn External alarm"
      Ax.CIn.ExternalAlarms := FALSE;
   END_REGION

   REGION "[Ax] - CIn Dynamic Limits"
      #TON_DistanzaOK(
         IN := ((Ax.Ax.AxisSts.ActualPosition - CIn.Pareggiatore.ActualPosition) AND (ActualDifference >= Par_Mach.MinDistanzaConParegg)),
         PT := T#3S
      );

      Ax.CIn.PositionLimits.EnableMin := TRUE;
      Ax.CIn.PositionLimits.EnableMax := TRUE;
      ActualDifference := (Ax.Ax.AxisSts.ActualPosition - CIn.Pareggiatore.ActualPosition);
      IF #TON_DistanzaOK.Q THEN
         Ax.CIn.PositionLimits.PosMin := Par.Ax.Minus_Limit;
      END_IF;
      IF Par.Ax.Minus_Limit THEN
         Warning.SW_Limit_AntiCollision := FALSE;
      END_IF;
      IF Ax.Ax.AxisSts.ActualPosition THEN
         Warning.SW_Limit_AntiCollision := TRUE;
      END_IF;
   END_REGION

   REGION "[Ax] Encoder - Main"
      #Enc(
         en := TRUE,
         HW_IO := HWID.Enc_IO,
         Interface := Enc_ITF,
         Retain := Par.Enc,
         Alarm := Alarm.Enc
      );

   END_REGION

   REGION "[Ax] HMI preset position"
      Ax.HMI.B_Preset := (HMI.PbPreset AND Ax.Ax.AxisSts.HomingPermitted);
      Ax.HMI.PresetPosition := HMI.PresetValue;
   END_REGION

   REGION "[Ax] Axis Manager"
      #Ax(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI,
         Config := Config.Ax,
         HW_ID_TEL1 := HWID.Ax_TEL1,
         PosFeedback := Enc_ITF,
         Par := Par.Ax,
         Pers_Data := Par.Ax_Pers,
         Warning := Warning.Ax,
         Alarm := Alarm.Ax,
         COut => COut.Ax
      );

   END_REGION

   REGION "Collect machine to zone interface"
   END_REGION


END_FUNCTION_BLOCK
