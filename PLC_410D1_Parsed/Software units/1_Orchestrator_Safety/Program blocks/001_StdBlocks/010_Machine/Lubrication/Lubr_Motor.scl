// Block: Lubr_Motor
// Title: Info

FUNCTION_BLOCK "Lubr_Motor"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Info
   VAR_INPUT
      DataIn : Struct
         PbManualLubr : Bool;
         LubrRotationFbk : Bool;
         SensorLevel : Bool;
         MotorFdbkRunning : Bool;
         MotorThermalProtection : Bool;
      END_STRUCT;
      ValveCycleTimeOut : Time;
      Simulation : Bool;
   END_VAR

   VAR_OUTPUT
      RunContactor : Bool;
   END_VAR

   VAR_IN_OUT
      Par : LubrMotor_Par;
   END_VAR

   VAR
      Ctrl : Struct
         RunReq : Bool;
      END_STRUCT;
      Sts : Struct
         OldValve : Int;
      END_STRUCT;
      Alarm : LubrMotor_Alr;
      HMI : LubrMotorPump_HMI;
      LubrInterface : LubrValve_ITF;
      tonRotationON : IEC_TIMER;
      tonRotationOFF : IEC_TIMER;
      tonLowLevel : IEC_TIMER;
      ValveChianTimeOut : IEC_TIMER;
      LubrMotor : Motor;
   END_VAR


BEGIN
   REGION "Info"
      //=============================================================================
      //PM FORMING
      //-----------------------------------------------------------------------------
      // Library: StandardBlocks
      // Tested with: S7-1518TF
      // Engineering: TIA Portal V18
      // Restrictions: -
      // Requirements: S7-1500
      // Functionality: Lubrication Motor for Lubr_Valve Machine
      //
      // v1.0.0  28/12/2022 
      // v1.0.2  23/01/2023 Set default ValveCycleTimeOut at 5M
      // v1.1.0  14/02/2023 Simulation added
      // v1.1.2  27/10/2023 Bug Fixes
      //=============================================================================

   END_REGION

   REGION "Reset Alarms"
      IF LubrInterface.Ctrl.RstAlarms THEN
          Alarm.RotationFeedback := FALSE;
          Alarm.LowLevelLubrication := FALSE;
      END_IF;

   END_REGION

   REGION "Alarms & Warning"
      //Low level lubrication alarm
      tonLowLevel.(IN := NOT DataIn.SensorLevel,
                       PT := Par.LowLevelCheckTime);

      IF tonLowLevel.Q AND LubrMotor.Contactor AND NOT Simulation THEN
          Alarm.LowLevelLubrication := TRUE;
      END_IF;

      //Rotation feedback alarm
      tonRotationON.(IN := DataIn.LubrRotationFbk AND LubrMotor.Contactor,
                         PT := Par.RotationFbkCheckTime);

      tonRotationOFF.(IN := NOT DataIn.LubrRotationFbk AND LubrMotor.Contactor,
                          PT := Par.RotationFbkCheckTime);

      IF (tonRotationON.Q OR tonRotationOFF.Q) AND Par.EnableCheckRotation AND NOT Simulation THEN
          Alarm.RotationFeedback := TRUE;
      END_IF;

   END_REGION

   REGION "Motor Ctrl"
      IF LubrInterface.ValveChain.ActualValve > 0 THEN
          Ctrl.RunReq := LubrInterface.Ctrl.WorkReq;
      ELSE
          Ctrl.RunReq := FALSE;
      END_IF;

      LubrMotor.MotorCtrl.Run := (Ctrl.RunReq OR DataIn.PbManualLubr) AND NOT LubrInterface.Sts.Error;

      LubrMotor.MotorCtrl.SafeStop := FALSE;
      LubrMotor.MotorCtrl.Rst := LubrInterface.Ctrl.RstAlarms;
      LubrMotor.FeedbackTimeout := T#500MS;

      LubrMotor(ThermalProtection := DataIn.MotorThermalProtection,
                 FdbkRunning := DataIn.MotorFdbkRunning,
                 Simulation := Simulation,
                 Contactor => RunContactor,
                 Alarm := Alarm.MotorAlr);

      LubrInterface.Sts.Running := LubrMotor.MotorSts.Running;
      LubrInterface.Sts.Error := Alarm.LowLevelLubrication OR Alarm.RotationFeedback OR LubrMotor.MotorSts.AlarmPresence;
      LubrInterface.Sts.PumpType := 0;

   END_REGION

   REGION "ValveChain"
      // End of round
      IF LubrInterface.ValveChain.ActualValve > LubrInterface.ValveChain.MaxValve THEN
          LubrInterface.ValveChain.ActualValve := 1;
      END_IF;

      // Timeout
      ValveChianTimeOut.(IN := LubrInterface.ValveChain.ActualValve = Sts.OldValve,
                             PT := ValveCycleTimeOut);

      IF ValveChianTimeOut.Q THEN
          LubrInterface.ValveChain.ActualValve += 1;
      END_IF;
      Sts.OldValve := LubrInterface.ValveChain.ActualValve;



      // Not enabled 
      IF LubrInterface.ValveChain.MaxValve = 0 THEN
          LubrInterface.ValveChain.ActualValve := 0;
      END_IF;

      // Init Chain
      LubrInterface.ValveChain.MaxValve := 0;
       

   END_REGION

   REGION "HMI"
      HMI.Alarm := LubrInterface.Sts.Error;
      HMI.Running := LubrInterface.Sts.Running;

   END_REGION


END_FUNCTION_BLOCK
