// Block: DiesLubrication_FB
// Title: Reset alarms command

FUNCTION_BLOCK "DiesLubrication_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Reset alarms command
   VAR_INPUT
      AreaInterface : AreaInterface;
      DataIn : Struct
         PbStop : Bool;
         PbStart : Bool;
         SensorLevel : Bool;
         ConnectorPlugged : Bool;
      END_STRUCT;
      CIn : Struct
         EnableStopInPhase : Bool;
         EnableStopProgrammed : Bool;
         EnableAborting : Bool;
         JobDone : Bool;
         ExternalPumpCycleDone : Bool;
         CutBenchCode : DInt;
      END_STRUCT;
      Config : Struct
         EnableWngSystemOff : Bool;
         ExternalPump : Bool;
         PumpWorkDuration : Time;
         PumpPauseDuration : Time;
         LowTankLevelDly : Time;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      DataOut : Struct
         PneumaticPumpSolenoidValve : Bool;
         Lamp : Bool;
      END_STRUCT;
      COut : Struct
         IsRunning : Bool;
         ToolsJobCounter : UDInt;
         PumpCycleCounter : UDInt;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      PersistentValues : Struct
         Data : Struct
            SavedCutBenchCode : DInt;
            PumpJobCounter : UDInt;
            JobsCounter : UDInt;
         END_STRUCT;
         Par : Struct
            SystemOffOn : Bool;
            JobsToStart : UDInt;
            OilPumpCycles : UDInt;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR
      Sts : Struct
         AlarmsPresence : Bool;
         WarningsPresence : Bool;
         IsStandstill : Bool;
         PumpPauseDone : Bool;
         PumpWorkDone : Bool;
         LubNormCycleReq : Bool;
         Condition : Bool;
      END_STRUCT;
      Ctrl : Struct
         RstAlarms : Bool;
         SafeMotion : Bool;
         StopDoorOpen : Bool;
         StopSafe : Bool;
         StopInPhase : Bool;
         StopProgrammed : Bool;
         ManStart : Bool;
         AutStart : Bool;
         V_Pneumatic : Bool;
      END_STRUCT;
      Warning : Struct
         NoAutReady : Bool;
         SystemOff : Bool;
      END_STRUCT;
      Alarm : Struct
         LowTankLevel : Bool;
         ConnectorUnplugged : Bool;
      END_STRUCT;
      TON_PumpPause : IEC_TIMER;
      TON_PumpWork : IEC_TIMER;
      TON_LowTankLevel : IEC_TIMER;
      JobDonePEAux : Bool;
      PbStartPEAux : Bool;
   END_VAR

   VAR_TEMP
      CutBechChanged : Bool;
      JobDonePositiveEdge : Bool;
   END_VAR


BEGIN
   REGION "Reset alarms command"
      Ctrl.RstAlarms := AreaInterface.RstAlarms;

      IF Ctrl.RstAlarms THEN
          Warning.NoAutReady := FALSE;
          Alarm.LowTankLevel := FALSE;
          Alarm.ConnectorUnplugged := FALSE;
      END_IF;

   END_REGION

   REGION "Warning system is off"
      Warning.SystemOff := (NOT (PersistentValues.Par.SystemOffOn) AND NOT (Config.EnableWngSystemOff));
   END_REGION

   REGION "Alarm low tank level"
      #TON_LowTankLevel(
         IN := NOT (DataIn.SensorLevel),
         PT := Config.LowTankLevelDly
      );

      IF NOT (PersistentValues.Par.SystemOffOn) THEN
         Alarm.LowTankLevel := FALSE;
      ELSIF #TON_LowTankLevel.Q THEN
         Alarm.LowTankLevel := TRUE;
      END_IF;
   END_REGION

   REGION "Alarm connector (pipe) unplugged"
      IF NOT (PersistentValues.Par.SystemOffOn) THEN
         Alarm.ConnectorUnplugged := FALSE;
      ELSIF ((CIn.CutBenchCode <> 0) AND NOT (DataIn.ConnectorPlugged)) THEN
         Alarm.ConnectorUnplugged := TRUE;
      END_IF;
   END_REGION

   REGION "Safety stops"
      Ctrl.StopDoorOpen := Sys.Bit0;
      Ctrl.StopSafe := AreaInterface.EStop;
   END_REGION

   REGION "Cycle stops"
      IF NOT (AreaInterface.StopInPhase) THEN
         Ctrl.StopInPhase := FALSE;
      ELSIF CIn.EnableStopInPhase THEN
         Ctrl.StopInPhase := TRUE;
      END_IF;
      IF NOT (AreaInterface.StopProgrammed) THEN
         Ctrl.StopProgrammed := FALSE;
      ELSIF CIn.EnableStopProgrammed THEN
         Ctrl.StopProgrammed := TRUE;
      END_IF;
   END_REGION

   REGION "Job counter add"
      JobDonePositiveEdge := PosEdge(CIn.JobDone);
      IF ((JobDonePositiveEdge AND NOT (Ctrl.AutStart)) AND NOT (Ctrl.ManStart)) THEN
         PersistentValues.Data.JobsCounter := (PersistentValues.Data.JobsCounter + 1);
      END_IF;
   END_REGION

   REGION "Cut bench code is change -> reset counters"
      IF (CIn.CutBenchCode <> PersistentValues.Data.SavedCutBenchCode) THEN
         PersistentValues.Data.SavedCutBenchCode := CIn.CutBenchCode;
      END_IF;
      CutBechChanged := CIn.CutBenchCode;
   END_REGION

   REGION "Pump cycle"
      #TON_PumpPause(
         IN := (NOT (Config.ExternalPump) AND NOT (Ctrl.V_Pneumatic)),
         PT := Config.PumpPauseDuration
      );

      #TON_PumpWork(
         IN := (NOT (Config.ExternalPump) AND Ctrl.V_Pneumatic),
         PT := Config.PumpWorkDuration
      );

      IF (NOT (Sts.PumpPauseDone) OR Config.ExternalPump) THEN
         Sts.PumpWorkDone := FALSE;
      ELSIF TON_PumpWork.Q THEN
         Sts.PumpWorkDone := TRUE;
      END_IF;
      IF (Sts.PumpWorkDone OR Config.ExternalPump) THEN
         Sts.PumpPauseDone := FALSE;
      ELSIF TON_PumpPause.Q THEN
         Sts.PumpPauseDone := TRUE;
      END_IF;
   END_REGION

   REGION "Pump job counter add"
      IF (Sts.PumpWorkDone OR CIn.ExternalPumpCycleDone) THEN
         PersistentValues.Data.PumpJobCounter := (PersistentValues.Data.PumpJobCounter + 1);
      END_IF;
   END_REGION

   REGION "Request of pump cycle due to jobs to start reached"
      IF ((PersistentValues.Data.PumpJobCounter >= PersistentValues.Par.OilPumpCycles) OR CutBechChanged OR Ctrl.ManStart) THEN
         PersistentValues.Data.JobsCounter := 0;
      END_IF;
      IF 0 THEN
         Sts.LubNormCycleReq := FALSE;
      ELSIF (PersistentValues.Data.JobsCounter >= PersistentValues.Par.JobsToStart) THEN
         Sts.LubNormCycleReq := TRUE;
      END_IF;
   END_REGION

   REGION "Run condition"
      Sts.Condition := (((((NOT (Ctrl.StopDoorOpen) AND NOT (Ctrl.StopSafe)) AND NOT (Ctrl.StopInPhase)) AND NOT (Ctrl.StopProgrammed)) AND NOT (Sts.AlarmsPresence)) AND PersistentValues.Par.SystemOffOn);
   END_REGION

   REGION "Aut Start"
      Ctrl.AutStart := (((AreaInterface.Man OR AreaInterface.Aut) AND Sts.LubNormCycleReq) AND Sts.Condition);
   END_REGION

   REGION "Man Start"
      IF (DataIn.PbStop OR NOT (AreaInterface.Man) OR Ctrl.AutStart OR NOT (Sts.Condition)) THEN
         Ctrl.ManStart := FALSE;
      ELSIF PosEdge(DataIn.PbStart) THEN
         Ctrl.ManStart := TRUE;
      END_IF;
   END_REGION

   REGION "Machine is standstill"
      Sts.IsStandstill := NOT (((NOT (Ctrl.ManStart) AND NOT (Ctrl.ManStart)) AND NOT (Sts.LubNormCycleReq)));
   END_REGION

   REGION "Alarm presence"
      Sts.AlarmsPresence := NOT ((NOT (Alarm.LowTankLevel) AND NOT (Alarm.ConnectorUnplugged)));
   END_REGION

   REGION "Warning presence"
      Sts.WarningsPresence := NOT ((NOT (Warning.NoAutReady) AND NOT (Warning.SystemOff)));
   END_REGION

   REGION "Collect machine to area interface"
      // Status machine ready
      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmsPresence;
      // Status machine aborting
      MachineInterface.Aborting := Sts.AlarmsPresence;
      // Status Ack Stop in phase
      MachineInterface.AckStopInPhase := Ctrl.StopInPhase;
      // Status Ack Stop programmed
      MachineInterface.AckStopProgrammed := Ctrl.StopProgrammed ;
      // Status Motion standtill
      MachineInterface.MotionsStandStill := Sts.IsStandstill;
      // Status Alarm presence
      MachineInterface.AlarmsPresence := Sts.AlarmsPresence;
      // Status Warning presence
      MachineInterface.WarningPresence := Sts.WarningsPresence;

      // Warning machine not automatic ready
      IF AreaInterface.CheckAutReady AND NOT MachineInterface.AutReady THEN
        Warning.NoAutReady := TRUE;
      END_IF;

   END_REGION

   REGION "Data Out"
      Ctrl.V_Pneumatic := ((NOT ((NOT (Ctrl.ManStart) AND NOT (Ctrl.AutStart))) AND Sts.PumpPauseDone) OR (NOT ((NOT (Ctrl.ManStart) AND NOT (Ctrl.AutStart))) AND Config.ExternalPump));
      DataOut.PneumaticPumpSolenoidValve := ((NOT ((NOT (Ctrl.ManStart) AND NOT (Ctrl.AutStart))) AND Sts.PumpPauseDone) OR (NOT ((NOT (Ctrl.ManStart) AND NOT (Ctrl.AutStart))) AND Config.ExternalPump));
      DataOut.Lamp := NOT ((NOT (Ctrl.ManStart) AND NOT (Ctrl.AutStart)));
   END_REGION

   REGION "Coordination Out"
      COut.IsRunning := NOT ((NOT (Ctrl.ManStart) AND NOT (Ctrl.AutStart)));
      COut.ToolsJobCounter := (PersistentValues.Par.JobsToStart - PersistentValues.Data.JobsCounter);
      IF ((PersistentValues.Par.JobsToStart - PersistentValues.Data.JobsCounter) AND (COut.ToolsJobCounter < 0)) THEN
         COut.ToolsJobCounter := 0;
      END_IF;
      COut.PumpCycleCounter := (PersistentValues.Par.OilPumpCycles - PersistentValues.Data.PumpJobCounter);
   END_REGION


END_FUNCTION_BLOCK
