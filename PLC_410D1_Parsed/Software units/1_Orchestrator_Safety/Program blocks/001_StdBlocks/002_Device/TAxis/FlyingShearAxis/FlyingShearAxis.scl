FUNCTION_BLOCK "FlyingShearAxis"
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
AUTHOR : PM
FAMILY : Motion
VERSION : 1.05
   VAR_INPUT 
      AxisCtrl : "TAx_Pos_Ctrl";
      Drive : "TAx_DriveInterface";
      PowerEnable : Bool;
      PowerOffDelay : Time := T#10s;
      Simulation : Bool;
   END_VAR

   VAR_OUTPUT 
      AxisSts : "TAx_Fol_Sts";
      Alarm : "TAx_Alarms";
      Warning : "TAx_Warnings";
      Diag : "TO_Diagnostic";
      Infeed_REQ_ON : Bool;
   END_VAR

   VAR_IN_OUT 
      Axis {InstructionName := 'TO_SynchronousAxis'; LibVersion := '8.0'} : TO_SynchronousAxis;
      LeadAxis {InstructionName := 'TO_PositioningAxis'; LibVersion := '8.0'} : TO_PositioningAxis;
   END_VAR

   VAR 
      initDone : Bool;
      ReadAlarm { S7_SetPoint := 'False'} : "RW_SINAMICS_Par";
      ReadWarning { S7_SetPoint := 'False'} : "RW_SINAMICS_Par";
      POWER {InstructionName := 'MC_POWER'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_POWER;
      HOME {InstructionName := 'MC_HOME'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_HOME;
      MOVE_ABS {InstructionName := 'MC_MOVEABSOLUTE'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_MOVEABSOLUTE;
      MOVE_VELOCITY {InstructionName := 'MC_MOVEVELOCITY'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_MOVEVELOCITY;
      RESET {InstructionName := 'MC_RESET'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_RESET;
      HALT {InstructionName := 'MC_HALT'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_HALT;
      STOP {InstructionName := 'MC_STOP'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_STOP;
      GEARINPOS {InstructionName := 'MC_GEARINPOS'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_GEARINPOS;
      HALTGEAR {InstructionName := 'MC_HALT'; LibVersion := '8.0'} : MC_HALT;
      DETACH {InstructionName := 'MC_MOVESUPERIMPOSED'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_MOVESUPERIMPOSED;
      GOHOME {InstructionName := 'MC_MOVEABSOLUTE'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_MOVEABSOLUTE;
      Ctrl : Struct
         InfeedPower : Bool;
         PowerEnable : Bool;
         PowerOn : Bool;
         Home : Bool;
         HomePowerOn : Bool;
         MovePlus : Bool;
         MoveMinus : Bool;
         MoveAbs : Bool;
         SynchHaltRequired : Bool;
         Halt : Bool;
         Stop : Bool;
         FsEnable : Bool;
         MoveDirection : Int;
      END_STRUCT;
      Sts : Struct
         AxisSts { S7_SetPoint := 'False'} : "TAx_STATUSWORD";
         AxisFault { S7_SetPoint := 'False'} : "TAx_ERRORWORD";
         AxisWarning { S7_SetPoint := 'False'} : "TAx_WARNINGWORD";
         Standstill : Bool;
         GeneralConditions : Bool;
         RestartConditions : Bool;
         PowerPermit : Bool;
         HomingPermitted : Bool;
         MoveVelPlusPermitted : Bool;
         MoveVelMinusPermitted : Bool;
         MoveAbsPermitted : Bool;
         InPosition : Bool;
         FsPermitted : Bool;
         FsRunning : Bool;
         Synchronizing : Bool;
         NotSynchCommandRequired : Bool;
         SynchCommandRequired : Bool;
         SynchCommandPending : Bool;
         InSynch : Bool;
         AxisEnabled : Bool;
         ActualTarget : LReal;
      END_STRUCT;
      Simulate : Struct
         Active : Bool;
         Mode : UDInt;
         WriteReq : Bool;
      END_STRUCT;
      FSCore { ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FsCore";
      Local : Struct
         ErrorReached_SwLimitMinus : Bool;
         ErrorReached_SwLimitPlus : Bool;
         ErrorReached_HwLimitMinus : Bool;
         ErrorReached_HwLimitPlus : Bool;
         ErrorMC_Reset : Bool;
         ErrorMC_Power : Bool;
         ErrorMC_Home : Bool;
         ErrorMC_MoveVel : Bool;
         ErrorMC_MoveAbs : Bool;
         ErrorMC_Halt : Bool;
         ErrorMC_Stop : Bool;
         ErrorMC_GearInPos : Bool;
         ErrorMC_Detach : Bool;
         ErrorMC_GoHome : Bool;
      END_STRUCT;
      tonPowerOFF {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tofInfeedPowerRequest {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tonHaltTimeOut {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tofRestartActive {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tonErrWindow {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tonErrWindowTimeout {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      MoveVelVelocityChanged : Bool;
      MoveAbsTargetChanged : Bool;
      MoveAbsVelocityChanged : Bool;
      MoveVelOldVelocity : LReal;
      MoveAbsOldTargetPosition : LReal;
      MoveAbsOldTargetVelocity : LReal;
   END_VAR

   VAR_TEMP 
      MC_Home_Idle : Bool;
      AxDw : DWord;
      RetBool : Bool;
      RetInt : Int;
   END_VAR

   VAR CONSTANT 
      MAX_TIME : Time := T#2147483647ms;
      EXTRA_TIME : Time := T#20ms;
      HALT_TIMEOUT : Time := T#2S;
      FCT_WAIT_WORKPOS : USInt := 0;
      FCT_WAIT_START_SYNC : USInt := 1;
      FCT_WAIT_SYNC : USInt := 2;
      FCT_WAIT_ERR : USInt := 3;
      FCT_WAIT_CUT_DONE : USInt := 4;
      FCT_GO_HOME_1 : USInt := 5;
      FCT_GO_HOME_2 : USInt := 6;
      FCT_GO_HOME_3 : USInt := 7;
      FCT_STOP : USInt := 9;
      FCT_RESTART : USInt := 10;
   END_VAR


BEGIN
	
	//=============================================================================
	//PM FORMING
	//(c)Copyright 2017 All Rights Reserved
	//-----------------------------------------------------------------------------
	// Library: /
	// Tested with: /
	// Engineering: TIA Portal V17
	// Restrictions: -
	// Requirements: S7-1500
	// Functionality: Flying Shear Axis
	//
	// v0.0.1  15/06/2022
	// v0.0.2  06/07/2022
	// v0.0.3  19/08/2022
	// v0.0.4  27/10/2022 - FAK and Modulo added
	// v1.0.2  16/01/2023 - New version TIA V18
	// v1.0.4  27/03/2023 
	//         Add a new parameter in order to separate the advance time of execution 
	//         of gearinpos function (StartAdvance) used to compensate PLC delays, from
	//         the synchronization point space surplus (SyncLag) to compensate errors 
	//         in calculation of the ramp space
	// v1.0.5  28/12/2023
	//         Fix running with modulo lead axis 
	//         modify master velocity to StatusSynchronizedMotion.EffectiveLeadingValue.Position
	// v1.0.6  07/10/2024
	//         replaced "standstill" with "Velocity = 0" in Halt conditions
	// v1.0.7  29/10/2025
	//         added mc_halt (GEARHALT) to Desynchronize 
	//=============================================================================
	
	REGION Axis Status
	    //=============================================================
	    // Get TAxis faults 
	    //=============================================================
	    #AxDw := #Axis.ErrorWord;
	    SCATTER(IN := #AxDw.%W0,
	            OUT => #Sts.AxisFault);
	    
	    //=============================================================
	    // Get TAxis warnings
	    //=============================================================
	    #AxDw := #Axis.WarningWord;
	    SCATTER(IN := #AxDw.%W0,
	            OUT => #Sts.AxisWarning);
	    //Overwrite Drive warning bit from telegram
	    IF #Axis.Actor.Interface.AddressIn.AREA = 16#0081 THEN
	        #Sts.AxisWarning.DriveWarning := PEEK_BOOL(area := #Axis.Actor.Interface.AddressIn.AREA,
	                                         dbNumber := #Axis.Actor.Interface.AddressIn.DB_NUMBER,
	                                         byteOffset := UDINT_TO_INT(#Axis.Actor.Interface.AddressIn.OFFSET / 8) + 1,
	                                         bitOffset := 7);
	    END_IF;
	        
	    //=============================================================
	    // Build status of TAxis Object
	    //=============================================================
	    #AxDw := #Axis.StatusWord;
	    SCATTER(IN := #AxDw,
	            OUT => #Sts.AxisSts);
	    
	    //Standstill
	    #Sts.Standstill := #Sts.AxisSts.Standstill;
	    
	END_REGION
	
	
	REGION Alarms
	    //=============================================================
	    // Reset
	    //=============================================================
	    IF #AxisCtrl.Rst OR #RESET.Done THEN
	        
	        #Local.ErrorReached_SwLimitMinus := FALSE;
	        #Local.ErrorReached_SwLimitPlus := FALSE;
	        #Local.ErrorReached_HwLimitMinus := FALSE;
	        #Local.ErrorReached_HwLimitPlus := FALSE;
	        
	        #Local.ErrorMC_Reset := FALSE;
	        #Local.ErrorMC_Power := FALSE;
	        #Local.ErrorMC_Home := FALSE;
	        #Local.ErrorMC_MoveVel := FALSE;
	        #Local.ErrorMC_MoveAbs := FALSE;
	        #Local.ErrorMC_GearInPos := FALSE;
	        #Local.ErrorMC_Halt := FALSE;
	        #Local.ErrorMC_Stop := FALSE;
	        #Local.ErrorMC_Detach := FALSE;
	        #Local.ErrorMC_GoHome := FALSE;
	        
	    END_IF;
	    
	    //==============================================================
	    // TO Axis alarm presence
	    //============================================================= 
	    IF #Sts.AxisSts.Error  THEN
	        #Alarm.TOAxis := #Axis.ErrorDetail.Reaction > 0;
	        #Diag.TO_Message := #Axis.ErrorDetail.Number;
	    ELSE
	        #Alarm.TOAxis := FALSE;
	        #Diag.TO_Message := 0;
	    END_IF; 
	    
	    //=============================================================
	    // Drive Alarm presence
	    //=============================================================
	    #Alarm.Drive := #Sts.AxisFault.DriveFault;
	    
	    //=============================================================
	    // Limits alarms
	    //=============================================================
	    IF #Sts.AxisSts.SW_NegativeLimitSwitch THEN
	        #Local.ErrorReached_SwLimitMinus := TRUE;
	    END_IF;
	    IF #Sts.AxisSts.SW_PositiveLimitSwitch THEN
	        #Local.ErrorReached_SwLimitPlus := TRUE;
	    END_IF;
	    IF #Sts.AxisSts.HW_NegativeLimitSwitch THEN
	        #Local.ErrorReached_HwLimitMinus := TRUE;
	    END_IF;
	    IF #Sts.AxisSts.HW_PositiveLimitSwitch THEN
	        #Local.ErrorReached_HwLimitPlus := TRUE;
	    END_IF;
	    
	    #Alarm.LimitMinus := #Local.ErrorReached_SwLimitMinus OR #Local.ErrorReached_HwLimitMinus;
	    #Alarm.LimitPlus := #Local.ErrorReached_SwLimitPlus OR #Local.ErrorReached_HwLimitPlus;
	    
	    //=============================================================
	    // MC Errors
	    //=============================================================
	    IF #RESET.Error THEN
	        #Local.ErrorMC_Reset := TRUE;
	        #Diag.#MC_Message := #RESET.ErrorId;
	    END_IF;
	    IF #POWER.Error THEN
	        #Local.ErrorMC_Power := TRUE;
	        #Diag.#MC_Message := #POWER.ErrorId;
	    END_IF;
	    IF #HOME.Error THEN
	        #Local.ErrorMC_Home := TRUE;
	        #Diag.#MC_Message := #HOME.ErrorId;
	    END_IF;
	    IF #MOVE_VELOCITY.Error THEN
	        #Local.ErrorMC_MoveVel := TRUE;
	        #Diag.#MC_Message := #MOVE_VELOCITY.ErrorId;
	    END_IF;
	    IF #MOVE_ABS.Error THEN
	        #Local.ErrorMC_MoveAbs := TRUE;
	        #Diag.#MC_Message := #MOVE_ABS.ErrorId;
	    END_IF;
	    IF #GEARINPOS.Error THEN
	        #Local.ErrorMC_GearInPos := TRUE;
	        #Diag.#MC_Message := #GEARINPOS.ErrorId;
	    END_IF;
	    IF #HALT.Error THEN
	        #Local.ErrorMC_Halt := TRUE;
	        #Diag.#MC_Message := #HALT.ErrorId;
	    END_IF;
	    IF #HALTGEAR.Error THEN
	        #Local.ErrorMC_Halt := TRUE;
	        #Diag.#MC_Message := #HALTGEAR.ErrorId;
	    END_IF;
	    IF #STOP.Error THEN
	        #Local.ErrorMC_Stop := TRUE;
	        #Diag.#MC_Message := #STOP.ErrorId;
	    END_IF;
	    IF #DETACH.Error THEN
	        #Local.ErrorMC_Detach := TRUE;
	        #Diag.#MC_Message := #DETACH.ErrorId;
	    END_IF;
	    IF #GOHOME.Error THEN
	        #Local.ErrorMC_GoHome := TRUE;
	        #Diag.#MC_Message := #GOHOME.ErrorId;
	    END_IF;
	    
	    #Alarm.MCFunction := #Local.ErrorMC_Reset
	    OR #Local.ErrorMC_Power
	    OR #Local.ErrorMC_Home
	    OR #Local.ErrorMC_MoveVel
	    OR #Local.ErrorMC_MoveAbs
	    OR #Local.ErrorMC_GearInPos
	    OR #Local.ErrorMC_Halt
	    OR #Local.ErrorMC_Stop
	    OR #Local.ErrorMC_Detach
	    OR #Local.ErrorMC_GoHome;
	    
	    IF NOT #Alarm.MCFunction THEN
	        #Diag.MC_Message := 0;
	    END_IF;
	    
	    #Diag.ErrorReached_SwLimitMinus := #Local.ErrorReached_SwLimitMinus;
	    #Diag.ErrorReached_SwLimitPlus := #Local.ErrorReached_SwLimitPlus;
	    #Diag.ErrorReached_HwLimitMinus := #Local.ErrorReached_HwLimitMinus;
	    #Diag.ErrorReached_HwLimitPlus := #Local.ErrorReached_HwLimitPlus;
	    #Diag.ErrorMC_Reset := #Local.ErrorMC_Reset;
	    #Diag.ErrorMC_Power := #Local.ErrorMC_Power;
	    #Diag.ErrorMC_Home := #Local.ErrorMC_Home;
	    #Diag.ErrorMC_MoveVel := #Local.ErrorMC_MoveVel;
	    #Diag.ErrorMC_MoveAbs := #Local.ErrorMC_MoveAbs OR #Local.ErrorMC_GoHome;;
	    #Diag.ErrorMC_Halt := #Local.ErrorMC_Halt;
	    #Diag.ErrorMC_Stop := #Local.ErrorMC_Stop;
	    #Diag.ErrorMC_GearInPos := #Local.ErrorMC_GearInPos;
	    #Diag.ErrorMC_MoveSuperImp := #Local.ErrorMC_Detach;
	
	    #Diag.MC_ErrorPresence := #Alarm.MCFunction;
	    #Diag.TO_ErrorPresence := #Alarm.TOAxis;    
	
	    //=============================================================
	    // Warning
	    //=============================================================
	    #Warning.Drive := #Sts.AxisWarning.DriveWarning;
	    
	    #Warning.TOAxis := #Axis.WarningWord <> 0;
	    
	END_REGION
	
	
	REGION Drive Dignostic
	    
	    #Diag.DeviceType := 15;
	    
	    IF #Drive.AccessPoint > 0 AND #Drive.TokenChain > 0 THEN
	        
	        #ReadAlarm(Enable := #Sts.AxisFault.DriveFault,
	                   ReadWrite := 0,
	                   ParNo := 2131,
	                   Index := 0,
	                   AxisNo := #Drive.AxisID,
	                   HW_ID := #Drive.AccessPoint,
	                   "TokenChain" := #Drive.TokenChain);
	        
	        #ReadWarning(Enable := #Sts.AxisWarning.DriveWarning AND NOT #Sts.AxisFault.DriveFault,
	                     ReadWrite := 0,
	                     ParNo := 2132,
	                     Index := 0,
	                     AxisNo := #Drive.AxisID,
	                     HW_ID := #Drive.AccessPoint,
	                     "TokenChain" := #Drive.TokenChain);
	        
	        
	        IF #Sts.AxisFault.DriveFault THEN
	            IF #ReadAlarm.Done THEN
	                #Diag.Drive_Message := REAL_TO_UINT(#ReadAlarm.ValueReadReal);
	            END_IF;
	        ELSIF #Sts.AxisWarning.DriveWarning THEN
	            IF #ReadWarning.Done THEN
	                #Diag.Drive_Message := REAL_TO_UINT(#ReadWarning.ValueReadReal);
	            END_IF;
	        ELSE
	            #Diag.Drive_Message := 0;
	        END_IF;
	    ELSE
	        #Diag.Drive_Message := 0;
	    END_IF;
	    
	    IF #Alarm.TOAxis OR #Alarm.MCFunction OR #Alarm.Drive THEN
	        #Diag.MessageType := 2;
	    ELSIF #Warning.TOAxis OR #Warning.Drive THEN
	        #Diag.MessageType := 1;
	    ELSE
	        #Diag.MessageType := 0;
	    END_IF;
	    
	END_REGION
	
	REGION Conditions
	    //=============================================================
	    // General condition to execute MC operation
	    //=============================================================
	    #Sts.GeneralConditions := NOT #AxisCtrl.SafeStop
	                            AND NOT #Alarm.TOAxis
	                            AND NOT #Alarm.MCFunction;
	END_REGION
	
	REGION Simulation
	    
	    #Simulate.Active := #Sts.AxisSts.AxisSimulation AND #Axis.VirtualAxis.Mode = 0;
	    
	    IF #Axis.VirtualAxis.Mode = 0 THEN
	        
	        IF #Simulation <> #Simulate.Active AND NOT #Diag.TO_RestartActive THEN
	            IF #Simulation = TRUE THEN
	                #Simulate.Mode := 1;
	            ELSE
	                #Simulate.Mode := 0;
	            END_IF;
	            #Simulate.WriteReq := TRUE;
	        END_IF;
	        
	        #RetInt := WRIT_DBL(REQ := #Simulate.WriteReq, SRCBLK := #Simulate.Mode, BUSY => #RetBool, DSTBLK => #Axis.Simulation.Mode);
	        
	        IF #RetInt = 16#7002 AND #Simulate.WriteReq THEN
	            #Simulate.WriteReq := FALSE;
	            #Diag.TO_RestartCmd := TRUE;
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	REGION Flying Shear
	
	    #Sts.FsPermitted := NOT #Sts.AxisSts.HomingCommand
	                        AND #Sts.AxisSts.HomingDone
	                        AND NOT #Ctrl.MovePlus
	                        AND NOT #Ctrl.MoveMinus
	                        AND #Sts.GeneralConditions;
	
	
	    IF NOT #Sts.FsPermitted AND #Sts.FsRunning THEN 
	        #FSCore.Sts.NotPermitted := TRUE;
	        #FSCore.Fct := #FCT_STOP; 
	        #Ctrl.FsEnable:= FALSE; 
	    END_IF;
	
	    // Flying Shear Init
	    IF NOT #initDone THEN
	        "FS_INIT"(LeadAx:=#LeadAxis,
	                  FollowAx:=#Axis,
	                  Core:=#FSCore);
	        // Set <TO>.Extrapolation.FollowingAxisDependentTime of lead axis
	        IF #LeadAxis.Extrapolation.FollowingAxisDependentTime = 0.0 THEN
	             #LeadAxis.Extrapolation.FollowingAxisDependentTime := #Axis.StatusPositioning.SetpointExecutionTime;
	        END_IF;
	        #initDone := TRUE;
	    END_IF;
	
	     // Calcolo Posizioni
	     #FSCore.MasterPosition     := #Axis.StatusSynchronizedMotion.EffectiveLeadingValue.Position; // "Fs.ActualPosition"(#LeadAxis);
	     #FSCore.SlavePosition      := "Fs_ActualPosition"(#Axis);
	     #FSCore.MaterialPosition   := #FSCore.MasterPosition-#FSCore.SlavePosition;
	     #FSCore.MasterVelocity     := #LeadAxis.StatusExtrapolation.FilteredVelocity * #FSCore.MasterExtraSpeed * #FSCore."K_mV_TO_m/s";
	     #FSCore.SlaveVelocity      := #Axis.Velocity * #FSCore."K_sV_TO_m/s";
	     #FSCore.SlaveAcceleration  := #Axis.Acceleration * #FSCore."K_sA_TO_m/s^2";
	     #FSCore.Sts.Standstill     := #Sts.AxisSts.Standstill;
	
	    // Conversione parametri a SI
	     #FSCore.Par_SI.Acc := #FSCore.Acc * #FSCore."K_sA_TO_m/s^2";
	     #FSCore.Par_SI.Jerk := #FSCore.Jerk / #FSCore."K_m/s^3_TO_sJ";
	 
	    // Controllo errore di inseguimento
	    #tonErrWindow.TON(IN := ABS(#Axis.StatusPositioning.FollowingError) <= #FSCore.ErrWindow,
	                      PT := #FSCore.ErrDwellTime);
	
	    // Eventi Asincroni
	    IF NOT #Ctrl.FsEnable AND (#Sts.FsRunning OR #FSCore.Sts.NotPermitted) THEN
	        #FSCore.Fct := #FCT_STOP;   
	    END_IF;
	
	    REGION State machine
	    //  Fasi del Taglio al volo   
	
	     // Attesa abilitazione e posizione di lavoro valida
	    
	    IF #FSCore.Fct = #FCT_WAIT_WORKPOS THEN
	        #Sts.FsRunning := #Ctrl.FsEnable AND #Sts.AxisEnabled;
	        IF #Sts.FsRunning THEN
	            IF #FSCore.iStartTrigger THEN
	                #FSCore.iStartTrigger := FALSE;
	                #FSCore.iWorkPosition := #FSCore.WorkPosition;
	             IF NOT "Fs_CalcSyncPositions"(#FSCore) THEN
	                 #FSCore.Fct := #FCT_WAIT_START_SYNC;
	             ELSE
	                 #FSCore.Sts.NotReachable := TRUE;
	                 #FSCore.Fct := #FCT_STOP;
	             END_IF;
	            END_IF;
	        END_IF;
	    END_IF;
	
	    // Attesa spazio rampa
	     IF #FSCore.Fct = #FCT_WAIT_START_SYNC THEN
	         IF "Fs_CalcSyncPositions"(#FSCore ) THEN
	             #GEARINPOS.MasterSyncPosition := #FSCore.iMasterSyncPos;
	             #GEARINPOS.SlaveSyncPosition := #FSCore.iSlaveSynchPos;
	             #GEARINPOS.MasterStartDistance := #FSCore.iMasterSynchSpace;
	             #GEARINPOS.SyncProfileReference :=0;
	             #GEARINPOS.Acceleration := #FSCore.Acc;
	             #GEARINPOS.Deceleration := #FSCore.Acc;
	             #GEARINPOS.Velocity := #LeadAxis.StatusExtrapolation.FilteredVelocity * #FSCore.MasterExtraSpeed
	                                    + #Axis.DynamicLimits.MaxVelocity * (#FSCore.MasterExtraSpeed - 1.0);
	             #GEARINPOS.Jerk := #FSCore.iJerkToUse * #FSCore."K_m/s^3_TO_sJ";
	             #GEARINPOS.RatioNumerator := LREAL_TO_DINT( #FSCore.FAK * 1000000.0);
	             #GEARINPOS.RatioDenominator := 1000000;
	             #FSCore.Fct := #FCT_WAIT_SYNC;
	         END_IF;
	         
	     END_IF; 
	
	     // Attesa sincronismo
	     IF #FSCore.Fct = #FCT_WAIT_SYNC THEN
	         IF #FSCore.MasterPosition > #FSCore.iMasterSyncPos AND NOT (#GEARINPOS.StartSync OR #GEARINPOS.InSync) THEN
	            IF (#FSCore.AxMODULO = 0)
	                OR (#FSCore.MasterPosition - #FSCore.iMasterSyncPos) < (#FSCore.AxMODULO / 2.0)
	            THEN
	                #FSCore.Sts.NotSynched := TRUE;
	                #FSCore.Fct := #FCT_STOP;
	            END_IF;
	         END_IF;
	         // Check for master standstill
	         IF #LeadAxis.StatusWord.%X7 THEN
	             #FSCore.Sts.NotSynched := TRUE;
	             #FSCore.Fct := #FCT_STOP;
	         END_IF;
	         IF #GEARINPOS.Error THEN
	             #FSCore.Fct := #FCT_STOP;
	         END_IF;
	         IF #GEARINPOS.InSync THEN
	             #FSCore.Fct := #FCT_WAIT_ERR;
	         END_IF;
	     END_IF;
	
	    // Attesa errore di inseguimento nei limiti
	    #tonErrWindowTimeout.TON(IN:= #FSCore.Fct = #FCT_WAIT_ERR,PT := #FSCore.ErrTimeout);
	
	     IF #FSCore.Fct = #FCT_WAIT_ERR THEN
	        IF #tonErrWindow.Q OR #tonErrWindowTimeout.Q
	        THEN
	            #FSCore.OKTAG := TRUE;
	            #FSCore.Sts.ErrTimeout := #tonErrWindowTimeout.Q;
	            #FSCore.Fct := #FCT_WAIT_CUT_DONE;
	        END_IF;
	     END_IF;
	 
	    // Attesa lavorazione eseguita
	     IF #FSCore.Fct = #FCT_WAIT_CUT_DONE THEN
	         #Sts.FsRunning := #Ctrl.FsEnable AND #Sts.AxisEnabled;
	         IF NOT #FSCore.OKTAG AND #Sts.FsRunning THEN                                    
	             #GOHOME.Velocity := #FSCore.HomeVelocity;
	             #GOHOME.Position := #FSCore.HomePos;
	             #GOHOME.Jerk := #FSCore.Par_SI.Jerk * 1000.0;
	             #DETACH.Execute := FALSE;
	             IF #Sts.Standstill THEN
	                #GOHOME.Execute := TRUE;
	                #FSCore.#Fct    := #FCT_WAIT_WORKPOS;
	             ELSE
	                #HALTGEAR.Execute   := TRUE;
	                #FSCore.#Fct        := #FCT_GO_HOME_1;
	             END_IF;   
	
	         END_IF;
	     END_IF;
	
	
	     IF  #FSCore.Fct >= #FCT_GO_HOME_1 AND #FSCore.Fct <=#FCT_GO_HOME_2 THEN
	         
	         // Attesa DIMEZZAMENTO velocità
	         IF #FSCore.Fct = #FCT_GO_HOME_1 AND
	              #Axis.Velocity < #LeadAxis.Velocity / 2.0 THEN
	              #GOHOME.Execute := TRUE;
	              #GOHOME.Jerk := 0.0;
	              #FSCore.Fct := #FCT_GO_HOME_2;
	          END_IF;
	          // Attesa inversione velocità
	          IF  #FSCore.Fct = #FCT_GO_HOME_2 AND
	              #Axis.Velocity < 0.0 THEN
	              #GOHOME.Execute := TRUE;
	              #GOHOME.Jerk := #FSCore.Par_SI.Jerk * 1000.0;
	              #FSCore.Fct := #FCT_WAIT_WORKPOS;
	          END_IF;
	          
	          // Controlla se caso di riagganciare
	          IF #FSCore.iStartTrigger THEN
	              #FSCore.iWorkPosition := #FSCore.WorkPosition;
	              IF "Fs_CalcSyncPositions"(#FSCore )
	                  AND NOT #GEARINPOS.Busy THEN
	                  #FSCore.iStartTrigger := FALSE;
	                  #FSCore.Fct := #FCT_WAIT_START_SYNC;
	              END_IF;
	          END_IF;
	      END_IF;
	
	    // Stop 
	    IF #FSCore.Fct = #FCT_STOP THEN
	        #GOHOME.Execute := FALSE;
	        #DETACH.Execute := FALSE;
	        #FSCore.OKTAG := FALSE;
	        #Ctrl.FsEnable := FALSE;
	        #Sts.FsRunning := FALSE;     
	        #FSCore.Fct := #FCT_RESTART;          
	    END_IF;
	
	    // Wait Restart Conditions
	    IF #FSCore.Fct = #FCT_RESTART THEN
	      IF #Ctrl.FsEnable OR NOT
	         (  #FSCore.Sts.NotReachable 
	         OR #FSCore.Sts.NotSynched
	         OR #FSCore.Sts.NotPermitted )  
	      THEN
	        #FSCore.Sts.NotReachable    :=
	        #FSCore.Sts.NotSynched      :=
	        #FSCore.Sts.NotPermitted    :=
	        #FSCore.Sts.ErrTimeout      := FALSE;  
	        #FSCore.Fct := #FCT_WAIT_WORKPOS;
	      END_IF;
	    END_IF;
	   
	    END_REGION
	
	    REGION Motion Control
	    #GEARINPOS( Execute := (#FSCore.Fct >= #FCT_WAIT_SYNC) AND (#FSCore.Fct <= #FCT_WAIT_CUT_DONE),
	                Master:=#LeadAxis,
	                Slave:=#Axis,
	                SyncDirection := 1);
	
	    #DETACH(Axis:=#Axis,
	            Acceleration:=#FSCore.Acc,
	            Deceleration:=#FSCore.Acc,
	            Jerk:=#FSCore.Par_SI.Jerk * 1000.0);
	
	    #HALTGEAR(Axis:=#Axis,
	              Deceleration:=#FSCore.Acc,
	              Jerk:=#FSCore.Par_SI.Jerk * 1000.0,
	              AbortAcceleration:=TRUE);
	
	    #GOHOME(Axis := #Axis,
	            Acceleration := #FSCore.Acc,
	            Deceleration := #FSCore.Acc);
	
	        // Reset MC execute trigger
	        #DETACH.Execute     :=FALSE;
	        #HALTGEAR.Execute   := FALSE;   
	        #GOHOME.Execute     :=FALSE;    
	    
	    END_REGION
	
	
	END_REGION
	
	
	
	REGION Reset
	    //=============================================================
	    // Axis restart active
	    //=============================================================
	    #tofRestartActive.TOF(IN := #Sts.AxisSts.RestartActive,
	                          PT := T#1S);
	    
	    //=============================================================
	    // Axis restart conditions
	    //=============================================================
	    #Sts.RestartConditions := NOT (#AxisCtrl.Power
	                                OR #AxisCtrl.MovePlus
	                                OR #AxisCtrl.MoveMinus
	                                OR (#AxisCtrl.Homing AND #Ctrl.HomePowerOn)
	                                OR #AxisCtrl.MoveAbsolute
	                                OR #AxisCtrl.ExtControl
	                                OR #MOVE_VELOCITY.Busy
	                                OR #MOVE_ABS.Busy
	                                OR #HALT.Busy
	                                OR #STOP.Busy)
	                                AND #Sts.Standstill
	                                AND NOT #AxisCtrl.Rst
	                                AND NOT #tofRestartActive.Q;
	
	    //=============================================================
	    // Axis reset
	    //=============================================================
	    #RESET(Axis := #Axis,
	           Execute := #AxisCtrl.Rst OR ((#AxisCtrl.RstHW OR #Diag.TO_RestartCmd) AND #Sts.RestartConditions),
	           Restart := (#AxisCtrl.RstHW OR #Diag.TO_RestartCmd) AND #Sts.RestartConditions);
	
	    IF NOT #RESET.Busy THEN
	        #Diag.TO_RestartCmd := FALSE;
	    END_IF;
	
	END_REGION
	
	REGION Power
	    //=============================================================
	    // Power permit
	    //=============================================================
	    #Sts.PowerPermit := NOT #AxisCtrl.SafeStop
	                        AND #Drive.Infeed_ON
	                        AND NOT #Alarm.TOAxis
	                        AND NOT #Local.ErrorMC_Power;
	
	    //=============================================================
	    // Power command during home
	    //=============================================================   
	    #Ctrl.HomePowerOn := (#AxisCtrl.HomeMode = 3 OR #AxisCtrl.HomeMode = 5);
	
	    //=============================================================
	    // Power command
	    //=============================================================
	    #Ctrl.PowerEnable := (#AxisCtrl.Power
	                        OR #AxisCtrl.MovePlus 
	                        OR #AxisCtrl.MoveMinus
	                        OR (#AxisCtrl.Homing AND #Ctrl.HomePowerOn)
	                        OR #AxisCtrl.MoveAbsolute
	                        OR #Ctrl.FsEnable
	                        OR #MOVE_VELOCITY.Busy
	                        OR #MOVE_ABS.Busy
	                        OR #GEARINPOS.Busy
	                        OR #HALT.Busy
	                        OR #STOP.Busy
	                        OR #DETACH.Busy
	                        OR #GOHOME.Busy)
	                        AND #Sts.PowerPermit;    
	    //=============================================================
	    // Delay OFF Power
	    //=============================================================
	    
	    #tonPowerOFF.TON(IN := NOT #Ctrl.PowerEnable AND #Ctrl.PowerOn,
	                     PT := #PowerOffDelay);
	    
	    IF #tonPowerOFF.Q OR (NOT #Sts.PowerPermit AND #Sts.Standstill) OR NOT #PowerEnable THEN
	        #Ctrl.PowerOn := FALSE;
	    ELSIF #Ctrl.PowerEnable THEN
	        #Ctrl.PowerOn := TRUE;
	    END_IF;
	    
	    //=============================================================
	    // MC Power
	    //=============================================================
	    #POWER(Axis := #Axis,
	           Enable := #Ctrl.PowerOn,
	           StartMode := 1,
	           StopMode := 2);
	    
	    #Sts.AxisEnabled := #POWER.Status AND #Sts.AxisSts.Enable;
	    
	    //=============================================================
	    // Power request to INFEED
	    //=============================================================
	    #Ctrl.InfeedPower := #AxisCtrl.Power
	                        OR #AxisCtrl.MovePlus 
	                        OR #AxisCtrl.MoveMinus
	                        OR (#AxisCtrl.Homing AND #Ctrl.HomePowerOn)
	                        OR #AxisCtrl.MoveAbsolute
	                        OR #AxisCtrl.ExtControl
	                        OR #Ctrl.FsEnable
	                        OR #Ctrl.PowerOn;
	      
	    #tofInfeedPowerRequest.TOF(IN := #Ctrl.InfeedPower,
	                      PT := T#300MS,
	                      Q => #Infeed_REQ_ON );
	
	END_REGION
	
	
	
	
	REGION Home
	    //=============================================================
	    // Home permitted
	    //=============================================================
	    #MC_Home_Idle := NOT #HOME.Busy AND NOT #HOME.Error AND NOT #HOME.Done;
	 
	    #Sts.HomingPermitted := NOT #Sts.AxisSts.PositioningCommand
	                            AND (NOT #Sts.AxisSts.VelocityCommand OR #AxisCtrl.HomeMode = 0)
	                            AND NOT #Sts.AxisSts.Synchronous
	                            AND NOT #Sts.AxisSts.Synchronizing
	                            AND (NOT #AxisCtrl.SafeStop OR NOT #Ctrl.HomePowerOn)
	                            AND NOT #Alarm.TOAxis
	                            AND NOT #Local.ErrorMC_Home
	                            AND (#MC_Home_Idle OR #Ctrl.Home);
	
	    //=============================================================
	    // Home Command
	    //=============================================================
	    #Ctrl.Home :=   #AxisCtrl.Homing
	                    AND (#Sts.AxisEnabled OR NOT #Ctrl.HomePowerOn)
	                    AND #Sts.HomingPermitted;
	
	    //=============================================================
	    // MC Home
	    //=============================================================
	    #HOME(Axis := #Axis,
	          Execute := #Ctrl.Home,
	          Position := #AxisCtrl.HomePosition,
	          Mode := #AxisCtrl.HomeMode);
	END_REGION
	
	REGION Move Velocity
	    //=============================================================
	    // Speed change
	    //=============================================================
	    #MoveVelVelocityChanged := ABS(#AxisCtrl.Velocity - #MoveVelOldVelocity) > #Axis.StandstillSignal.VelocityThreshold ;
	    IF #MoveVelVelocityChanged THEN
	        #MoveVelOldVelocity := #AxisCtrl.Velocity;
	    END_IF;
	
	    //=============================================================
	    // Move Bkw permitted
	    //=============================================================
	    #Sts.MoveVelMinusPermitted :=  NOT #Sts.AxisSts.HomingCommand
	                                AND NOT #Ctrl.FsEnable 
	                                AND NOT #Ctrl.MovePlus
	                                AND NOT #Ctrl.MoveAbs
	                                AND NOT #Alarm.LimitMinus
	                                AND #Sts.GeneralConditions;
	                                
	    //=============================================================
	    // Move Bkw Command
	    //=============================================================
	    #Ctrl.MoveMinus := #AxisCtrl.MoveMinus
	                    AND #Sts.MoveVelMinusPermitted
	                    AND #Sts.AxisEnabled;
	
	    //=============================================================
	    // Move Fwd permitted
	    //=============================================================
	    #Sts.MoveVelPlusPermitted :=  NOT #Sts.AxisSts.HomingCommand
	                                AND NOT #Ctrl.FsEnable 
	                                AND NOT #Ctrl.MoveMinus
	                                AND NOT #Ctrl.MoveAbs
	                                AND NOT #Alarm.LimitPlus
	                                AND #Sts.GeneralConditions;
	
	    //=============================================================
	    // Move Fwd Command
	    //=============================================================
	    #Ctrl.MovePlus := #AxisCtrl.MovePlus
	                    AND #Sts.MoveVelPlusPermitted
	                    AND #Sts.AxisEnabled;
	                
	    //=============================================================
	    // Move direction
	    //=============================================================
	    IF #Ctrl.MovePlus THEN
	        #Ctrl.MoveDirection := 1;
	    END_IF;
	    
	    IF #Ctrl.MoveMinus THEN
	        #Ctrl.MoveDirection := 2;
	    END_IF;
	    //=============================================================
	    // Main
	    //=============================================================
	    #MOVE_VELOCITY(Axis := #Axis,
	                   Execute := (#Ctrl.MovePlus OR #Ctrl.MoveMinus) AND NOT #MoveVelVelocityChanged,
	                   Velocity := #AxisCtrl.Velocity,
	                   Acceleration := #AxisCtrl.Acceleration,
	                   Deceleration := #AxisCtrl.Deceleration,
	                   Jerk := #AxisCtrl.Jerk,
	                   PositionControlled := #AxisCtrl.VelocityPositionControlled,
	                   Direction := #Ctrl.MoveDirection,
	                   Current := FALSE);
	END_REGION
	
	
	
	REGION Move Absolute
	    //=============================================================
	    // Target position changed
	    //=============================================================
	    #MoveAbsTargetChanged := ABS(#AxisCtrl.MoveAbsTarget - #MoveAbsOldTargetPosition) > #Axis.PositioningMonitoring.Window;
	    IF #MoveAbsTargetChanged THEN
	        #MoveAbsOldTargetPosition := #AxisCtrl.MoveAbsTarget;
	    END_IF;
	    //=============================================================
	    // Target velocity changed
	    //=============================================================
	    #MoveAbsVelocityChanged := ABS(#AxisCtrl.Velocity - #MoveAbsOldTargetVelocity) > #Axis.StandstillSignal.VelocityThreshold ;
	    IF  #MoveAbsVelocityChanged THEN
	        #MoveAbsOldTargetVelocity := #AxisCtrl.Velocity;
	    END_IF;
	    
	    //=============================================================
	    // Positioning permitted
	    //=============================================================
	    #Sts.MoveAbsPermitted := NOT #Sts.AxisSts.HomingCommand
	                            AND NOT #Ctrl.FsEnable
	                            AND #Sts.AxisSts.HomingDone
	                            AND #Sts.GeneralConditions;
	            
	    //=============================================================
	    // Move absolute Command
	    //=============================================================
	    #Ctrl.MoveAbs :=  #AxisCtrl.MoveAbsolute
	                    AND #Sts.MoveAbsPermitted
	                    AND #Sts.AxisEnabled;
	           
	    //=============================================================
	    // MC Move absolute
	    //=============================================================
	    #MOVE_ABS(Axis := #Axis,
	              Execute := #Ctrl.MoveAbs AND  NOT #MoveAbsTargetChanged AND NOT #MoveAbsVelocityChanged,
	              Position := #AxisCtrl.MoveAbsTarget,
	              Velocity := #AxisCtrl.Velocity,
	              Acceleration := #AxisCtrl.Acceleration,
	              Deceleration := #AxisCtrl.Deceleration,
	              Jerk := #AxisCtrl.Jerk,
	              Direction := #AxisCtrl.MoveAbsDirection);
	    
	END_REGION
	
	
	REGION Stop
	    
	    //=============================================================
	    // Stop command
	    //=============================================================
	    #Sts.SynchCommandRequired := #Ctrl.FsEnable;
	    #Sts.SynchCommandPending := #Axis.StatusSynchronizedMotion.WaitingFunctionState > 0;
	    
	    #Ctrl.Stop := ((#Sts.SynchCommandPending AND NOT #Sts.SynchCommandRequired AND #Sts.Standstill) OR
	    ((#HALT.Error OR #tonHaltTimeOut.Q) AND NOT #Sts.Standstill))
	    AND NOT #STOP.CommandAborted
	    AND NOT #STOP.Error
	    AND #Sts.AxisEnabled;
	    
	    //=============================================================
	    // MC Stop
	    //=============================================================                    
	    #STOP(Axis := #Axis,
	          Execute := #Ctrl.Stop,
	          Mode := 2,
	          Deceleration := #AxisCtrl.Deceleration,
	          Jerk := #AxisCtrl.Jerk,
	          AbortAcceleration := TRUE);
	    
	END_REGION
	
	REGION Halt
	
	    //=============================================================
	    // Halt command
	    //=============================================================
	    #Ctrl.Halt := NOT (#Ctrl.MovePlus
	                OR #Ctrl.MoveMinus
	                OR #Ctrl.MoveAbs
	                OR (#Ctrl.Home AND #Ctrl.HomePowerOn)
	                OR #Ctrl.FsEnable)
	                AND NOT #Sts.AxisSts.Done
	                AND NOT (#Axis.Velocity = 0.0)
	                AND NOT #HALT.Error
	                AND NOT #HALT.CommandAborted
	                AND NOT (#STOP.Execute OR #STOP.Busy)
	                AND #Sts.AxisEnabled;
	    
	    //=============================================================
	    // MC Halt
	    //============================================================= 
	    #HALT(Axis := #Axis,
	          Execute := #Ctrl.Halt,
	          Deceleration := #AxisCtrl.Deceleration,
	          Jerk := #AxisCtrl.Jerk,
	          AbortAcceleration := TRUE);
	
	    #tonHaltTimeOut.TON(IN := #Ctrl.Halt AND NOT #Sts.Standstill, PT := #HALT_TIMEOUT);
	
	END_REGION
	
	
	REGION Status
	    
	    #Sts.InPosition := #AxisCtrl.MoveAbsolute AND #MOVE_ABS.Done;
	    
	    #Sts.Synchronizing := #Sts.FsRunning AND #Sts.AxisSts.Synchronizing;
	    #Sts.InSynch := #Sts.FsRunning AND #Sts.AxisSts.Synchronous;
	    
	    #Sts.ActualTarget := #AxisCtrl.MoveAbsTarget;
	
	END_REGION
	
	REGION Coordination Out
	    //=============================================================
	    // Coordination Out
	    //=============================================================  
	
	    #AxisSts.AlarmPresence := #Alarm.TOAxis OR #Alarm.MCFunction OR #Alarm.Drive OR #Alarm.LimitMinus OR #Alarm.LimitPlus;
	    #AxisSts.WarningPresence := #Warning.TOAxis OR #Warning.Drive;
	    #AxisSts.Enabled := #Sts.AxisEnabled;
	    #AxisSts.Done := #Sts.AxisSts.Done;
	    #AxisSts.Standstill := #Sts.Standstill;
	    #AxisSts.RstHWDone := #AxisCtrl.RstHW AND #RESET.Done;
	    #AxisSts.Homed := #Sts.AxisSts.HomingDone;
	    #AxisSts.AtProgrammedSpeed := #Sts.AxisSts.CostantVelocity;
	    #AxisSts.HomingPermitted := #Sts.HomingPermitted;
	    #AxisSts.HomingDone := #HOME.Done;
	    #AxisSts.MoveMinusPermitted := #Sts.MoveVelMinusPermitted;
	    #AxisSts.MovePlusPermitted := #Sts.MoveVelPlusPermitted;
	    #AxisSts.MoveAbsPermitted := #Sts.MoveAbsPermitted;
	    #AxisSts.ActualPosition := #Axis.ActualPosition;
	    #AxisSts.ActualTarget :=  #Sts.ActualTarget;
	    #AxisSts.ActualSpeed := #Axis.ActualVelocity;
	    #AxisSts.Positioned := #Sts.InPosition;
	    #AxisSts.InSynch := #Sts.InSynch;
	    #AxisSts.Synchronizing:=#Sts.Synchronizing;
	    #AxisSts.SwLimitMinus := #Axis.PositionLimits_SW.MinPosition;
	    #AxisSts.SwLimitPlus := #Axis.PositionLimits_SW.MaxPosition;
	
	END_REGION
	
	
	
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

