FUNCTION_BLOCK "PositioningAxis"
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
AUTHOR : PM
FAMILY : Motion
VERSION : 1.0
   VAR_INPUT 
      AxisCtrl : "TAx_Pos_Ctrl";
      Drive : "TAx_DriveInterface";
      Config : "TAx_Config";
      PowerEnable : Bool;   // Power enable from safety
   END_VAR

   VAR_OUTPUT 
      AxisSts : "TAx_Pos_Sts";
      Infeed_REQ_ON : Bool;   // Request to infeed 
   END_VAR

   VAR_IN_OUT 
      Axis {InstructionName := 'TO_PositioningAxis'; LibVersion := '8.0'} : TO_PositioningAxis;
      Alarm : "TAx_Alarms";
      Warning : "TAx_Warnings";
      Diag : "TO_Diagnostic";
   END_VAR

   VAR 
      ReadAlarm { S7_SetPoint := 'False'} : "RW_SINAMICS_Par";
      ReadWarning { S7_SetPoint := 'False'} : "RW_SINAMICS_Par";
      POWER {InstructionName := 'MC_POWER'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_POWER;
      HOME {InstructionName := 'MC_HOME'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_HOME;
      MOVE_ABS {InstructionName := 'MC_MOVEABSOLUTE'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_MOVEABSOLUTE;
      MOVE_VELOCITY {InstructionName := 'MC_MOVEVELOCITY'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_MOVEVELOCITY;
      RESET {InstructionName := 'MC_RESET'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_RESET;
      HALT {InstructionName := 'MC_HALT'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_HALT;
      STOP {InstructionName := 'MC_STOP'; LibVersion := '8.0'; S7_SetPoint := 'False'} : MC_STOP;
      Ctrl : Struct
         InfeedPower : Bool;
         PowerEnable : Bool;
         PowerOn : Bool;
         Home : Bool;
         HomePowerOn : Bool;
         MovePlus : Bool;
         MoveMinus : Bool;
         MoveAbs : Bool;
         Halt : Bool;
         Stop : Bool;
         MoveDirection : Int;
      END_STRUCT;
      Sts : Struct
         AxisSts { S7_SetPoint := 'False'} : "TAx_STATUSWORD";
         AxisFault { S7_SetPoint := 'False'} : "TAx_ERRORWORD";
         AxisWarning { S7_SetPoint := 'False'} : "TAx_WARNINGWORD";
         Standstill : Bool;
         GeneralConditions : Bool;
         RestartConditions : Bool;
         PowerPermit : Bool;
         HomingPermitted : Bool;
         MoveVelPlusPermitted : Bool;
         MoveVelMinusPermitted : Bool;
         MoveAbsPermitted : Bool;
         InPosition : Bool;
         AxisEnabled : Bool;
         ActualTarget : LReal;
      END_STRUCT;
      Simulate : Struct
         Active : Bool;
         Mode : UDInt;
         WriteReq : Bool;
      END_STRUCT;
      Local : Struct
         ErrorReached_SwLimitMinus : Bool;
         ErrorReached_SwLimitPlus : Bool;
         ErrorReached_HwLimitMinus : Bool;
         ErrorReached_HwLimitPlus : Bool;
         ErrorMC_Reset : Bool;
         ErrorMC_Power : Bool;
         ErrorMC_Home : Bool;
         ErrorMC_MoveVel : Bool;
         ErrorMC_MoveAbs : Bool;
         ErrorMC_Halt : Bool;
         ErrorMC_Stop : Bool;
      END_STRUCT;
      tonPowerOFF {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tofInfeedPowerRequest {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tonHaltTimeOut {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      tofRestartActive {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; S7_SetPoint := 'False'} : IEC_TIMER;
      MoveVelVelocityChanged : Bool;
      MoveAbsTargetChanged : Bool;
      MoveAbsVelocityChanged : Bool;
      MoveVelOldVelocity : LReal;
      MoveAbsOldTargetPosition : LReal;
      MoveAbsOldTargetVelocity : LReal;
   END_VAR

   VAR_TEMP 
      MC_Home_Idle : Bool;
      AxDw : DWord;
      RetBool : Bool;
      RetInt : Int;
   END_VAR

   VAR CONSTANT 
      HALT_TIMEOUT : Time := T#10S;
   END_VAR


BEGIN
	
	REGION Info    
	    //=============================================================================
	    //PM FORMING
	    //-----------------------------------------------------------------------------
	    // Library: StandardBlocks
	    // Tested with: S7-1518TF
	    // Engineering: TIA Portal V18
	    // Restrictions: -
	    // Requirements: S7-1500
	    // Functionality: Positioning Axis
	    //
	    // v0.0.1  10/05/2022
	    // v0.0.2  20/05/2022 MC_Stop Added, General improvment
	    // v0.0.3  24/05/2022 General Fixes, deleted tonStandstill, added Peek_bool for drive warning
	    // v0.0.4  05/06/2022 Diagnostic implement
	    // v0.0.5  29/07/2022 General Fixes, add alarms limit plus/minus
	    // v0.0.6  23/08/2022 MC_Halt command modified, general fixes
	    // v0.0.7  13/09/2022 RW Sinamics par modified
	    // v0.0.8  20/10/2022 External Control added
	    // v0.0.9  15/11/2022 Restart TO Management added, TO Diagnostic modified, Alarm-warning-Diag moved in INOUT
	    // v0.0.10  21/11/2022 AxisCtrl default value modified
	    // v1.0.0  28/12/2022 New version TIA V18
	    // v1.1.0  14/02/2023 Simulation added
	    // v1.1.1  24/07/2023 Added AxisSts.Done and status kinemtic bit
	    // v2.0.0  28/12/2023 New version TIA V19
	    // v2.0.1  03/01/2024 Added Config Structure and Start/Stop Mode to MC Power
	    //=============================================================================
	END_REGION
	
	REGION Axis Status
	    //=============================================================
	    // Get TAxis faults 
	    //=============================================================
	    #AxDw := #Axis.ErrorWord;
	    SCATTER(IN:=#AxDw.%W0, OUT=>#Sts.AxisFault);
	    
	    //=============================================================
	    // Get TAxis warnings
	    //=============================================================
	    #AxDw := #Axis.WarningWord;
	    SCATTER(IN:=#AxDw.%W0, OUT=>#Sts.AxisWarning);
	    //Overwrite Drive warning bit from telegram
	    IF #Axis.Actor.Interface.AddressIn.AREA = 16#0081 THEN
	        #Sts.AxisWarning.DriveWarning := PEEK_BOOL(area := #Axis.Actor.Interface.AddressIn.AREA,
	                                         dbNumber := #Axis.Actor.Interface.AddressIn.DB_NUMBER,
	                                         byteOffset := UDINT_TO_INT(#Axis.Actor.Interface.AddressIn.OFFSET / 8) + 1,
	                                         bitOffset := 7);
	    END_IF;
	    
	    //=============================================================
	    // Build status of TAxis Object
	    //=============================================================
	    #AxDw := #Axis.StatusWord;
	    SCATTER(IN:=#AxDw, OUT=>#Sts.AxisSts);
	
	    //Standstill
	    #Sts.Standstill := #Sts.AxisSts.Standstill;
	   
	END_REGION
	
	
	REGION Alarms & Warnings
	    //=============================================================
	    // Reset
	    //=============================================================
	    IF #AxisCtrl.Rst OR #RESET.Done THEN
	        
	        #Local.ErrorReached_SwLimitMinus := FALSE;
	        #Local.ErrorReached_SwLimitPlus := FALSE;
	        #Local.ErrorReached_HwLimitMinus := FALSE;
	        #Local.ErrorReached_HwLimitPlus := FALSE;
	        
	        #Local.ErrorMC_Reset := FALSE;
	        #Local.ErrorMC_Power := FALSE;
	        #Local.ErrorMC_Home := FALSE;
	        #Local.ErrorMC_MoveVel := FALSE;
	        #Local.ErrorMC_MoveAbs := FALSE;
	        #Local.ErrorMC_Halt := FALSE;
	        #Local.ErrorMC_Stop := FALSE;
	        
	    END_IF;
	    
	    //==============================================================
	    // TO Axis alarm presence
	    //============================================================= 
	    IF #Sts.AxisSts.Error THEN
	        #Alarm.TOAxis := #Axis.ErrorDetail.Reaction > 0;
	        #Diag.TO_Message := #Axis.ErrorDetail.Number;
	    ELSE
	        #Alarm.TOAxis := FALSE;
	        #Diag.TO_Message := 0;
	    END_IF;
	    
	    //=============================================================
	    // Drive Alarm presence
	    //=============================================================
	    #Alarm.Drive := #Sts.AxisFault.DriveFault;
	    
	    //=============================================================
	    // Limits alarms
	    //=============================================================
	    IF #Sts.AxisSts.SW_NegativeLimitSwitch THEN
	        #Local.ErrorReached_SwLimitMinus := TRUE;
	    END_IF;
	    IF #Sts.AxisSts.SW_PositiveLimitSwitch THEN
	        #Local.ErrorReached_SwLimitPlus := TRUE;
	    END_IF;
	    IF #Sts.AxisSts.HW_NegativeLimitSwitch THEN
	        #Local.ErrorReached_HwLimitMinus := TRUE;
	    END_IF;
	    IF #Sts.AxisSts.HW_PositiveLimitSwitch THEN
	        #Local.ErrorReached_HwLimitPlus := TRUE;
	    END_IF;
	    
	    #Alarm.LimitMinus := #Local.ErrorReached_SwLimitMinus OR #Local.ErrorReached_HwLimitMinus;
	    #Alarm.LimitPlus := #Local.ErrorReached_SwLimitPlus OR #Local.ErrorReached_HwLimitPlus;
	    
	    //=============================================================
	    // MC Errors
	    //=============================================================
	    IF #RESET.Error THEN
	        #Local.ErrorMC_Reset := TRUE;
	        #Diag.#MC_Message := #RESET.ErrorId;
	    END_IF;
	    IF #POWER.Error THEN
	        #Local.ErrorMC_Power := TRUE;
	        #Diag.#MC_Message := #POWER.ErrorId;
	    END_IF;
	    IF #HOME.Error THEN
	        #Local.ErrorMC_Home := TRUE;
	        #Diag.#MC_Message := #HOME.ErrorId;
	    END_IF;
	    IF #MOVE_VELOCITY.Error THEN
	        #Local.ErrorMC_MoveVel := TRUE;
	        #Diag.#MC_Message := #MOVE_VELOCITY.ErrorId;
	    END_IF;
	    IF #MOVE_ABS.Error THEN
	        #Local.ErrorMC_MoveAbs := TRUE;
	        #Diag.#MC_Message := #MOVE_ABS.ErrorId;
	    END_IF;
	    IF #HALT.Error THEN
	        #Local.ErrorMC_Halt := TRUE;
	        #Diag.#MC_Message := #HALT.ErrorId;
	    END_IF;
	    IF #STOP.Error THEN
	        #Local.ErrorMC_Stop := TRUE;
	        #Diag.#MC_Message := #STOP.ErrorId;
	    END_IF;
	    
	    #Alarm.MCFunction := #Local.ErrorMC_Reset
	                    OR #Local.ErrorMC_Power
	                    OR #Local.ErrorMC_Home
	                    OR #Local.ErrorMC_MoveVel
	                    OR #Local.ErrorMC_MoveAbs
	                    OR #Local.ErrorMC_Halt
	                    OR #Local.ErrorMC_Stop;
	    
	    IF NOT #Alarm.MCFunction THEN
	        #Diag.MC_Message := 0;
	    END_IF;
	    
	    //=============================================================
	    // Warnings
	    //=============================================================
	    #Warning.Drive := #Sts.AxisWarning.DriveWarning;
	    
	    #Warning.TOAxis := (#Sts.AxisSts.Error AND #Axis.ErrorDetail.Reaction = 0)
	                    OR #Axis.WarningWord <> 0
	                    OR #Diag.TO_RestartNeeded
	                    OR #Diag.TO_RestartActive
	                    OR #Diag.TO_SimulationActive;
	    
	END_REGION
	
	
	REGION Diagnostic
	    
	    #Diag.DeviceType := 12;
	    
	    //=============================================================
	    // Diagnostic bit
	    //=============================================================
	    #Diag.ErrorReached_SwLimitMinus := #Local.ErrorReached_SwLimitMinus;
	    #Diag.ErrorReached_SwLimitPlus := #Local.ErrorReached_SwLimitPlus;
	    #Diag.ErrorReached_HwLimitMinus := #Local.ErrorReached_HwLimitMinus;
	    #Diag.ErrorReached_HwLimitPlus := #Local.ErrorReached_HwLimitPlus;
	    #Diag.ErrorMC_Reset := #Local.ErrorMC_Reset;
	    #Diag.ErrorMC_Power := #Local.ErrorMC_Power;
	    #Diag.ErrorMC_Home := #Local.ErrorMC_Home;
	    #Diag.ErrorMC_MoveVel := #Local.ErrorMC_MoveVel;
	    #Diag.ErrorMC_MoveAbs := #Local.ErrorMC_MoveAbs;
	    #Diag.ErrorMC_Halt := #Local.ErrorMC_Halt;
	    #Diag.ErrorMC_Stop := #Local.ErrorMC_Stop;
	    
	    #Diag.MC_ErrorPresence := #Alarm.MCFunction;
	    #Diag.TO_ErrorPresence := #Alarm.TOAxis;
	    #Diag.Drive_ErrorPresence := #Alarm.Drive;
	    
	    #Diag.TO_RestartNeeded := #Sts.AxisSts.OnlineStartValuesChanged;
	    #Diag.TO_RestartEnable := #Sts.RestartConditions;
	    #Diag.TO_RestartActive := #tofRestartActive.Q;
	    #Diag.TO_SimulationActive := #Simulate.Active;
	    
	    //=============================================================
	    // Drive Diagnostic
	    //=============================================================
	    IF #Drive.AccessPoint > 0 AND #Drive.TokenChain > 0 AND NOT #Config.Simulation THEN
	        
	        #ReadAlarm(Enable := #Sts.AxisFault.DriveFault,
	                   ReadWrite := 0,
	                   ParNo := 2131,
	                   Index := 0,
	                   AxisNo := #Drive.AxisID,
	                   HW_ID := #Drive.AccessPoint,
	                   "TokenChain" := #Drive.TokenChain);
	        
	        #ReadWarning(Enable := #Sts.AxisWarning.DriveWarning AND NOT #Sts.AxisFault.DriveFault,
	                   ReadWrite := 0,
	                   ParNo := 2132,
	                   Index := 0,
	                   AxisNo := #Drive.AxisID,
	                   HW_ID := #Drive.AccessPoint,
	                   "TokenChain" := #Drive.TokenChain);
	        
	        
	      IF #Sts.AxisFault.DriveFault THEN
	            IF #ReadAlarm.Done THEN
	                #Diag.Drive_Message := REAL_TO_UINT(#ReadAlarm.ValueReadReal);
	            END_IF;
	        ELSIF #Sts.AxisWarning.DriveWarning THEN
	            IF #ReadWarning.Done THEN
	                #Diag.Drive_Message := REAL_TO_UINT(#ReadWarning.ValueReadReal);
	            END_IF;
	        ELSE
	            #Diag.Drive_Message := 0;
	        END_IF;
	    ELSE
	        #Diag.Drive_Message := 0;
	    END_IF;
	    
	    //=============================================================
	    // Diagnotic message type
	    //=============================================================
	    IF #Alarm.TOAxis
	        OR #Alarm.MCFunction
	        OR #Alarm.Drive
	        OR #Alarm.LimitMinus
	        OR #Alarm.LimitPlus
	    THEN
	        #Diag.MessageType := 2;
	    ELSIF #Warning.TOAxis
	        OR #Warning.Drive
	    THEN
	        #Diag.MessageType := 1;
	    ELSE
	        #Diag.MessageType := 0;
	    END_IF;
	    
	END_REGION
	
	
	REGION Conditions
	    //=============================================================
	    // General condition to execute MC operation
	    //=============================================================
	    #Sts.GeneralConditions := NOT #AxisCtrl.SafeStop
	                            AND NOT #Alarm.TOAxis
	                            AND NOT #Alarm.MCFunction;
	END_REGION
	
	REGION Simulation
	    
	    #Simulate.Active := #Sts.AxisSts.AxisSimulation AND #Axis.VirtualAxis.Mode = 0;
	    
	    IF #Axis.VirtualAxis.Mode = 0 THEN
	        
	        IF #Config.Simulation <> #Simulate.Active AND NOT #Diag.TO_RestartActive THEN
	            IF #Config.Simulation = TRUE THEN
	                #Simulate.Mode := 1;
	            ELSE
	                #Simulate.Mode := 0;
	            END_IF;
	            #Simulate.WriteReq := TRUE;
	        END_IF;
	        
	        #RetInt := WRIT_DBL(REQ := #Simulate.WriteReq, SRCBLK := #Simulate.Mode, BUSY => #RetBool, DSTBLK => #Axis.Simulation.Mode);
	        
	        IF #RetInt = 16#7002 AND #Simulate.WriteReq THEN
	            #Simulate.WriteReq := FALSE;
	            #Diag.TO_RestartCmd := TRUE;
	        END_IF;
	        
	    END_IF;
	END_REGION
	
	
	REGION Reset  
	    //=============================================================
	    // Axis restart active
	    //=============================================================
	    #tofRestartActive.TOF(IN := #Sts.AxisSts.RestartActive,
	                          PT := T#1S);
	    
	    //=============================================================
	    // Axis restart conditions
	    //=============================================================
	    #Sts.RestartConditions := NOT (#AxisCtrl.Power
	                                OR #AxisCtrl.MovePlus
	                                OR #AxisCtrl.MoveMinus
	                                OR (#AxisCtrl.Homing AND #Ctrl.HomePowerOn)
	                                OR #AxisCtrl.MoveAbsolute
	                                OR #AxisCtrl.ExtControl
	                                OR #MOVE_VELOCITY.Busy
	                                OR #MOVE_ABS.Busy
	                                OR #HALT.Busy
	                                OR #STOP.Busy)
	                                AND #Sts.Standstill
	                                AND NOT #AxisCtrl.Rst
	                                AND NOT #tofRestartActive.Q;
	    
	    //=============================================================
	    // Axis reset
	    //=============================================================
	    #RESET(Axis := #Axis,
	           Execute := #AxisCtrl.Rst OR ((#AxisCtrl.RstHW OR #Diag.TO_RestartCmd) AND #Sts.RestartConditions),
	           Restart := (#AxisCtrl.RstHW OR #Diag.TO_RestartCmd) AND #Sts.RestartConditions);
	    
	    IF NOT #RESET.Busy THEN
	        #Diag.TO_RestartCmd := FALSE;
	    END_IF;
	    
	END_REGION
	
	
	REGION Power
	    //=============================================================
	    // Power permit
	    //=============================================================
	    #Sts.PowerPermit := NOT #AxisCtrl.SafeStop
	                        AND #Drive.Infeed_ON
	                        AND NOT #Alarm.TOAxis
	                        AND NOT #Local.ErrorMC_Power;
	
	    //=============================================================
	    // Power command during home
	    //=============================================================   
	    #Ctrl.HomePowerOn := (#AxisCtrl.HomeMode = 3 OR #AxisCtrl.HomeMode = 5);
	
	    //=============================================================
	    // Power command
	    //=============================================================
	    #Ctrl.PowerEnable := (#AxisCtrl.Power
	                        OR #AxisCtrl.MovePlus 
	                        OR #AxisCtrl.MoveMinus
	                        OR (#AxisCtrl.Homing AND #Ctrl.HomePowerOn)
	                        OR #AxisCtrl.MoveAbsolute
	                        OR #AxisCtrl.ExtControl
	                        OR #MOVE_VELOCITY.Busy
	                        OR #MOVE_ABS.Busy
	                        OR #HALT.Busy
	                        OR #STOP.Busy)
	                        AND #Sts.PowerPermit ;
	            
	    //=============================================================
	    // Delay OFF Power
	    //=============================================================
	    
	    #tonPowerOFF.TON(IN := NOT #Ctrl.PowerEnable AND #Ctrl.PowerOn,
	    PT := #Config.PowerOffDelay);
	    
	    IF #tonPowerOFF.Q OR (NOT #Sts.PowerPermit AND #Sts.Standstill) OR NOT #PowerEnable THEN
	        #Ctrl.PowerOn := FALSE;
	    ELSIF #Ctrl.PowerEnable THEN
	        #Ctrl.PowerOn := TRUE;
	    END_IF;
	
	
	    //=============================================================
	    // MC Power
	    //=============================================================
	    #POWER(Axis := #Axis,
	           Enable := #Ctrl.PowerOn,
	           StartMode := #Config.PowerStartMode,
	           StopMode := #Config.PowerStopMode);
	    
	    #Sts.AxisEnabled := #POWER.Status AND #Sts.AxisSts.Enable;
	    
	    //=============================================================
	    // Power request to INFEED
	    //=============================================================
	    #Ctrl.InfeedPower := #AxisCtrl.Power
	                    OR #AxisCtrl.MovePlus
	                    OR #AxisCtrl.MoveMinus
	                    OR (#AxisCtrl.Homing AND #Ctrl.HomePowerOn)
	                    OR #AxisCtrl.MoveAbsolute
	                    OR #AxisCtrl.ExtControl
	                    OR #Ctrl.PowerOn;
	     
	    #tofInfeedPowerRequest.TOF(IN := #Ctrl.InfeedPower,
	                      PT := T#300MS,
	                      Q => #Infeed_REQ_ON);
	
	END_REGION
	
	
	REGION Home
	    //=============================================================
	    // Home permitted
	    //=============================================================
	    #MC_Home_Idle := NOT #HOME.Busy AND NOT #HOME.Error AND NOT #HOME.Done;
	 
	    #Sts.HomingPermitted := NOT #Sts.AxisSts.PositioningCommand
	                        AND (NOT #Sts.AxisSts.VelocityCommand OR #AxisCtrl.HomeMode = 0)
	                        AND NOT #Sts.AxisSts.Synchronous
	                        AND NOT #Sts.AxisSts.Synchronizing
	                        AND (NOT #AxisCtrl.SafeStop OR NOT #Ctrl.HomePowerOn)
	                        AND NOT #Alarm.TOAxis
	                        AND NOT #Local.ErrorMC_Home
	                        AND (#MC_Home_Idle OR #Ctrl.Home);
	                        
	    //=============================================================
	    // Home Mode
	    //=============================================================
	    IF #Simulate.Active THEN
	        #HOME.Mode := 0;
	    ELSE
	        #HOME.Mode := #AxisCtrl.HomeMode;
	    END_IF;
	    
	    //=============================================================
	    // Home Command
	    //=============================================================
	    #Ctrl.Home :=   #AxisCtrl.Homing
	                    AND (#Sts.AxisEnabled OR NOT #Ctrl.HomePowerOn)
	                    AND #Sts.HomingPermitted;
	    //=============================================================
	    // MC Home
	    //=============================================================
	    #HOME(Axis := #Axis,
	          Execute := #Ctrl.Home,
	          Position := #AxisCtrl.HomePosition,
	          Mode := #AxisCtrl.HomeMode);
	END_REGION
	
	
	REGION Move Velocity
	    //=============================================================
	    // Speed change
	    //=============================================================
	    #MoveVelVelocityChanged := ABS(#AxisCtrl.Velocity - #MoveVelOldVelocity) > #Axis.StandstillSignal.VelocityThreshold ;
	    IF #MoveVelVelocityChanged THEN
	        #MoveVelOldVelocity := #AxisCtrl.Velocity;
	    END_IF;
	
	    //=============================================================
	    // Move Bkw permitted
	    //=============================================================
	    #Sts.MoveVelMinusPermitted := NOT #Sts.AxisSts.HomingCommand
	                                AND NOT #Ctrl.MovePlus
	                                AND NOT #Ctrl.MoveAbs
	                                AND NOT #Alarm.LimitMinus
	                                AND #Sts.GeneralConditions;
	
	    //=============================================================
	    // Move Bkw Command
	    //=============================================================
	    #Ctrl.MoveMinus := #AxisCtrl.MoveMinus
	                    AND #Sts.MoveVelMinusPermitted
	                    AND #Sts.AxisEnabled;
	
	    //=============================================================
	    // Move Fwd permitted
	    //=============================================================
	    #Sts.MoveVelPlusPermitted := NOT #Sts.AxisSts.HomingCommand
	                                AND NOT #Ctrl.MoveMinus
	                                AND NOT #Ctrl.MoveAbs
	                                AND NOT #Alarm.LimitPlus
	                                AND #Sts.GeneralConditions;
	
	    //=============================================================
	    // Move Fwd Command
	    //=============================================================
	    #Ctrl.MovePlus := #AxisCtrl.MovePlus
	                AND #Sts.MoveVelPlusPermitted
	                AND #Sts.AxisEnabled;
	    //=============================================================
	    // Move direction
	    //=============================================================
	    IF #Ctrl.MovePlus THEN
	        #Ctrl.MoveDirection := 1;
	    END_IF;
	    
	    IF #Ctrl.MoveMinus THEN
	        #Ctrl.MoveDirection := 2;
	    END_IF;
	    //=============================================================
	    // Main
	    //=============================================================
	    #MOVE_VELOCITY(Axis := #Axis,
	                   Execute := (#Ctrl.MovePlus OR #Ctrl.MoveMinus) AND NOT #MoveVelVelocityChanged,
	                   Velocity := #AxisCtrl.Velocity,
	                   Acceleration := #AxisCtrl.Acceleration,
	                   Deceleration := #AxisCtrl.Deceleration,
	                   Jerk := #AxisCtrl.Jerk,
	                   PositionControlled := #AxisCtrl.VelocityPositionControlled,
	                   Direction := #Ctrl.MoveDirection,
	                   Current := FALSE);
	END_REGION
	
	
	REGION Move Absolute
	    //=============================================================
	    // Target position changed
	    //=============================================================
	    #MoveAbsTargetChanged := ABS(#AxisCtrl.MoveAbsTarget - #MoveAbsOldTargetPosition) > #Axis.PositioningMonitoring.Window;
	    IF #MoveAbsTargetChanged THEN
	        #MoveAbsOldTargetPosition := #AxisCtrl.MoveAbsTarget;
	    END_IF;
	    //=============================================================
	    // Target velocity changed
	    //=============================================================
	    #MoveAbsVelocityChanged := ABS(#AxisCtrl.Velocity - #MoveAbsOldTargetVelocity) > #Axis.StandstillSignal.VelocityThreshold ;
	    IF  #MoveAbsVelocityChanged THEN
	        #MoveAbsOldTargetVelocity := #AxisCtrl.Velocity;
	    END_IF;
	    
	    //=============================================================
	    // Positioning permitted
	    //=============================================================
	    #Sts.MoveAbsPermitted := NOT #Sts.AxisSts.HomingCommand
	                            AND #Sts.AxisSts.HomingDone
	                            AND #Sts.GeneralConditions;
	    //=============================================================
	    // Move absolute Command
	    //=============================================================
	    #Ctrl.MoveAbs := #AxisCtrl.MoveAbsolute
	                    AND #Sts.MoveAbsPermitted
	                    AND #Sts.AxisEnabled;
	    //=============================================================
	    // MC Move absolute
	    //=============================================================
	    #MOVE_ABS(Axis := #Axis,
	              Execute := #Ctrl.MoveAbs AND  NOT #MoveAbsTargetChanged AND NOT #MoveAbsVelocityChanged,
	              Position := #AxisCtrl.MoveAbsTarget,
	              Velocity := #AxisCtrl.Velocity,
	              Acceleration := #AxisCtrl.Acceleration,
	              Deceleration := #AxisCtrl.Deceleration,
	              Jerk := #AxisCtrl.Jerk,
	              Direction := #AxisCtrl.MoveAbsDirection);
	    
	    
	END_REGION
	
	
	REGION Halt
	   
	    //=============================================================
	    // Halt command
	    //=============================================================
	    #Ctrl.Halt :=   NOT (#Ctrl.MovePlus
	                    OR #Ctrl.MoveMinus
	                    OR #Ctrl.MoveAbs
	                    OR (#Ctrl.Home AND #Ctrl.HomePowerOn)
	                    OR #AxisCtrl.ExtControl)
	                    AND NOT #Sts.AxisSts.Done
	                    AND NOT #HALT.Error 
	                    AND NOT #HALT.CommandAborted
	                    AND NOT (#STOP.Execute OR #STOP.Busy)
	                    AND #Sts.AxisEnabled;
	                    
	    //=============================================================
	    // MC Halt
	    //============================================================= 
	    #HALT(Axis := #Axis,
	          Execute := #Ctrl.Halt,
	          Deceleration := #AxisCtrl.Deceleration,
	          Jerk := #AxisCtrl.Jerk,
	          AbortAcceleration := TRUE);
	    
	    #tonHaltTimeOut.TON(IN := #Ctrl.Halt AND NOT #Sts.Standstill, PT := #HALT_TIMEOUT);
	    
	END_REGION
	
	
	REGION Stop
	    
	    //=============================================================
	    // Stop command
	    //=============================================================
	     
	    #Ctrl.Stop := (#HALT.Error OR #tonHaltTimeOut.Q)
	                AND NOT #Sts.Standstill
	                AND NOT #STOP.CommandAborted
	                AND NOT #STOP.Error
	                AND #Sts.AxisEnabled;
	    
	    //=============================================================
	    // MC Stop
	    //=============================================================                    
	    #STOP(Axis := #Axis,
	          Execute := #Ctrl.Stop,
	          Mode := 2,
	          Deceleration := #AxisCtrl.Deceleration,
	          Jerk := #AxisCtrl.Jerk,
	          AbortAcceleration := TRUE);
	    
	END_REGION
	
	
	REGION Status
	    
	    #Sts.InPosition := #AxisCtrl.MoveAbsolute AND #MOVE_ABS.Done;
	    
	    #Sts.ActualTarget:= #AxisCtrl.MoveAbsTarget;
	   
	
	END_REGION
	
	
	REGION Coordination Out
	    //=============================================================
	    // Coordination Out
	    //=============================================================  
	
	    #AxisSts.AlarmPresence := #Alarm.TOAxis OR #Alarm.MCFunction OR #Alarm.Drive;
	    #AxisSts.WarningPresence := #Warning.TOAxis OR #Warning.Drive;
	    #AxisSts.Enabled := #Sts.AxisEnabled;
	    #AxisSts.Done := #Sts.AxisSts.Done;
	    #AxisSts.Standstill := #Sts.Standstill;
	    #AxisSts.RstHWDone := #AxisCtrl.RstHW AND #RESET.Done;
	    #AxisSts.Homed := #Sts.AxisSts.HomingDone;
	    #AxisSts.AtProgrammedSpeed := #Sts.AxisSts.CostantVelocity;
	    #AxisSts.HomingPermitted := #Sts.HomingPermitted;
	    #AxisSts.HomingDone := #HOME.Done;
	    #AxisSts.MoveMinusPermitted := #Sts.MoveVelMinusPermitted;
	    #AxisSts.MovePlusPermitted := #Sts.MoveVelPlusPermitted;
	    #AxisSts.MoveAbsPermitted := #Sts.MoveAbsPermitted;
	    #AxisSts.ActualPosition := #Axis.ActualPosition;
	    #AxisSts.ActualTarget :=  #Sts.ActualTarget;
	    #AxisSts.ActualSpeed := #Axis.ActualVelocity;
	    #AxisSts.Positioned := #Sts.InPosition;
	    #AxisSts.SwLimitMinus := #Axis.PositionLimits_SW.MinPosition;
	    #AxisSts.SwLimitPlus := #Axis.PositionLimits_SW.MaxPosition;
	
	END_REGION
	
	
	
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

