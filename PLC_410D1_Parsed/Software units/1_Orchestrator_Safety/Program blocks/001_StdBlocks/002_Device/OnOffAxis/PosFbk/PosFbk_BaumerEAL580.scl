FUNCTION_BLOCK "PosFbk_BaumerEAL580"
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
AUTHOR : TVA
FAMILY : Devices
VERSION : 0.2
   VAR_INPUT 
      HW_IO : HW_IO;   // Hardware ID
   END_VAR

   VAR_IN_OUT 
      Interface : "PosFbk_ITF";   // Interface with OnOff Axis
      "Retain" : "PosFbk_RTN";
      Alarm : "PosFbk_Encoder_Alr";
   END_VAR

   VAR 
      Encoder : "PosFbk_Encoder_TEL81";
      tonNotAbsPos {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      pos1Raw { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      CommOK { S7_SetPoint := 'True'} : Bool;
      auxOsPreset : Bool;
   END_VAR

   VAR_TEMP 
      wrRetval : Int;
      pos2Raw : DInt;
      deltaPos : DInt;
      startPreset : Bool;
   END_VAR

   VAR CONSTANT 
      pulsePerRevolution : LReal := 65536.0;
      SYNC_TOLL : DInt := 2;
   END_VAR


BEGIN
	
	REGION Info
	    //=============================================================================
	    //PM FORMING
	    //-----------------------------------------------------------------------------
	    // Library: StandardBlocks
	    // Tested with: S7-1518TF
	    // Engineering: TIA Portal V18
	    // Restrictions: -
	    // Requirements: S7-1500
	    // Functionality: Baumer EAL580 Encoder Handling by Telegram 81
	    //
	    // v0.0.1  31/08/2022  New version
	    // v0.0.3  25/11/2022  Remove struct from Retain for HMI
	    // v1.0.0  28/12/2022  New version V18
	    // v1.0.2  10/01/2023  Fix not synched on startup
	    //=============================================================================
	    
	END_REGION
	
	REGION Data Input
	(* Read Data From Device *)
	    #CommOK := DPRD_DAT(LADDR := #HW_IO, RECORD => #Encoder.IN) = 0;
	    
	END_REGION
	
	
	REGION Alarms Handling
	    // Reset
	    IF #Interface.Ctrl.Rst THEN
	        #Alarm.CommFault := FALSE;
	        #Alarm.SensorFault := FALSE;
	        #Alarm.NoRef := FALSE;
	    END_IF;
	    
	    // Communication Fault 
	    #Alarm.CommFault := NOT #CommOK;
	    
	    // Sensor Fault 
	    #tonNotAbsPos.TON(IN := #CommOK AND NOT #Encoder.IN.G1_ZSW.TRM_ABS_POS,
	                        PT := T#10S);
	    
	    #Alarm.SensorFault := #Encoder.IN.G1_ZSW.ENC_ERR OR #tonNotAbsPos.Q;
	    #Encoder.OUT.G1_STW.ERR_ACK := #Interface.Ctrl.Rst AND #Encoder.IN.G1_ZSW.ENC_ERR;
	    
	    // Parameter Error
	    #Alarm.Resolution:=#Retain.Config.Resolution=0.0;
	    
	    // Device Error
	    #Interface.Sts.Error := #Alarm.CommFault OR #Alarm.SensorFault OR #Alarm.Resolution;
	    
	END_REGION
	
	REGION Positions Handling
	(* Encoder Position Request *)
	    #Encoder.OUT.STW2_ENC.PLC_CTRL := TRUE;
	    #Encoder.OUT.G1_STW.POS_REQ := NOT #Encoder.IN.G1_ZSW.ENC_ERR;
	    
	    (* Positions Handling *)
	    IF #Encoder.IN.G1_ZSW.TRM_ABS_POS THEN
	        
	        // Counter 1 Value
	        #pos1Raw := SHL(IN := #Encoder.IN.G1_XIST1, N := 3);
	        
	        // Counter 2 Value
	        #pos2Raw := SHL(IN := #Encoder.IN.G1_XIST2, N := 3);
	        
	        // Reduild Encoder Position 
	        #deltaPos := (#pos1Raw - #Retain.Preset.Pulses);
	        #Interface.Sts.Position := #Retain.Preset.Units + (DINT_TO_LREAL(#deltaPos) / #pulsePerRevolution * #Retain.Config.Resolution );
	        
	        (* No REFERENCE Alarm *)
	        #Alarm.NoRef := ABS(#pos1Raw - #Retain.Preset.Pulses - #pos2Raw) > #SYNC_TOLL;
	        #Interface.Sts.ErrorNotSynched := #Alarm.NoRef;
	    END_IF;
	  
	    #Interface.Sts.EncIsAbsolute := TRUE;
	    
	END_REGION
	
	REGION Preset
	 
	    // Preset Command
	    #startPreset:= #Interface.Ctrl.PresetCmd AND NOT #auxOsPreset;
	    #auxOsPreset:=#Interface.Ctrl.PresetCmd;
	    #Encoder.OUT.G1_STW.PSET_ACT := (#startPreset OR #Encoder.OUT.G1_STW.PSET_ACT)
	                                AND #CommOK AND NOT #Encoder.IN.G1_ZSW.ENC_ERR AND #Interface.Ctrl.PresetCmd;
	    // Preset Command Acknoledge
	    IF #Encoder.IN.G1_ZSW.PSET_STS AND NOT #Interface.Sts.PresetAck THEN
	        #Retain.Preset.Pulses := #pos1Raw;
	        #Retain.Preset.Units := #Interface.Ctrl.PresetPosition;
	        #Encoder.OUT.G1_STW.PSET_ACT:=FALSE;
	        #Interface.Sts.PresetAck:=TRUE;
	    END_IF;
	    IF NOT #Interface.Ctrl.PresetCmd THEN 
	        #Interface.Sts.PresetAck := FALSE;
	    END_IF;
	END_REGION
	
	REGION Data Output
	    #wrRetval:= DPWR_DAT(LADDR := #HW_IO, RECORD := #Encoder.OUT);
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK

