// Block: Positioning_DOL_Machine_FB
// Title: Init

FUNCTION_BLOCK "Positioning_DOL_Machine_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Init
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI : udt_DeviceSafetyInterface;
      Drive : TAx_DriveInterface;
      DataIn : Positioning_DOL_Machine_DataIn;
      CIn : Positioning_DOL_Machine_CIn;
      Config : Positioning_DOL_Machine_Config;
      HW_ID_TEL1 : HW_SUBMODULE;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      DataOut : Positioning_DOL_Machine_DataOut;
      COut : Positioning_DOL_Machine_COut;
   END_VAR

   VAR_IN_OUT
      PosFeedback : PosFbk_ITF;
      Par : Positioning_DOL_Machine_Par;
      Pers_Data : Positioning_DOL_Machine_Pers_Data;
      Warning : Positioning_DOL_Machine_Wng;
      Alarm : Positioning_DOL_Machine_Alr;
   END_VAR

   VAR
      InitDone : Bool;
      Diag : Struct
         S120 : TO_Diagnostic;
      END_STRUCT;
      HMI : Struct
         Sts : "UDT_HMI-Sts_PosDOL-MchFB";
         B_Preset : Bool;
         B_Preset_UM2 : Bool;
         PresetPosition : LReal;
         TargetPosition : LReal;
      END_STRUCT;
      Sts : Struct
         Standstill : Bool;
         AlarmPresence : Bool;
         WarningPresence : Bool;
         Gen_Cnd : Bool;
         Minus_Cnd : Bool;
         Plus_Cnd : Bool;
         Pos_Cnd : Bool;
         Preset_Cnd : Bool;
         ActualPosition : LReal;
         Act_SysTime : DTL;
         Prv_SysTime : DTL;
      END_STRUCT;
      Ctrl : Struct
         StopDueDoorOpeningRequest : Bool;
         StopAborting : Bool;
         SafeMotionEnable : Bool;
         StopInPhase : Bool;
         StopProgrammed : Bool;
         Preset : Bool;
         Minus_Pos_Aut : Bool;
         Plus_Pos_Aut : Bool;
         Minus_Pos_Man : Bool;
         Plus_Pos_Man : Bool;
         Minus_Vel_Man : Bool;
         Plus_Vel_Man : Bool;
         MoveToPos_Aut : Bool;
         MoveToPos_Man : Bool;
         MoveToPos : Bool;
         Minus_Vel : Bool;
         Plus_Vel : Bool;
         Fan : Bool;
         Pos : LReal;
         Speed : LReal;
         SpeedPercentage : LReal;
      END_STRUCT;
      Ax : OnOffAxis;
      S120 : SpeedMotor;
      Fan_M : Motor;
      TON_NoPendingCmd : TON_TIME;
      TON_MinusCnd : TON_TIME;
      TON_PlusCnd : TON_TIME;
      TON_Fan_DelayOff : TON_TIME;
      TON_Brake_TimeOut : TON_TIME;
      S120_STW_TEL1 : PD_TEL1_IN;
      S120_ZSW_TEL1 : PD_TEL1_OUT;
      GETIO_STW_TEL1 : GETIO;
      SETIO_ZSW_TEL1 : SETIO;
      AUX : Struct
         PB_Minus : Bool;
         PB_Plus : Bool;
         PB_MoveToPos : Bool;
         B_Preset : Bool;
         B_Preset_UM2 : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP
      PE : Struct
         PB_Minus : Bool;
         PB_Plus : Bool;
         PB_MoveToPos : Bool;
         B_Preset : Bool;
         B_Preset_UM2 : Bool;
      END_STRUCT;
      RETVAL : Int;
      Req : Bool;
      REAL_value : Real;
   END_VAR


BEGIN
   REGION "Init"
      IF NOT InitDone THEN
          
          InitDone := TRUE;
          
          RETVAL := (Sts.Act_SysTime);
          
          Sts.Prv_SysTime := Sts.Act_SysTime;
          
      END_IF;



   END_REGION

   REGION "Reset"
      IF AreaInterface.RstAlarms THEN
          
          Alarm.BrakeTimeOut := FALSE;
          Alarm.S120_ComErr := FALSE;
          Alarm.Ax_NotHomed := FALSE;
          
          Warning.NotAutReady := FALSE;
          Warning.MissingCnd_Minus := FALSE;
          Warning.MissingCnd_Plus := FALSE;
          
      END_IF;


   END_REGION

   REGION "Actual Position"
      Sts.ActualPosition := PosFeedback.Sts.Position;

   END_REGION

   REGION "Machine stop movements due door open request"
      Ctrl.StopDueDoorOpeningRequest := (((((TON_NoPendingCmd.Q AND Sts.Standstill) OR Ctrl.StopDueDoorOpeningRequest) AND CIn.Manager.EnableStopDoorOpeningReq) AND ZSI.Door_NormalStop) AND NOT (ZSI.Door_Opened));
   END_REGION

   REGION "Stop in phase"
      IF NOT (AreaInterface.StopInPhase) THEN
         Ctrl.StopInPhase := FALSE;
      ELSIF AreaInterface.StopInPhase THEN
         Ctrl.StopInPhase := TRUE;
      END_IF;
   END_REGION

   REGION "Stop programmed"
      IF NOT (AreaInterface.StopProgrammed) THEN
         Ctrl.StopProgrammed := FALSE;
      ELSIF AreaInterface.StopProgrammed THEN
         Ctrl.StopProgrammed := TRUE;
      END_IF;
   END_REGION

   REGION "Alarm comunication (s120 IN)"
      #GETIO_STW_TEL1(
         en := TRUE,
         ID := HW_ID_TEL1,
         INPUTS := S120_STW_TEL1
      );

      #GETIO_STW_TEL1.Q;
      IF (GETIO_STW_TEL1.STATUS <> 0) THEN
         Alarm.S120_ComErr := TRUE;
      END_IF;
   END_REGION

   REGION "Alarm / Warning axis not homed"
      Warning.Ax_NotHomed := NOT (Ax.AxisSts.Homed);
      IF ((NOT (Ax.AxisSts.Homed) AND AreaInterface.Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Man)) THEN
         Alarm.Ax_NotHomed := TRUE;
      END_IF;
      IF ((NOT (Ax.AxisSts.Homed) AND AreaInterface.Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Man)) THEN
         Warning.Ax_NotHomed := FALSE;
      END_IF;
   END_REGION

   REGION "Alarm motor brake timeout"
      #TON_Brake_TimeOut(
         IN := (((Config.Brake_Presence AND DataIn.Brake_M_Q) AND NOT (DataIn.Brake_M_Feedback)) OR ((Config.Brake_Presence AND NOT (DataIn.Brake_M_Q)) AND DataIn.Brake_M_Feedback)),
         PT := t#1s
      );

      #TON_Brake_TimeOut.Q;
      IF #TON_Brake_TimeOut.Q THEN
         Alarm.BrakeTimeOut := TRUE;
      END_IF;
   END_REGION

   REGION "Buttons"
      PE.PB_Minus := PosEdge(DataIn.PB.Bwd_Minus);
      PE.PB_Plus := PosEdge(DataIn.PB.Fwd_Plus);
      PE.PB_MoveToPos := PosEdge(DataIn.PB.MoveToPos);
      PE.B_Preset := PosEdge(HMI.B_Preset);
      PE.B_Preset_UM2 := PosEdge(HMI.B_Preset_UM2);
   END_REGION

   REGION "Preset"
      "Um2-1"(
         en := PE.B_Preset_UM2,
         y := HMI.PresetPosition,
         coeff := Config.Ax_UM2,
         Ret_Val => Ax.AxisCtrl.HomePosition
      );

      Sts.Preset_Cnd := (AreaInterface.Man AND Ax.AxisSts.HomingPermitted);
      IF PE.B_Preset THEN
         Ax.AxisCtrl.HomePosition := HMI.PresetPosition;
      END_IF;
      IF PE.B_Preset_UM2 THEN
         Ax.AxisCtrl.HomePosition := "Um2-1"(y := HMI.PresetPosition, coeff := Config.Ax_UM2);
      END_IF;
      Ctrl.Preset := (((((HMI.PresetPosition OR "Um2-1"(y := HMI.PresetPosition, coeff := Config.Ax_UM2) OR Ctrl.Preset) AND HMI.B_Preset) AND NOT (HMI.B_Preset_UM2)) OR (((HMI.PresetPosition OR "Um2-1"(y := HMI.PresetPosition, coeff := Config.Ax_UM2) OR Ctrl.Preset) AND HMI.B_Preset_UM2) AND NOT (HMI.B_Preset))) AND Sts.Preset_Cnd);
   END_REGION

   REGION "Man"
      Ctrl.Minus_Vel_Man := (((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND PE.PB_Minus) OR ((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND Ctrl.Minus_Vel_Man)) AND DataIn.PB.Bwd_Minus) AND NOT (DataIn.PB.Fwd_Plus));
      Ctrl.Plus_Vel_Man := (((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND PE.PB_Plus) OR ((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND Ctrl.Plus_Vel_Man)) AND DataIn.PB.Fwd_Plus) AND NOT (DataIn.PB.Bwd_Minus));
      Ctrl.MoveToPos_Man := (((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND PE.PB_MoveToPos) OR (((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND Ctrl.MoveToPos_Man)) AND DataIn.PB.MoveToPos);
      Ctrl.Minus_Pos_Man := (((((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND PE.PB_Minus) OR ((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND Ctrl.Minus_Pos_Man)) AND DataIn.PB.Bwd_Minus) AND NOT (DataIn.PB.Fwd_Plus));
      Ctrl.Plus_Pos_Man := (((((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND PE.PB_Plus) OR ((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND Ctrl.Plus_Pos_Man)) AND DataIn.PB.Fwd_Plus) AND NOT (DataIn.PB.Bwd_Minus));
   END_REGION

   REGION "Aut"
      Ctrl.MoveToPos_Aut := (CIn.Manager.Control_ON AND CIn.Manager.MoveToPos);
      Ctrl.Minus_Pos_Aut := (((CIn.Manager.Control_ON AND NOT (CIn.Manager.MoveToPos)) AND CIn.Manager.Minus) AND NOT (CIn.Manager.Plus));
      Ctrl.Plus_Pos_Aut := (((CIn.Manager.Control_ON AND NOT (CIn.Manager.MoveToPos)) AND CIn.Manager.Plus) AND NOT (CIn.Manager.Minus));
   END_REGION

   REGION "Axis Limits"
      COut.MinPosition := Par.Minus_Limit; //+ #Par.PosTolerance ; 

      COut.MaxPosition := Par.Plus_Limit; //- #Par.PosTolerance;


      IF CIn.PositionLimits.EnableMin THEN
          COut.MinPosition := (IN1 := COut.MinPosition, IN2 := CIn.PositionLimits.PosMin);
      END_IF;

      IF CIn.PositionLimits.EnableMax THEN
          COut.MaxPosition := (IN1 := COut.MaxPosition, IN2 := CIn.PositionLimits.PosMax);
      END_IF;

   END_REGION

   REGION "Software Limit switches / External limits reached / exceed"
      COut.MinusLsSwReached := FALSE;
      COut.PlusLsSwReached := FALSE;
      COut.MinusLimitReached := FALSE;
      COut.PlusLimitReached := FALSE;


      IF Ax.AxisSts.Homed THEN

          COut.MinusLsSwReached := Warning.Ax.SwLimitMinus; //OR (ABS(#Sts.ActualPosition - #Par.Minus_Limit) <= #Par.PosTolerance);
          COut.PlusLsSwReached := Warning.Ax.SwLimitPlus; //OR (ABS(#Sts.ActualPosition - #Par.Plus_Limit) <= #Par.PosTolerance);
          
          
          IF NOT COut.MinusLsSwReached AND CIn.PositionLimits.EnableMin THEN
              
              COut.MinusLimitReached := (Sts.ActualPosition < COut.MinPosition) OR ((Sts.ActualPosition - COut.MinPosition) <= (Par.PosTolerance/2));
              
          END_IF;
          
          
          
          IF NOT COut.PlusLsSwReached  AND CIn.PositionLimits.EnableMax THEN
              
              COut.PlusLimitReached := (Sts.ActualPosition > COut.MaxPosition) OR ((Sts.ActualPosition - COut.MaxPosition) <= (Par.PosTolerance/2));
              
          END_IF;
          
      END_IF;


   END_REGION

   REGION "Target position"
      IF CIn.Manager.Control_ON THEN


          Ctrl.Pos := CIn.Manager.Pos;
          
          IF Ctrl.Minus_Pos_Aut THEN
              Ctrl.Pos := COut.MinPosition;
              
          ELSIF Ctrl.Plus_Pos_Aut THEN
              Ctrl.Pos := COut.MaxPosition;
          END_IF;
          
          
          HMI.TargetPosition := Ctrl.Pos;

      ELSE
          
          
          Ctrl.Pos := HMI.TargetPosition;
          
          IF Ctrl.Minus_Pos_Man THEN
              Ctrl.Pos := COut.MinPosition;
              HMI.TargetPosition := Ctrl.Pos;
              
          ELSIF Ctrl.Plus_Pos_Man THEN
              Ctrl.Pos := COut.MaxPosition;
              HMI.TargetPosition := Ctrl.Pos;
          END_IF;
          
      END_IF;





      //---   



      // Dynamics limiting
      // 

      Ctrl.Pos := (IN := Ctrl.Pos, MN := COut.MinPosition, MX := COut.MaxPosition);




          
          
          

   END_REGION

   REGION "Conditions"
      Sts.Gen_Cnd := (((((NOT (Ctrl.StopDueDoorOpeningRequest) AND NOT (DSI.SafeStop)) AND NOT (DSI.DevicesInSafeState)) AND NOT (Ctrl.StopAborting)) AND NOT (Ctrl.StopInPhase)) AND NOT (Ctrl.StopProgrammed));
      Sts.Gen_Cnd := (((Sts.Gen_Cnd AND NOT (Alarm.BrakeTimeOut)) AND NOT (Alarm.S120.Drive)) AND NOT (Alarm.S120_ComErr));
      Sts.Minus_Cnd := ((((Sts.Gen_Cnd AND CIn.MinusExtEnable) AND Ax.AxisSts.MoveMinusPermitted) AND S120.AxisSts.MoveMinusPermitted) OR (((Sts.Gen_Cnd AND CIn.MinusExtEnable) AND Ax.AxisSts.MoveAbsPermitted) AND S120.AxisSts.MoveMinusPermitted) OR (((Sts.Gen_Cnd AND CIn.MinusExtEnable) AND Ax.AxisSts.MoveAbsPermitted) AND S120.AxisSts.MovePlusPermitted));
      Sts.Plus_Cnd := ((((Sts.Gen_Cnd AND CIn.PlusExtEnable) AND Ax.AxisSts.MovePlusPermitted) AND S120.AxisSts.MovePlusPermitted) OR (((Sts.Gen_Cnd AND CIn.PlusExtEnable) AND Ax.AxisSts.MoveAbsPermitted) AND S120.AxisSts.MoveMinusPermitted) OR (((Sts.Gen_Cnd AND CIn.PlusExtEnable) AND Ax.AxisSts.MoveAbsPermitted) AND S120.AxisSts.MovePlusPermitted));
      Sts.Pos_Cnd := ((((Ctrl.Pos < Sts.ActualPosition) AND Sts.Minus_Cnd) OR ((Ctrl.Pos > Sts.ActualPosition) AND Sts.Plus_Cnd)) AND Ax.AxisSts.Homed);
   END_REGION

   REGION "On/Off Axis - Controls"
      Ax.AxisCtrl.SafeStop := DSI.DevicesInSafeState;
      Ax.AxisCtrl.Rst := AreaInterface.RstAlarms;
      Ctrl.Minus_Vel := NOT (NOT (Ctrl.Minus_Vel_Man));
      Ax.AxisCtrl.MoveMinus := (NOT (NOT (Ctrl.Minus_Vel_Man)) AND Sts.Minus_Cnd);
      Ctrl.Plus_Vel := NOT (NOT (Ctrl.Plus_Vel_Man));
      Ax.AxisCtrl.MovePlus := (NOT (NOT (Ctrl.Plus_Vel_Man)) AND Sts.Plus_Cnd);
      Ctrl.MoveToPos := (NOT ((NOT (Ctrl.Minus_Pos_Man) AND NOT (Ctrl.Plus_Pos_Man))) OR NOT ((NOT (Ctrl.Minus_Pos_Aut) AND NOT (Ctrl.Plus_Pos_Aut))) OR NOT ((NOT (Ctrl.MoveToPos_Aut) AND NOT (Ctrl.MoveToPos_Man))));
      Ax.AxisCtrl.MoveAbsolute := ((NOT ((NOT (Ctrl.Minus_Pos_Man) AND NOT (Ctrl.Plus_Pos_Man))) OR NOT ((NOT (Ctrl.Minus_Pos_Aut) AND NOT (Ctrl.Plus_Pos_Aut))) OR NOT ((NOT (Ctrl.MoveToPos_Aut) AND NOT (Ctrl.MoveToPos_Man)))) AND Sts.Pos_Cnd);
      Ax.AxisCtrl.MoveAbsTarget := Ctrl.Pos;
      Ax.AxisCtrl.Homing := 0;
   END_REGION

   REGION "On/Off Axis - Configuration"
      Ax.Config := Config.Ax;

      Ax.Config.limitMinus := Par.Minus_Limit;
      Ax.Config.limitPlus := Par.Plus_Limit;

      Ax.Config.ToleranceWindow := Par.PosTolerance;
      Ax.Config.PreCutOff := Par.PreCutOff;
      Ax.Config.PreEndMedSpeed := Par.PreEndMedSpeed;
      Ax.Config.PreEndLowSpeed := Par.PreEndLowSpeed;


      Ax.Config.StandStillDelay := ((Config.S120.DecTime + 0.1));



      IF Config.CyclicOBTime_ms <= 0.0 THEN
          
          Sts.Prv_SysTime := Sts.Act_SysTime;
          
          RETVAL := (Sts.Act_SysTime);
          
          Ax.Config.RecallTime := (((IN1 := Sts.Act_SysTime, IN2 := Sts.Prv_SysTime)));
          IF Ax.Config.RecallTime <= 1 THEN
              Ax.Config.RecallTime := 1;
          END_IF;
      ELSE
          
          Ax.Config.RecallTime := Config.CyclicOBTime_ms;
          
      END_IF;

   END_REGION

   REGION "On/Off Axis - Call"
      #Ax(
         en := TRUE,
         HwLsMinus := DataIn.LS_Minus,
         HwLsPlus := DataIn.LS_Plus,
         HwLsZero := FALSE,
         Interface := PosFeedback,
         Alarm := Alarm.Ax,
         Warning := Warning.Ax,
         AxisHomed := Pers_Data.AxisHomed
      );

      #Ax.Q;
   END_REGION

   REGION "On/Off Axis -Reset Wanrning"

      Warning.Ax.SwLimitMinus := ((Sts.ActualPosition - Par.Minus_Limit) <= (Par.PosTolerance / 2));
      Warning.Ax.SwLimitPlus := ((Sts.ActualPosition - Par.Plus_Limit) <= (Par.PosTolerance / 2));

   END_REGION

   REGION "S120 - Velocity & Dynamics"
      Ctrl.SpeedPercentage := Par.Man_Speed;

      IF CIn.Manager.Control_ON THEN
          Ctrl.SpeedPercentage := CIn.Manager.Speed;
      END_IF;

      Ctrl.SpeedPercentage := (IN1 := Ctrl.SpeedPercentage, IN2 := 100.0);
      Ctrl.SpeedPercentage := (IN1 := Ctrl.SpeedPercentage, IN2 := 0.0);


      Ctrl.Speed := 0.0;


      IF Ax.ActorCtrl.CmdLowSpeed THEN
             
          Ctrl.Speed := (Par.LowSpeed / 100.0) * Config.S120.SpeedMotor.ReferenceVelocity;
          
          
          IF NOT Ax.AxisCtrl.MoveAbsolute THEN
              
              Ctrl.Speed := Ctrl.Speed * Ctrl.SpeedPercentage / 100.0;
          END_IF;
          
          
      ELSIF Ax.ActorCtrl.CmdMediumSpeed THEN
          
          Ctrl.Speed := (Par.MedSpeed / 100.0) * Config.S120.SpeedMotor.ReferenceVelocity;
          
          Ctrl.Speed := Ctrl.Speed * Ctrl.SpeedPercentage / 100.0;
          
          
      ELSIF Ax.ActorCtrl.CmdHighSpeed THEN
          
          Ctrl.Speed := (Par.HighSpeed / 100.0) * Config.S120.SpeedMotor.ReferenceVelocity;
          
          Ctrl.Speed := Ctrl.Speed * Ctrl.SpeedPercentage / 100.0;
      END_IF;



      // Brake not open... Velocity  = 0.0
      // 
      IF Config.Brake_Presence AND NOT DataIn.Brake_M_Feedback THEN
          Ctrl.Speed := 0.0;
      END_IF;



      S120.AxisCtrl.Velocity := (IN1 := Ctrl.Speed , IN2 := Config.S120.SpeedMotor.ReferenceVelocity);

      S120.AxisCtrl.Acceleration := Config.S120.SpeedMotor.ReferenceVelocity / 60.0 / Config.S120.AccTime;
      S120.AxisCtrl.Deceleration := Config.S120.SpeedMotor.ReferenceVelocity / 60.0 / Config.S120.DecTime;


   END_REGION

   REGION "S120 - Control"
      S120.AxisCtrl.SafeStop := DSI.DevicesInSafeState;
      S120.AxisCtrl.Rst := AreaInterface.RstAlarms;
      S120.AxisCtrl.Power := (((CIn.Manager.Control_ON AND Config.Fan.Presence) OR CIn.ExternalPowerOn) AND NOT (Ctrl.StopDueDoorOpeningRequest));
      S120.AxisCtrl.MoveMinus := Ax.ActorCtrl.CmdMinus;
      S120.AxisCtrl.MovePlus := Ax.ActorCtrl.CmdPlus;
   END_REGION

   REGION "S120 - Call"
      #S120(
         en := TRUE,
         AxisConfig := Config.S120.SpeedMotor,
         Drive := Drive,
         PowerOffDelay := Config.S120.PowerOffDelay,
         StandtillVelocity := Config.S120.StandstillVelocity,
         StandstillDelay := Config.Ax.StandStillDelay,
         TEL1_IN := S120_STW_TEL1,
         TEL1_OUT := S120_ZSW_TEL1,
         Alarm := Alarm.S120,
         Warning := Warning.S120,
         Diag := Diag.S120
      );

      #S120.Q;
   END_REGION

   REGION "Mask warning 1699 = Test stop STO required"
      IF (Warning.S120.Drive AND (Diag.S120.Drive_Message = 1699)) THEN
         Warning.S120.Drive := FALSE;
      END_IF;
   END_REGION

   REGION "S120 - Alarm comunication (OUT)"
      #SETIO_ZSW_TEL1(
         en := TRUE,
         ID := HW_ID_TEL1,
         OUTPUTS := S120_ZSW_TEL1
      );

      #SETIO_ZSW_TEL1.Q;
      IF (GETIO_STW_TEL1.STATUS <> 0) THEN
         Alarm.S120_ComErr := TRUE;
      END_IF;
   END_REGION

   REGION "Run"
      #TON_Fan_DelayOff(
         IN := (NOT (Req) AND Ctrl.Fan),
         PT := Config.Fan.DelayOff
      );

      Req := NOT (((NOT (S120.AxisSts.Enabled) AND NOT (Ax.ActorCtrl.CmdMinus)) AND NOT (Ax.ActorCtrl.CmdPlus)));
      Ctrl.Fan := ((NOT (((NOT (S120.AxisSts.Enabled) AND NOT (Ax.ActorCtrl.CmdMinus)) AND NOT (Ax.ActorCtrl.CmdPlus))) OR Ctrl.Fan) AND Fan_M.MotorSts.RunPermitted);
      #TON_Fan_DelayOff.Q;
      IF #TON_Fan_DelayOff.Q THEN
         Ctrl.Fan := FALSE;
      END_IF;
   END_REGION

   REGION "Device"
      #Fan_M(
         en := Config.Fan.Presence,
         ThermalProtection := DataIn.Fan_M_ThermalProtection,
         FdbkRunning := DataIn.Fan_M_Feedback,
         FeedbackTimeout := T#1S,
         Alarm := Alarm.Fan_M,
         Contactor => DataOut.Fan_M_Contactor
      );

      Fan_M.MotorCtrl.SafeStop := AreaInterface.EStop;
      Fan_M.MotorCtrl.Rst := AreaInterface.RstAlarms;
      Fan_M.MotorCtrl.Run := Ctrl.Fan;
      IF Config.Fan.Presence THEN
         #Fan_M.Q;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         DataOut.Fan_M_Contactor := FALSE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Fan_M.MotorSts.RunPermitted := FALSE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Fan_M.MotorSts.Running := TRUE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Alarm.Fan_M.ThermalProtection := FALSE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Alarm.Fan_M.Feedback := FALSE;
      END_IF;
      IF NOT (Config.Fan.Presence) THEN
         Fan_M.MotorSts.AlarmPresence := FALSE;
      END_IF;
   END_REGION

   REGION "Coordination Out"
      "Um1-2"(
         en := LREAL_TO_REAL(Sts.ActualPosition),
         x := REAL_value,
         coeff := Config.Ax_UM2,
         Ret_Val => COut.ActualPosition_UM2
      );

      COut.CtrlSafe := (NOT (TON_NoPendingCmd.IN) OR (CIn.Manager.Control_ON AND NOT (Ctrl.StopDueDoorOpeningRequest)));
      COut.Infeed_ReqON := S120.Infeed_REQ_ON;
      COut.Homed := Ax.AxisSts.Homed;
      COut.Standstill := (Ax.AxisSts.StandStill AND S120.AxisSts.Standstill);
      COut.Enabled := S120.AxisSts.Enabled;
      COut.InPosition := Ax.AxisSts.InPosition;
      COut.MinusCheckNext := (Ctrl.Minus_Vel OR (Ctrl.MoveToPos AND (Ctrl.Pos < Sts.ActualPosition)));
      COut.PlusCheckNext := (Ctrl.Plus_Vel OR (Ctrl.MoveToPos AND (Ctrl.Pos > Sts.ActualPosition)));
      COut.MinusRunning := ((S120.AxisCtrl.MoveMinus AND S120.AxisSts.Enabled) AND (S120.AxisSts.ActualVelocity < 0.0));
      COut.PlusRunning := ((S120.AxisCtrl.MovePlus AND S120.AxisSts.Enabled) AND (S120.AxisSts.ActualVelocity > 0.0));
      COut.ActualPosition := Sts.ActualPosition;
      REAL_value := LREAL_TO_REAL(Sts.ActualPosition);
      IF LREAL_TO_REAL(Sts.ActualPosition) THEN
         COut.ActualPosition_UM2 := "Um1-2"(x := REAL_value, coeff := Config.Ax_UM2);
      END_IF;
   END_REGION

   REGION "Coordination Out - Actual speed drive 0-100 %"
      COut.ActualSpeed_Drive := S120.AxisSts.ActualVelocity / Config.S120.SpeedMotor.ReferenceVelocity * 100.0;

   END_REGION

   REGION "Warning Missing conditions"
      #TON_MinusCnd(
         IN := (COut.MinusCheckNext AND NOT (Sts.Minus_Cnd)),
         PT := Config.DelayMissingCondition
      );

      #TON_PlusCnd(
         IN := (COut.PlusCheckNext AND NOT (Sts.Plus_Cnd)),
         PT := Config.DelayMissingCondition
      );

      #TON_MinusCnd.Q;
      IF (COut.MinusCheckNext AND Sts.Minus_Cnd) THEN
         Warning.MissingCnd_Minus := FALSE;
      ELSIF #TON_MinusCnd.Q THEN
         Warning.MissingCnd_Minus := TRUE;
      END_IF;
      #TON_PlusCnd.Q;
      IF (COut.PlusCheckNext AND Sts.Plus_Cnd) THEN
         Warning.MissingCnd_Plus := FALSE;
      ELSIF #TON_PlusCnd.Q THEN
         Warning.MissingCnd_Plus := TRUE;
      END_IF;
   END_REGION

   REGION "Standstill"
      Sts.Standstill := (COut.Standstill OR DSI.DevicesInSafeState);
   END_REGION

   REGION "No pending commands"
      #TON_NoPendingCmd(
         IN := (((NOT (Sys.FirstPLCCycle) AND NOT (Ctrl.Minus_Vel)) AND NOT (Ctrl.Plus_Vel)) AND NOT (Ctrl.MoveToPos)),
         PT := t#1s
      );

      #TON_NoPendingCmd.Q;
   END_REGION

   REGION "Warning presence"
      Sts.WarningPresence := NOT (((((NOT (Warning.NotAutReady) AND NOT (Warning.MissingCnd_Minus)) AND NOT (Warning.MissingCnd_Plus)) AND NOT (Warning.Ax_NotHomed)) AND NOT (S120.AxisSts.WarningPresence)));
   END_REGION

   REGION "Alarm presence"
      Sts.AlarmPresence := NOT (((((((NOT (Alarm.BrakeTimeOut) AND NOT (Alarm.S120_ComErr)) AND NOT (Alarm.Ax_NotHomed)) AND NOT (Ax.AxisSts.AlarmPresence)) AND NOT (S120.AxisSts.AlarmPresence)) AND NOT (Fan_M.MotorSts.AlarmPresence)) AND NOT (CIn.ExternalAlarms)));
   END_REGION

   REGION "Stop aborting"
      Ctrl.StopAborting := (((AreaInterface.Cycle AND Sts.Standstill) OR (AreaInterface.Cycle AND Ctrl.StopAborting) OR AreaInterface.Aut OR CIn.Manager.Control_ON) AND Sts.AlarmPresence);
   END_REGION

   REGION "Collect machine to zone interface"
      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmPresence;
      MachineInterface.Aborting := Ctrl.StopAborting;
      MachineInterface.MotionsStandStill := TON_NoPendingCmd.Q AND Sts.Standstill;
      MachineInterface.AckStopInPhase := Ctrl.StopInPhase AND MachineInterface.MotionsStandStill;
      MachineInterface.AckStopProgrammed := Ctrl.StopProgrammed AND MachineInterface.MotionsStandStill;
      MachineInterface.AlarmsPresence := Sts.AlarmPresence;
      MachineInterface.WarningPresence := Sts.WarningPresence;

   END_REGION

   REGION "Warning Machine not ready for automatic"
      IF AreaInterface.Cycle THEN
         Warning.NotAutReady := FALSE;
      ELSIF (AreaInterface.CheckAutReady AND NOT (MachineInterface.AutReady)) THEN
         Warning.NotAutReady := TRUE;
      END_IF;
   END_REGION

   REGION "HMI Status Positioning DOL Machine"
      // Area dati Status per HMI sull'azionamento

      HMI.Sts.Enabled :=S120.AxisSts.Enabled ;
      HMI.Sts.Standstill := Sts.Standstill;
      HMI.Sts.Homed := COut.Homed;
      HMI.Sts.Alarm := Sts.AlarmPresence;
      HMI.Sts.Warning := Sts.WarningPresence;
      HMI.Sts.Plus_Run := COut.PlusRunning;
      HMI.Sts.Minus_Run := COut.MinusRunning;
      HMI.Sts.InTargetPos := Ax.AxisSts.InPosition;
      HMI.Sts.MinPosReached := COut.MinusLsSwReached OR COut.MinusLimitReached;
      HMI.Sts.MaxPosReached := COut.PlusLsSwReached OR COut.PlusLimitReached;
      HMI.Sts.TargetPos := COut.ActualTargetPos;
      HMI.Sts.ActualPos := COut.ActualPosition;
      HMI.Sts.ActualPos_UM2 := COut.ActualPosition_UM2;
      HMI.Sts.ActualVel := COut.ActualSpeed;



   END_REGION


END_FUNCTION_BLOCK
