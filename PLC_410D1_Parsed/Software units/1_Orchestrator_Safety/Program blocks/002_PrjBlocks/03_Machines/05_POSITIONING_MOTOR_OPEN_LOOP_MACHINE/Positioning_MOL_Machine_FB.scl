// Block: Positioning_MOL_Machine_FB
// Title: Init

FUNCTION_BLOCK "Positioning_MOL_Machine_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Init
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI : udt_DeviceSafetyInterface;
      DataIn : Positioning_MOL_Machine_DataIn;
      CIn : Positioning_MOL_Machine_CIn;
      Config : Positioning_MOL_Machine_Config;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      DataOut : Positioning_MOL_Machine_DataOut;
      COut : Positioning_MOL_Machine_COut;
   END_VAR

   VAR_IN_OUT
      PosFeedback : PosFbk_ITF;
      Par : Positioning_MOL_Machine_Par;
      Pers_Data : Positioning_MOL_Machine_Pers_Data;
      Warning : Positioning_MOL_Machine_Wng;
      Alarm : Positioning_MOL_Machine_Alr;
   END_VAR

   VAR
      InitDone : Bool;
      HMI : Struct
         Sts : "UDT_HMI-Sts_PosMOL-MchFB";
         B_Preset : Bool;
         B_Preset_UM2 : Bool;
         PresetPosition : LReal;
         TargetPosition : LReal;
      END_STRUCT;
      Sts : Struct
         Standstill : Bool;
         AlarmPresence : Bool;
         WarningPresence : Bool;
         Gen_Cnd : Bool;
         Minus_Cnd : Bool;
         Plus_Cnd : Bool;
         Pos_Cnd : Bool;
         Preset_Cnd : Bool;
         Minus_PosReached : Bool;
         Minus_PosExceeded : Bool;
         ActualPosition : LReal;
         Act_SysTime : DTL;
         Prv_SysTime : DTL;
      END_STRUCT;
      Ctrl : Struct
         StopDueDoorOpeningRequest : Bool;
         StopAborting : Bool;
         SafeMotionEnable : Bool;
         StopInPhase : Bool;
         StopProgrammed : Bool;
         Preset : Bool;
         Minus_Pos_Aut : Bool;
         Plus_Pos_Aut : Bool;
         Minus_Pos_Man : Bool;
         Plus_Pos_Man : Bool;
         Minus_Vel_Man : Bool;
         Plus_Vel_Man : Bool;
         MoveToPos_Aut : Bool;
         MoveToPos_Man : Bool;
         MoveToPos : Bool;
         Minus_Vel : Bool;
         Plus_Vel : Bool;
         Pos : LReal;
      END_STRUCT;
      Ax : OnOffAxis;
      Motor : MotorS;
      TON_NoPendingCmd : TON_TIME;
      TON_MinusCnd : TON_TIME;
      TON_PlusCnd : TON_TIME;
      AUX : Struct
         PB_Minus : Bool;
         PB_Plus : Bool;
         PB_MoveToPos : Bool;
         B_Preset : Bool;
         B_Preset_UM2 : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP
      PE : Struct
         PB_Minus : Bool;
         PB_Plus : Bool;
         PB_MoveToPos : Bool;
         B_Preset : Bool;
         B_Preset_UM2 : Bool;
      END_STRUCT;
      RETVAL : Int;
      REAL_value : Real;
   END_VAR


BEGIN
   REGION "Init"
      IF NOT InitDone THEN
          
          InitDone := TRUE;
          
          RETVAL := (Sts.Act_SysTime);
          
          Sts.Prv_SysTime := Sts.Act_SysTime;
          
      END_IF;



   END_REGION

   REGION "Reset"
      IF AreaInterface.RstAlarms THEN
          
          Alarm.Ax_NotHomed := FALSE;
          
          Warning.NotAutReady := FALSE;
          Warning.Minus_CndMissing := FALSE;
          Warning.Plus_CndMissing := FALSE;
          
      END_IF;


   END_REGION

   REGION "Actual Position"
      Sts.ActualPosition := PosFeedback.Sts.Position;

   END_REGION

   REGION "Machine stop movements due door open request"
      Ctrl.StopDueDoorOpeningRequest := (((((TON_NoPendingCmd.Q AND Sts.Standstill) OR Ctrl.StopDueDoorOpeningRequest) AND CIn.Manager.EnableStopDoorOpeningReq) AND ZSI.Door_NormalStop) AND NOT (ZSI.Door_Opened));
   END_REGION

   REGION "Stop in phase"
      IF NOT (AreaInterface.StopInPhase) THEN
         Ctrl.StopInPhase := FALSE;
      ELSIF AreaInterface.StopInPhase THEN
         Ctrl.StopInPhase := TRUE;
      END_IF;
   END_REGION

   REGION "Stop programmed"
      IF NOT (AreaInterface.StopProgrammed) THEN
         Ctrl.StopProgrammed := FALSE;
      ELSIF AreaInterface.StopProgrammed THEN
         Ctrl.StopProgrammed := TRUE;
      END_IF;
   END_REGION

   REGION "Alarm / Warning axis not homed"
      Warning.Ax_NotHomed := NOT (Ax.AxisSts.Homed);
      IF ((NOT (Ax.AxisSts.Homed) AND AreaInterface.Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Man)) THEN
         Alarm.Ax_NotHomed := TRUE;
      END_IF;
      IF ((NOT (Ax.AxisSts.Homed) AND AreaInterface.Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Aut) OR (NOT (Ax.AxisSts.Homed) AND Ctrl.MoveToPos_Man)) THEN
         Warning.Ax_NotHomed := FALSE;
      END_IF;
   END_REGION

   REGION "Buttons"
      PE.PB_Minus := PosEdge(DataIn.PB.Bwd_Minus);
      PE.PB_Plus := PosEdge(DataIn.PB.Fwd_Plus);
      PE.PB_MoveToPos := PosEdge(DataIn.PB.MoveToPos);
      PE.B_Preset := PosEdge(HMI.B_Preset);
      PE.B_Preset_UM2 := PosEdge(HMI.B_Preset_UM2);
   END_REGION

   REGION "Preset"
      "Um2-1"(
         en := PE.B_Preset_UM2,
         y := HMI.PresetPosition,
         coeff := Config.Ax_UM2,
         Ret_Val => Ax.AxisCtrl.HomePosition
      );

      Sts.Preset_Cnd := (AreaInterface.Man AND Ax.AxisSts.HomingPermitted);
      IF PE.B_Preset THEN
         Ax.AxisCtrl.HomePosition := HMI.PresetPosition;
      END_IF;
      IF PE.B_Preset_UM2 THEN
         Ax.AxisCtrl.HomePosition := "Um2-1"(y := HMI.PresetPosition, coeff := Config.Ax_UM2);
      END_IF;
      Ctrl.Preset := (((((HMI.PresetPosition OR "Um2-1"(y := HMI.PresetPosition, coeff := Config.Ax_UM2) OR Ctrl.Preset) AND HMI.B_Preset) AND NOT (HMI.B_Preset_UM2)) OR (((HMI.PresetPosition OR "Um2-1"(y := HMI.PresetPosition, coeff := Config.Ax_UM2) OR Ctrl.Preset) AND HMI.B_Preset_UM2) AND NOT (HMI.B_Preset))) AND Sts.Preset_Cnd);
   END_REGION

   REGION "Man"
      Ctrl.Minus_Vel_Man := (((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND PE.PB_Minus) OR ((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND Ctrl.Minus_Vel_Man)) AND DataIn.PB.Bwd_Minus) AND NOT (DataIn.PB.Fwd_Plus));
      Ctrl.Plus_Vel_Man := (((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND PE.PB_Plus) OR ((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND NOT (Ax.AxisSts.Homed)) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitMinus) OR ((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Alarm.Ax.HwLimitPlus)) AND Ctrl.Plus_Vel_Man)) AND DataIn.PB.Fwd_Plus) AND NOT (DataIn.PB.Bwd_Minus));
      Ctrl.MoveToPos_Man := (((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND PE.PB_MoveToPos) OR (((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND Ctrl.MoveToPos_Man)) AND DataIn.PB.MoveToPos);
      Ctrl.Minus_Pos_Man := (((((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND PE.PB_Minus) OR ((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND Ctrl.Minus_Pos_Man)) AND DataIn.PB.Bwd_Minus) AND NOT (DataIn.PB.Fwd_Plus));
      Ctrl.Plus_Pos_Man := (((((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND PE.PB_Plus) OR ((((((NOT (CIn.Manager.Control_ON) AND AreaInterface.Man) AND Ax.AxisSts.Homed) AND NOT (Alarm.Ax.HwLimitMinus)) AND NOT (Alarm.Ax.HwLimitPlus)) AND NOT (Ctrl.MoveToPos_Man)) AND Ctrl.Plus_Pos_Man)) AND DataIn.PB.Fwd_Plus) AND NOT (DataIn.PB.Bwd_Minus));
   END_REGION

   REGION "Aut"
      Ctrl.MoveToPos_Aut := (CIn.Manager.Control_ON AND CIn.Manager.MoveToPos);
      Ctrl.Minus_Pos_Aut := (((CIn.Manager.Control_ON AND NOT (CIn.Manager.MoveToPos)) AND CIn.Manager.Minus) AND NOT (CIn.Manager.Plus));
      Ctrl.Plus_Pos_Aut := (((CIn.Manager.Control_ON AND NOT (CIn.Manager.MoveToPos)) AND CIn.Manager.Plus) AND NOT (CIn.Manager.Minus));
   END_REGION

   REGION "Axis Limits"
      COut.MinPosition := Par.Minus_Limit;//+ #Par.PosTolerance ; 

      COut.MaxPosition := Par.Plus_Limit;// - #Par.PosTolerance;


      IF CIn.PositionLimits.EnableMin THEN
          COut.MinPosition := (IN1 := COut.MinPosition, IN2 := CIn.PositionLimits.PosMin);
      END_IF;

      IF CIn.PositionLimits.EnableMax THEN
          COut.MaxPosition := (IN1 := COut.MaxPosition, IN2 := CIn.PositionLimits.PosMax);
      END_IF;

   END_REGION

   REGION "Software Limit switches / External limits reached / exceed"
      COut.MinusLsSwReached := FALSE;
      COut.PlusLsSwReached := FALSE;
      COut.MinusLimitReached := FALSE;
      COut.PlusLimitReached := FALSE;


      IF Ax.AxisSts.Homed THEN
         
          COut.MinusLsSwReached := Warning.Ax.SwLimitMinus; //OR (ABS(#Sts.ActualPosition - #Par.Minus_Limit) <= #Par.PosTolerance);
          COut.PlusLsSwReached := Warning.Ax.SwLimitPlus; //OR (ABS(#Sts.ActualPosition - #Par.Plus_Limit) <= #Par.PosTolerance);
          
          
          IF NOT COut.MinusLsSwReached AND CIn.PositionLimits.EnableMin THEN
              
              COut.MinusLimitReached := (Sts.ActualPosition < COut.MinPosition) OR ((Sts.ActualPosition - COut.MinPosition) <= (Par.PosTolerance/2));
              
          END_IF;
          
          
          
          IF NOT COut.PlusLsSwReached  AND CIn.PositionLimits.EnableMax THEN
              
              COut.PlusLimitReached := (Sts.ActualPosition > COut.MaxPosition) OR ((Sts.ActualPosition - COut.MaxPosition) <= (Par.PosTolerance/2));
              
          END_IF;
          
      END_IF;


   END_REGION

   REGION "Target position"

      IF CIn.Manager.Control_ON THEN
          
          
          Ctrl.Pos := CIn.Manager.Pos;
          
          IF Ctrl.Minus_Pos_Aut THEN
              Ctrl.Pos := COut.MinPosition;
              
          ELSIF Ctrl.Plus_Pos_Aut THEN
              Ctrl.Pos :=  COut.MaxPosition;
          END_IF;
          
          
          HMI.TargetPosition := Ctrl.Pos;
          
          
      ELSE
          
          Ctrl.Pos := HMI.TargetPosition;
          
          
          
          IF Ctrl.Minus_Pos_Man THEN
              Ctrl.Pos := COut.MinPosition;
              HMI.TargetPosition := Ctrl.Pos;
              
              
              
          ELSIF Ctrl.Plus_Pos_Man THEN
              Ctrl.Pos := COut.MaxPosition;
              HMI.TargetPosition := Ctrl.Pos;
              
              
          END_IF;
          
      END_IF;



          
      //---   


      // Dynamics limiting
      // 

      Ctrl.Pos := (IN := Ctrl.Pos, MN := COut.MinPosition, MX := COut.MaxPosition);


          

   END_REGION

   REGION "Conditions"
      Sts.Gen_Cnd := (((((NOT (Ctrl.StopDueDoorOpeningRequest) AND NOT (DSI.SafeStop)) AND NOT (DSI.DevicesInSafeState)) AND NOT (Ctrl.StopAborting)) AND NOT (Ctrl.StopInPhase)) AND NOT (Ctrl.StopProgrammed));
      Sts.Gen_Cnd := (Sts.Gen_Cnd AND Motor.MotorSts.RunPermitted);
      Sts.Minus_Cnd := (((Sts.Gen_Cnd AND CIn.MinusExtEnable) AND Ax.AxisSts.MoveMinusPermitted) OR ((Sts.Gen_Cnd AND CIn.MinusExtEnable) AND Ax.AxisSts.MoveAbsPermitted));
      Sts.Plus_Cnd := (((Sts.Gen_Cnd AND CIn.PlusExtEnable) AND Ax.AxisSts.MovePlusPermitted) OR ((Sts.Gen_Cnd AND CIn.PlusExtEnable) AND Ax.AxisSts.MoveAbsPermitted));
      Sts.Pos_Cnd := ((((Ctrl.Pos < Sts.ActualPosition) AND Sts.Minus_Cnd) OR ((Ctrl.Pos > Sts.ActualPosition) AND Sts.Plus_Cnd)) AND Ax.AxisSts.Homed);
   END_REGION

   REGION "On/Off Axis - Controls"
      Ax.AxisCtrl.SafeStop := DSI.DevicesInSafeState;
      Ax.AxisCtrl.Rst := AreaInterface.RstAlarms;
      Ctrl.Minus_Vel := NOT (NOT (Ctrl.Minus_Vel_Man));
      Ax.AxisCtrl.MoveMinus := (NOT (NOT (Ctrl.Minus_Vel_Man)) AND Sts.Minus_Cnd);
      Ctrl.Plus_Vel := NOT (NOT (Ctrl.Plus_Vel_Man));
      Ax.AxisCtrl.MovePlus := (NOT (NOT (Ctrl.Plus_Vel_Man)) AND Sts.Plus_Cnd);
      Ctrl.MoveToPos := (NOT ((NOT (Ctrl.Minus_Pos_Man) AND NOT (Ctrl.Plus_Pos_Man))) OR NOT ((NOT (Ctrl.Minus_Pos_Aut) AND NOT (Ctrl.Plus_Pos_Aut))) OR NOT ((NOT (Ctrl.MoveToPos_Aut) AND NOT (Ctrl.MoveToPos_Man))));
      Ax.AxisCtrl.MoveAbsolute := ((NOT ((NOT (Ctrl.Minus_Pos_Man) AND NOT (Ctrl.Plus_Pos_Man))) OR NOT ((NOT (Ctrl.Minus_Pos_Aut) AND NOT (Ctrl.Plus_Pos_Aut))) OR NOT ((NOT (Ctrl.MoveToPos_Aut) AND NOT (Ctrl.MoveToPos_Man)))) AND Sts.Pos_Cnd);
      Ax.AxisCtrl.MoveAbsTarget := Ctrl.Pos;
      Ax.AxisCtrl.Homing := 0;
   END_REGION

   REGION "On/Off Axis - Configuration"
      Ax.Config := Config.Ax;

      Ax.Config.limitMinus := Par.Minus_Limit;
      Ax.Config.limitPlus := Par.Plus_Limit;
      Ax.Config.ToleranceWindow := Par.PosTolerance;
      Ax.Config.PreCutOff := Par.PreCutOff;


      IF Config.CyclicOBTime_ms <= 0.0 THEN
          
          Sts.Prv_SysTime := Sts.Act_SysTime;
          
          RETVAL := (Sts.Act_SysTime);
          
          Ax.Config.RecallTime := (((IN1 := Sts.Act_SysTime, IN2 := Sts.Prv_SysTime)));
      ELSE
          
          Ax.Config.RecallTime := Config.CyclicOBTime_ms;
      END_IF;

   END_REGION

   REGION "On/Off Axis - Call"
      #Ax(
         en := TRUE,
         HwLsMinus := DataIn.LS_Minus,
         HwLsPlus := DataIn.LS_Plus,
         HwLsZero := FALSE,
         Interface := PosFeedback,
         Alarm := Alarm.Ax,
         Warning := Warning.Ax,
         AxisHomed := Pers_Data.AxisHomed
      );

      #Ax.Q;
   END_REGION

   REGION "On/Off Axis -Reset Wanrning"
      Warning.Ax.SwLimitMinus := ((Sts.ActualPosition - Par.Minus_Limit) <= (Par.PosTolerance / 2));
      Warning.Ax.SwLimitPlus := ((Sts.ActualPosition - Par.Plus_Limit) <= (Par.PosTolerance / 2));

   END_REGION

   REGION "Motor - Controls"
      Motor.MotorCtrl.SafeStop := DSI.DevicesInSafeState;
      Motor.MotorCtrl.Rst := AreaInterface.RstAlarms;
      Motor.MotorCtrl.RunBkw := Ax.ActorCtrl.CmdMinus;
      Motor.MotorCtrl.RunFwd := Ax.ActorCtrl.CmdPlus;
   END_REGION

   REGION "Motor - Call"
      #Motor(
         en := TRUE,
         ThermalProtectionA := DataIn.M1_TherrmalProtection,
         ThermalProtectionB := DataIn.M2_TherrmalProtection,
         FdbkRunning := DataIn.M1M2_Feedback,
         FeedbackTimeout := T#500MS,
         ReversalTime := Config.Ax.ChangeDirectionDelay,
         BkwContactor => DataOut.M_Contactor_Minus,
         FwdContactor => DataOut.M_Contactor_Plus,
         Alarm => Alarm.Motor
      );

      #Motor.Q;
   END_REGION

   REGION "Coordination Out"
      "Um1-2"(
         en := LREAL_TO_REAL(Sts.ActualPosition),
         x := REAL_value,
         coeff := Config.Ax_UM2,
         Ret_Val => COut.ActualPosition_UM2
      );

      COut.CtrlSafe := (NOT (TON_NoPendingCmd.IN) OR (CIn.Manager.Control_ON AND NOT (Ctrl.StopDueDoorOpeningRequest)));
      COut.Homed := Ax.AxisSts.Homed;
      COut.Standstill := (Ax.AxisSts.StandStill AND NOT (Motor.MotorSts.Running));
      COut.InPosition := Ax.AxisSts.InPosition;
      COut.MinusCheckNext := (Ctrl.Minus_Vel OR (Ctrl.MoveToPos AND (Ctrl.Pos < Sts.ActualPosition)));
      COut.PlusCheckNext := (Ctrl.Plus_Vel OR (Ctrl.MoveToPos AND (Ctrl.Pos > Sts.ActualPosition)));
      COut.MinusRunning := (NOT (Ax.AxisSts.StandStill) AND DataOut.M_Contactor_Minus);
      COut.PlusRunning := (NOT (Ax.AxisSts.StandStill) AND DataOut.M_Contactor_Plus);
      COut.ActualPosition := Sts.ActualPosition;
      REAL_value := LREAL_TO_REAL(Sts.ActualPosition);
      IF LREAL_TO_REAL(Sts.ActualPosition) THEN
         COut.ActualPosition_UM2 := "Um1-2"(x := REAL_value, coeff := Config.Ax_UM2);
      END_IF;
   END_REGION

   REGION "Warning Missing condittions"
      #TON_MinusCnd(
         IN := (COut.MinusCheckNext AND NOT (Sts.Minus_Cnd)),
         PT := Config.DelayMissingCondition
      );

      #TON_PlusCnd(
         IN := (COut.PlusCheckNext AND NOT (Sts.Plus_Cnd)),
         PT := Config.DelayMissingCondition
      );

      #TON_MinusCnd.Q;
      IF (COut.MinusCheckNext AND Sts.Minus_Cnd) THEN
         Warning.Minus_CndMissing := FALSE;
      ELSIF #TON_MinusCnd.Q THEN
         Warning.Minus_CndMissing := TRUE;
      END_IF;
      #TON_PlusCnd.Q;
      IF (COut.PlusCheckNext AND Sts.Plus_Cnd) THEN
         Warning.Plus_CndMissing := FALSE;
      ELSIF #TON_PlusCnd.Q THEN
         Warning.Plus_CndMissing := TRUE;
      END_IF;
   END_REGION

   REGION "Standstill"
      Sts.Standstill := COut.Standstill;
   END_REGION

   REGION "No pending commands"
      #TON_NoPendingCmd(
         IN := (((NOT (Sys.FirstPLCCycle) AND NOT (Ctrl.Minus_Vel)) AND NOT (Ctrl.Plus_Vel)) AND NOT (Ctrl.MoveToPos)),
         PT := t#1s
      );

      #TON_NoPendingCmd.Q;
   END_REGION

   REGION "Warning presence"
      Sts.WarningPresence := NOT ((((NOT (Warning.NotAutReady) AND NOT (Warning.Minus_CndMissing)) AND NOT (Warning.Plus_CndMissing)) AND NOT (Warning.Ax_NotHomed)));
   END_REGION

   REGION "Alarm presence"
      Sts.AlarmPresence := NOT ((((NOT (Alarm.Ax_NotHomed) AND NOT (Ax.AxisSts.AlarmPresence)) AND NOT (Motor.MotorSts.AlarmPresence)) AND NOT (CIn.ExternalAlarms)));
   END_REGION

   REGION "Stop aborting"
      Ctrl.StopAborting := (((AreaInterface.Cycle AND Sts.Standstill) OR (AreaInterface.Cycle AND Ctrl.StopAborting) OR AreaInterface.Aut OR CIn.Manager.Control_ON) AND Sts.AlarmPresence);
   END_REGION

   REGION "Collect machine to zone interface"
      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmPresence;
      MachineInterface.Aborting := Ctrl.StopAborting;
      MachineInterface.MotionsStandStill := TON_NoPendingCmd.Q AND Sts.Standstill;
      MachineInterface.AckStopInPhase := Ctrl.StopInPhase AND MachineInterface.MotionsStandStill;
      MachineInterface.AckStopProgrammed := Ctrl.StopProgrammed AND MachineInterface.MotionsStandStill;
      MachineInterface.AlarmsPresence := Sts.AlarmPresence;
      MachineInterface.WarningPresence := Sts.WarningPresence;

   END_REGION

   REGION "Warning Machine not ready for automatic"
      IF AreaInterface.Cycle THEN
         Warning.NotAutReady := FALSE;
      ELSIF (AreaInterface.CheckAutReady AND NOT (MachineInterface.AutReady)) THEN
         Warning.NotAutReady := TRUE;
      END_IF;
   END_REGION

   REGION "HMI Status Positioning MOL Machine"
      // Area dati Status per HMI sull'azionamento

      HMI.Sts.Enabled := DataOut.M_Contactor_Minus OR DataOut.M_Contactor_Plus;
      HMI.Sts.Standstill := Sts.Standstill;
      HMI.Sts.Homed := COut.Homed;
      HMI.Sts.Alarm := Sts.AlarmPresence;
      HMI.Sts.Warning := Sts.WarningPresence;
      HMI.Sts.Plus_Run := COut.PlusRunning;
      HMI.Sts.Minus_Run := COut.MinusRunning;
      HMI.Sts.InTargetPos := Ax.AxisSts.InPosition;
      HMI.Sts.MinPosReached := COut.MinusLsSwReached OR COut.MinusLimitReached;
      HMI.Sts.MaxPosReached := COut.PlusLsSwReached OR COut.PlusLimitReached;
      HMI.Sts.TargetPos := COut.ActualTargetPos;
      HMI.Sts.ActualPos := COut.ActualPosition;
      HMI.Sts.ActualPos_UM2 := COut.ActualPosition_UM2;
      HMI.Sts.ActualVel := COut.ActualSpeed;



   END_REGION


END_FUNCTION_BLOCK
