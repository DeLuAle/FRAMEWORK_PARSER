// Block: A0301_Manager_FB
// Title:  °°°°°° FORZATURA PTrk °°°°°°°°°

FUNCTION_BLOCK "A0301_Manager_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
//  °°°°°° FORZATURA PTrk °°°°°°°°°
   VAR_INPUT
      AreaInterface : AreaInterface;
      DataIn : Struct
         SemiAut_Pb : Bool;
         P1 : Struct
            Sens_Ing : Array[1..3] of Bool;
            Sens_Out : Array[1..3] of Bool;
         END_STRUCT;
         P2 : Struct
            Sens_Ing : Array[1..3] of Bool;
            Sens_Out : Array[1..3] of Bool;
         END_STRUCT;
         P3 : Struct
            Sens_Ing : Array[1..3] of Bool;
            Sens_Out : Array[1..3] of Bool;
         END_STRUCT;
         P4 : Struct
            Sens_Ing : Array[1..3] of Bool;
            Sens_Out : Array[1..3] of Bool;
         END_STRUCT;
         P5 : Struct
            Sens_Fuori_Ingombro_A0301 : Bool;
         END_STRUCT;
      END_STRUCT;
      CIn : Struct
         Trasporto : SpeedMachine_COut;
         P1 : Struct
            Fermi : ValveMachine_COut;
            Sfalsatore : ValveMachine_COut;
         END_STRUCT;
         P2 : Struct
            Fermi : ValveMachine_COut;
            Sollevatore : ValveMachine_COut;
         END_STRUCT;
         P3 : Struct
            Fermi : ValveMachine_COut;
         END_STRUCT;
         P4 : Struct
            Fermi : ValveMachine_COut;
         END_STRUCT;
         P5 : Struct
            Sollevatori : ValveMachine_COut;
            Spintore_Lat : Struct
               Spin_Lat1 : Struct
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Rest : Bool;
                  Work : Bool;
               END_STRUCT;
               Spin_Lat2 : Struct
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Rest : Bool;
                  Work : Bool;
               END_STRUCT;
               Vrt_1 : ValveMachine_COut;
               Orz_1 : ValveMachine_COut;
               Vrt_2 : ValveMachine_COut;
               Orz_2 : ValveMachine_COut;
            END_STRUCT;
            SpintoreLong : Struct
               Ax : Positioning_EPOS_Machine_COut;
               Vert : ValveMachine_COut;
            END_STRUCT;
            SensUscitaBanco : Bool;
         END_STRUCT;
         Ribaltatore : Struct
            Solleva_Rib : ValveMachine_COut;
            Ax : Positioning_EPOS_Machine_COut;
            Sts_Ribaltatore : Struct
               Pos0_Reached : Bool;
               Pos1_Reached : Bool;
               Pos2_Reached : Bool;
               Pos3_Reached : Bool;
            END_STRUCT;
         END_STRUCT;
         SpintoreLong : Struct
            Ax_Sts : Struct
               PosAttesa_Reached : Bool;
               PosFineSpinta_Reached : Bool;
            END_STRUCT;
            Spin_Ev : ValveMachine_COut;
         END_STRUCT;
         ProdManager : Prod_Beam_Ctrl;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      COut : Struct
         P1 : Struct
            Fermi : ValveMachine_Manager;
            Pareggiatore : ValveMachine_Manager;
            ReqPTrk_A02 : Bool;
         END_STRUCT;
         P2 : Struct
            Fermi : ValveMachine_Manager;
            Sollevatore : ValveMachine_Manager;
         END_STRUCT;
         P3 : Struct
            Fermi : ValveMachine_Manager;
         END_STRUCT;
         P4 : Struct
            Fermi : ValveMachine_Manager;
         END_STRUCT;
         P5 : Struct
            Spintore_Lat_1 : ValveMachine_Manager;
            Spintore_Lat_2 : ValveMachine_Manager;
            Sollevatori : ValveMachine_Manager;
         END_STRUCT;
         Trasporto : SpeedMachine_CIn_Manager;
         Trasporto_Brw_Req : Bool;
         Trasporto_Frw_Req : Bool;
         Ribaltatore : Struct
            Solleva : ValveMachine_Manager;
            Ax : Positioning_EPOS_Machine_Manager;
            Ax_Req : Struct
               Pos0 : Bool;
               Pos1 : Bool;
               Pos2 : Bool;
               Pos3 : Bool;
            END_STRUCT;
            Solleva_REST_Req : Bool;
            Solleva_WORK_Req : Bool;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         DlySensorsON : Time;
         DlySensorsOFF : Time;
         TRK : Struct
            BTrk_MoveP4Exit : Time;
            BTrk_MoveToP5 : Time;
         END_STRUCT;
      END_STRUCT;
      Data : Struct
         LastCounter_PartMove_P2toP4 : LReal;
         LastCounter_PartMove_P1toP2 : LReal;
         LastCounter_PartMove_P1toP3 : LReal;
      END_STRUCT;
   END_VAR

   VAR
      Alarm : Struct
         WrongShiftDone : Bool;
         P2toP4_NotReached : Bool;
         P1toP2_NotReached : Bool;
         P1toP3_NotReached : Bool;
         PTrk_TO_BTrk : Struct
            Status : USInt;
         END_STRUCT;
         STOP_FineTurno : Bool;
         STOP_End_Of_Proroduction : Bool;
         STOP_ControlloQualita : Bool;
      END_STRUCT;
      Sts : Struct
         SemiAut : Struct
            ON : Bool;
            Request : Bool;
            MaterialFrw : Bool;
         END_STRUCT;
         P1 : Struct
            Fermi : Struct
               Sens_Ing : Bool;
               Sens_Out : Bool;
            END_STRUCT;
            Sfalsatura_OK : Bool;
         END_STRUCT;
         P2 : Struct
            Fermi : Struct
               Some_Sens_Ing : Bool;
               Sens_Ing : Bool;
               Sens_Out : Bool;
            END_STRUCT;
         END_STRUCT;
         P3 : Struct
            Fermi : Struct
               Some_Sens_Ing : Bool;
               Sens_Ing : Bool;
               Sens_Out : Bool;
            END_STRUCT;
         END_STRUCT;
         P4 : Struct
            Fermi : Struct
               Some_Sens_Ing : Bool;
               Sens_Ing : Bool;
               Sens_Out : Bool;
            END_STRUCT;
         END_STRUCT;
         A0301_Station1 : Struct
            ZoneEmpty : Bool;
            Trk : Struct
               Actual_O_ID : DInt;
               OLD_OID : DInt;
               A0301_PTrk_Absence : Bool;
               A0301_BTrk_Absence : Bool;
               Wait_A0301_Recive : Bool;
            END_STRUCT;
         END_STRUCT;
         Attrezzamento : Struct
            Ready : Bool;
            FindNewID : Bool;
            RequestNewPosition : Bool;
            OLD_OID : DInt;
         END_STRUCT;
         AlarmsPresence : Bool;
         WarningsPresence : Bool;
         IsStandstill : Bool;
      END_STRUCT;
      Ctrl : Struct
         Stop : Bool;
         TRK : Struct
            PTrk : Struct
               Start_Brw : Bool;
               Start_Frw : Bool;
               Pos1_TO_Pos3 : Bool;
               Pos1_TO_Pos2 : Bool;
               Pos2Entry_TO_Pos2Solleva : Bool;
               Paregg_Pos1_to_Pos2 : Bool;
               Paregg_Pos1_to_Pos3 : Bool;
            END_STRUCT;
            BTrk : Struct
               Pos2Up_TO_Pos2Down : Bool;
               WritePos2Up_TO_Pos2Down : Bool;
               Pos4_Entry_TO_Pos4_Exit : Bool;
               Pos4_Entry_Cndz_To_Exit : Bool;
               Pos4_Exit_TO_Pos4_to_Pos5 : Bool;
               Pos4_to_Pos5_TO_Pos5_Lat_Spin_Orz : Struct
                  Exe : Bool;
                  Solleva : Bool;
                  Trasla : Bool;
               END_STRUCT;
               Pos5_SpinLat_TO_Pos5_SpinLong : Bool;
            END_STRUCT;
            Ribaltatore : Struct
               MoveToPos0 : Bool;
               MoveToPos1 : Bool;
               MoveToPos2 : Bool;
               MoveToPos3 : Bool;
            END_STRUCT;
         END_STRUCT;
         P1 : Struct
            Fermi : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Pareggiatore : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            PartMove_P1toP3_Init : Bool;
            PartMove_P1toP2_Init : Bool;
         END_STRUCT;
         P2 : Struct
            Fermi : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Sollevatore : Struct
               EnableMove : Bool;
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            PartMove_P2toP4_Init : Bool;
         END_STRUCT;
         P3 : Struct
            Fermi : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
         P4 : Struct
            Fermi : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Part_Move_P2toP4_Init : Bool;
         END_STRUCT;
         P5 : Struct
            Spintore_Lat_1 : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Spintore_Lat_2 : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Sollevatori : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
         Ribaltatore : Struct
            Solleva : Struct
               EnableMove : Bool;
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
      END_STRUCT;
      Ctrl_Part_Move_P1toP2 : Check_Part_Movement;
      Ctrl_Part_Move_P1toP3 : Check_Part_Movement;
      Ctrl_Part_Move_P2toP4 : Check_Part_Movement;
      TON_Stop : IEC_TIMER;
      TON : Struct
         BTrk_MoveP4Exit : TON_TIME;
         BTrk_MoveToP5 : TON_TIME;
         Delay_Pos1Ribalta : TON_TIME;
         P1 : Struct
            Sens_Ing : Struct
               DelayOn : TON_TIME;
            END_STRUCT;
            Sens_Out : Struct
               DelayOff : TOF_TIME;
            END_STRUCT;
         END_STRUCT;
         P2 : Struct
            Sens_Ing : Struct
               DelayOn : TON_TIME;
            END_STRUCT;
            Sens_Out : Struct
               DelayOff : TOF_TIME;
            END_STRUCT;
         END_STRUCT;
         P3 : Struct
            Sens_Ing : Struct
               DelayOn : TON_TIME;
            END_STRUCT;
            Sens_Out : Struct
               DelayOff : TOF_TIME;
            END_STRUCT;
         END_STRUCT;
         P4 : Struct
            Sens_Ing : Struct
               DelayOn : TON_TIME;
            END_STRUCT;
            Sens_Out : Struct
               DelayOff : TOF_TIME;
            END_STRUCT;
         END_STRUCT;
         P1_Exit_P3 : IEC_TIMER;
         P1_Exit_P2 : IEC_TIMER;
      END_STRUCT;
      HMI : Struct
         B_ResetShiftDone : Bool;
      END_STRUCT;
      AUX : Struct
         SemiAut_Pb : Bool;
         B_ResetShiftDone : Bool;
      END_STRUCT;
      BTrk_Item : Struct
         O_ID : DInt;
         BLean : Real;
         W_A : Real;
         H_B : Real;
         Tol_Max : Real;
         Tol_Min : Real;
         Good : Bool;
         Bad : Bool;
      END_STRUCT;
      PLen_Pos1 : Real;
      PLen_Pos3 : Real;
   END_VAR

   VAR_TEMP
      i : Int;
      j : Int;
      SensorToUse : Struct
         P1_In : Array[1..3] of Bool;
         P1_Out : Array[1..3] of Bool;
         P2_In : Array[1..3] of Bool;
         P2_Out : Array[1..3] of Bool;
         P3_In : Array[1..3] of Bool;
         P3_Out : Array[1..3] of Bool;
         P4_In : Array[1..3] of Bool;
         P4_Out : Array[1..3] of Bool;
      END_STRUCT;
      P1 : Struct
         Cndz1_P1toP3 : Bool;
         Cndz2_P1toP3 : Bool;
      END_STRUCT;
      Trk_GetData : Struct
         indx : Int;
         Sts : Int;
         Item : Prod_Item_small;
      END_STRUCT;
      Sens : Struct
         P1_IngOn : Bool;
         P1_OutOn : Bool;
         P2_IngOn : Bool;
         P3_IngOn : Bool;
         P3_OutOn : Bool;
         P4_IngOn : Bool;
         P4_OutOn : Bool;
      END_STRUCT;
   END_VAR


BEGIN
   REGION "°°°°°° FORZATURA PTrk °°°°°°°°°"
      IF A03_DEBUG.A0301_Manager.PTrk_Pos1_Write THEN
         PTrk.A0301.P[1] := A03_DEBUG.A301_PTrk;
      END_IF;
   END_REGION

   REGION "= Area - Rst ="
      IF AreaInterface.RstAlarms THEN
          Alarm.WrongShiftDone := FALSE;
          Alarm.P2toP4_NotReached:= FALSE;
          Alarm.P1toP2_NotReached:=FALSE;
          Alarm.P1toP3_NotReached := FALSE;
          //
          Alarm.STOP_ControlloQualita := FALSE;
          Alarm.STOP_FineTurno := FALSE;
          Alarm.STOP_End_Of_Proroduction := FALSE;
      END_IF;

   END_REGION

   REGION "Semiautomatico Pb"
      Sts.SemiAut.MaterialFrw := ((NOT (NOT (DataIn.SemiAut_Pb)) AND DataIn.SemiAut_Pb) OR (NOT (NOT (DataIn.SemiAut_Pb)) AND Sts.SemiAut.ON));
      Sts.SemiAut.ON := ((PosEdge(DataIn.SemiAut_Pb) OR Sts.SemiAut.ON) AND Sts.SemiAut.MaterialFrw);
   END_REGION

   REGION "== Cerco order ID nelle macchine precedenti e leggo i dati dal MES=="
      Sts.Attrezzamento.FindNewID := Sts.A0301_Station1.ZoneEmpty;
      IF (((Trk_GetData.Sts >= 0) AND (Trk_GetData.Item.Beam_Code = 1)) OR ((Trk_GetData.Sts >= 0) AND A03_DEBUG.A0301_Manager.BeamCode)) THEN
         BTrk_Item.O_ID := Trk_GetData.Item.O_ID;
      END_IF;
   END_REGION

   REGION "== CONTROLLO TRACKING E STAZIONE PER AVANZAMENTO O_ID =="
      REGION CONTROLLO (TRK EMPTY) SU STAZIONE 1 RIBALTAMENTO A0301 
          // Controllo zona libera dai traking e sensori non in lettura su stazione A0301
          // 
          FOR i := 1 TO BTRK_A0301_ITEMS DO
              IF BTrk.A0301.B[i].B_ID = 0 THEN
                  Sts.A0301_Station1.Trk.A0301_BTrk_Absence := TRUE;
              ELSE
                  Sts.A0301_Station1.Trk.A0301_BTrk_Absence := FALSE;
                  EXIT;
              END_IF;
          END_FOR;
          //
          FOR j := 2 TO PTRK_A0301_ITEMS DO
              IF PTrk.A0301.P[j].P_ID = 0 THEN
                  Sts.A0301_Station1.Trk.A0301_PTrk_Absence := TRUE;
              ELSE
                  Sts.A0301_Station1.Trk.A0301_PTrk_Absence := FALSE;
                  EXIT;
              END_IF;
          END_FOR;
          
      END_REGION

      REGION CONTROLLO CHE CI SIANO LE CONDIZIONI PER MANDARE AVANTI IL NUOVO ID SU STAZIONE 1 RIBALTAMENTO A0301 (TRK EMPTY)
          
          // Verifica A0301 VUOTA se PTrk o BTrk assente e sensori su Stazione 1 non in lettura
          Sts.A0301_Station1.ZoneEmpty := Sts.A0301_Station1.Trk.A0301_PTrk_Absence AND Sts.A0301_Station1.Trk.A0301_BTrk_Absence AND
          (NOT Sts.P1.Fermi.Sens_Out AND
          NOT Sts.P2.Fermi.Sens_Ing AND NOT Sts.P1.Fermi.Sens_Out AND
          NOT Sts.P3.Fermi.Sens_Ing AND NOT Sts.P3.Fermi.Sens_Out AND
          NOT Sts.P4.Fermi.Sens_Ing AND NOT Sts.P4.Fermi.Sens_Out);
          
          
          //Se ho O_ID <> e non sono vuoto attivo avviso di attesa zona A0302 vuota
          IF (Sts.A0301_Station1.Trk.Actual_O_ID <> Sts.A0301_Station1.Trk.OLD_OID) OR NOT Sts.A0301_Station1.ZoneEmpty THEN
              Sts.A0301_Station1.Trk.Wait_A0301_Recive := TRUE;
          ELSIF (Sts.A0301_Station1.Trk.Actual_O_ID = Sts.A0301_Station1.Trk.OLD_OID) OR Sts.A0301_Station1.ZoneEmpty THEN
              Sts.A0301_Station1.Trk.Wait_A0301_Recive := FALSE;
          END_IF;
          
          //Se ho O_ID <> e sono vuoto aggiorno vecchio O_ID 
          IF (Sts.A0301_Station1.Trk.Actual_O_ID <> Sts.A0301_Station1.Trk.OLD_OID) AND Sts.A0301_Station1.ZoneEmpty THEN
              Sts.A0301_Station1.Trk.OLD_OID := Sts.A0301_Station1.Trk.Actual_O_ID;
          END_IF;
          
      END_REGION


   END_REGION

   REGION "== Compilo i dati del BTrk in base all'order ID in arrivo =="

      IF Trk_GetData.Sts >= 0 THEN
          
          BTrk.A0301.O_ID :=   Sts.A0301_Station1.Trk.OLD_OID;
          BTrk.A0301.Beam_Len := BTrk_Item.BLean;
          BTrk.A0301.Beam_W_A := BTrk_Item.W_A;
          BTrk.A0301.Beam_H_B := BTrk_Item.H_B;
          
      ELSE
               BTrk.A0301.O_ID := -1;
               BTrk.A0301.Beam_Len := -1.0;
               BTrk.A0301.Beam_W_A := -1.0;
               BTrk.A0301.Beam_H_B := -1.0;
      END_IF;

   END_REGION

   REGION "[P1] = Enable/Disable Sensors Pin & Controllo e Stato dei sensori =="
      #TON.P1.Sens_Ing.DelayOn(
         IN := Sens.P1_IngOn,
         PT := A0301_PERS.SensTime.P1.Sens_Ing.DelayOn
      );

      #TON.P1.Sens_Out.DelayOff(
         IN := Sens.P1_OutOn,
         PT := A0301_PERS.SensTime.P1.Sens_Out.DelayOff
      );

      PLen_Pos1 := PTrk.A0301.P.PLen_Meas;
      Sts.P1.Fermi.Sens_Ing := (#TON.P1.Sens_Ing.DelayOn.Q AND TON.P1.Sens_Ing.DelayOn.Q);
      Sts.P1.Fermi.Sens_Out := (#TON.P1.Sens_Out.DelayOff.Q AND TON.P1.Sens_Out.DelayOff.Q);
   END_REGION

   REGION "[P2] = Enable/Disable Sensors Pin & Controllo e Stato dei sensori =="
      #TON.P2.Sens_Ing.DelayOn(
         IN := Sens.P2_IngOn,
         PT := A0301_PERS.SensTime.P2.Sens_Ing.DelayOn
      );

      #TON.P2.Sens_Out.DelayOff(
         IN := TON.P2.Sens_Ing.DelayOn.Q,
         PT := A0301_PERS.SensTime.P2.Sens_Out.DelayOff
      );

      Sts.P2.Fermi.Sens_Ing := (#TON.P2.Sens_Out.DelayOff.Q AND TON.P2.Sens_Out.DelayOff.Q);
   END_REGION

   REGION "[P3] = Enable/Disable Sensors Pin & Controllo e Stato dei sensori =="
      #TON.P3.Sens_Ing.DelayOn(
         IN := Sens.P3_IngOn,
         PT := A0301_PERS.SensTime.P3.Sens_Ing.DelayOn
      );

      #TON.P3.Sens_Out.DelayOff(
         IN := Sens.P3_OutOn,
         PT := A0301_PERS.SensTime.P3.Sens_Out.DelayOff
      );

      PLen_Pos3 := BTrk.A0301.B.BLen_Meas;
      Sts.P3.Fermi.Sens_Ing := (#TON.P3.Sens_Ing.DelayOn.Q AND TON.P3.Sens_Ing.DelayOn.Q);
      Sts.P3.Fermi.Sens_Out := (#TON.P3.Sens_Out.DelayOff.Q AND TON.P3.Sens_Out.DelayOff.Q);
   END_REGION

   REGION "[P4] = Enable/Disable Sensors Pin & Controllo e Stato dei sensori =="
      #TON.P4.Sens_Ing.DelayOn(
         IN := Sens.P4_IngOn,
         PT := A0301_PERS.SensTime.P4.Sens_Ing.DelayOn
      );

      #TON.P4.Sens_Out.DelayOff(
         IN := Sens.P4_OutOn,
         PT := A0301_PERS.SensTime.P4.Sens_Out.DelayOff
      );

      Sts.P4.Fermi.Sens_Ing := (#TON.P4.Sens_Ing.DelayOn.Q AND TON.P4.Sens_Ing.DelayOn.Q);
      Sts.P4.Fermi.Sens_Out := (#TON.P4.Sens_Out.DelayOff.Q AND TON.P4.Sens_Out.DelayOff.Q);
   END_REGION

   REGION "[Ax] Trasporto - Controllo condizioni di START - Fwd"
      Ctrl.TRK.PTrk.Start_Frw := (??? OR ((??? OR ??? OR ???) AND CIn.P4.Fermi.Work) OR FALSE OR ??? OR ??? OR A03_DEBUG.A0301_Manager.TrasportoStart OR ??? OR ??? OR ((((??? OR ???) AND CIn.P2.Fermi.Rest) AND CIn.Ribaltatore.Solleva_Rib.Rest) AND CIn.P3.Fermi.Work) OR ??? OR (((??? OR ??? OR ???) AND CIn.P2.Fermi.Work) AND CIn.P2.Sollevatore.Rest) OR (((??? OR ??? OR ???) AND CIn.Ribaltatore.Solleva_Rib.Rest) AND CIn.P4.Fermi.Work) OR ???);
   END_REGION

   REGION "[Ax] Trasporto - COut Manager"
      COut.Trasporto_Brw_Req := (Ctrl.TRK.PTrk.Start_Brw AND FALSE);
      COut.Trasporto_Frw_Req := Ctrl.TRK.PTrk.Start_Frw;
      COut.Trasporto.Bwd := ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.TRK.PTrk.Start_Brw) AND FALSE);
      COut.Trasporto.Fwd := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.TRK.PTrk.Start_Frw);
      COut.Trasporto.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Trasporto.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Trasporto.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Trasporto.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
      IF (Sts.SemiAut.ON AND NOT (AreaInterface.Cycle)) THEN
         COut.Trasporto.Vel := A0301_Trasporto_PERS.Par.Ax_Aut.SemiAut_Vel;
      END_IF;
   END_REGION

   REGION "Richiesta Pezzo Area 02"
      COut.P1.ReqPTrk_A02 := ???;
   END_REGION

   REGION "[P1] Condizioni di allarme Pareggiatore del pezzo"
      Alarm.WrongShiftDone := ???;
      IF ((PosEdge(HMI.B_ResetShiftDone) AND AreaInterface.Man) AND PTrk.A0301.P.ShiftDone) THEN
         PTrk.A0301.P.ShiftDone := FALSE;
      END_IF;
   END_REGION

   REGION "[P1] Richiesta movimento Part agli stopper P2"
      Ctrl.TRK.PTrk.Pos1_TO_Pos2 := ???;
   END_REGION

   REGION "[P1] Richiesta movimento Part agli stopper P3"
      P1.Cndz1_P1toP3 := ???;
      P1.Cndz2_P1toP3 := ???;
      Ctrl.TRK.PTrk.Pos1_TO_Pos3 := (P1.Cndz1_P1toP3 OR P1.Cndz2_P1toP3);
   END_REGION

   REGION "P[Pareggiatore] Pareggiamento su A03 Pos.1 eseguito"
      Ctrl.TRK.PTrk.Paregg_Pos1_to_Pos3 := ???;
      IF ??? THEN
         PTrk.A0301.P.ShiftDone := TRUE;
      END_IF;
      Ctrl.TRK.PTrk.Paregg_Pos1_to_Pos2 := ???;
   END_REGION

   REGION "[P1] Movimento PTRK da Pos1 Entry  == a==> P1 Exit P2 / P1 exit P3"
      PTrk.A0301.P := PTrk.A0301.P;
      IF PTrk.A0301.P THEN
         Ctrl.P1.PartMove_P1toP2_Init := TRUE;
      END_IF;
      IF PTrk.A0301.P THEN
         Ctrl.P1.PartMove_P1toP3_Init := TRUE;
      END_IF;
   END_REGION

   REGION "[P1] Movimento PTRK da Pos1 exit Pos.3 ==a==> Pos1_To_Pos3"
      // Salvo la quota nastro appena dopo la perdita del sensore presenza prodotto da Pos.1 e
// azzero il PTrk su "Pos1ExitToP3" perchè passato avanti

      #TON.P1_Exit_P3(
         PT := T#800MS
      );

      IF #TON.P1_Exit_P3.Q THEN
         PTrk.A0301.P := PTrk.A0301.P;
      END_IF;
   END_REGION

   REGION "== Monitoraggio spazio di trasporto del movimento PTrk da Pos.1 a Pos.3 =="
      // Controllo la posizione salvata da Pos.1 exit + Distanza sensori Pos.1 / Pos.3 = Target da raggiungere

      #Ctrl_Part_Move_P1toP3(
         en := TRUE,
         Init := ((NOT (Ctrl.P1.PartMove_P1toP3_Init) OR Sys.Bit1) AND A03_DEBUG.A0301_Manager.P1-P3_Init),
         TriggerNegPos := TRUE,
         S1 := Sts.P1.Fermi.Sens_Ing,
         S2 := Sts.P3.Fermi.Sens_Ing,
         V_Counter := Area0301_V_Counter.Value,
         DistanceToTravel := #A0301_Distanza_P1toP3,
         Tolerance_Reached := #A0301_Tollerance,
         Delta_TooEarly := 1.5,
         Delta_NotReached := 720.0,
         V_Counter_Save := Data.LastCounter_PartMove_P1toP3
      );

      IF ((((Sts.P3.Fermi.Some_Sens_Ing AND NOT (Sts.P3.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP3.S2_Reached)) AND Ctrl_Part_Move_P1toP3.Err_S2_ON) OR (((Sts.P3.Fermi.Some_Sens_Ing AND NOT (Sts.P3.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP3.S2_Reached)) AND Ctrl_Part_Move_P1toP3.Err_S2_OFF)) THEN
         Alarm.P1toP3_NotReached := TRUE;
      END_IF;
      IF ((((Sts.P3.Fermi.Some_Sens_Ing AND NOT (Sts.P3.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP3.S2_Reached)) AND Ctrl_Part_Move_P1toP3.Err_S2_ON) OR (((Sts.P3.Fermi.Some_Sens_Ing AND NOT (Sts.P3.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP3.S2_Reached)) AND Ctrl_Part_Move_P1toP3.Err_S2_OFF)) THEN
         Ctrl.P1.PartMove_P1toP3_Init := FALSE;
      END_IF;
   END_REGION

   REGION "[P1] Movimento PTRK da Pos1 to Pos.3 ==a==> Pos3_Entry + gest. allarme"
      Sts.P3.Fermi.Some_Sens_Ing := (??? OR ??? OR ???);
      IF (((Sts.P3.Fermi.Some_Sens_Ing AND Sts.P3.Fermi.Sens_Ing) AND Ctrl_Part_Move_P1toP3.S2_Reached) OR ((Sts.P3.Fermi.Some_Sens_Ing AND Sts.P3.Fermi.Sens_Ing) AND Sys.Bit1)) THEN
         PTrk.A0301.P := PTrk.A0301.P;
      END_IF;
      IF PTrk.A0301.P THEN
         Ctrl.P1.PartMove_P1toP3_Init := FALSE;
      END_IF;
   END_REGION

   REGION "[P1] Movimento PTRK da Pos1 exit Pos.2 ==a==> Pos1_To_Pos2"
      // Salvo la quota nastro appena dopo la perdita del sensore presenza prodotto da Pos.1 e
// azzero il PTrk su "Pos1ExitToP2" perchè passato avanti

      #TON.P1_Exit_P2(
         PT := T#800MS
      );

      IF #TON.P1_Exit_P2.Q THEN
         PTrk.A0301.P := PTrk.A0301.P;
      END_IF;
   END_REGION

   REGION "== Monitoraggio spazio di trasporto del movimento PTrk da Pos.1 a Pos.2 =="
      // Controllo la posizione salvata da Pos.1entry + Distanza sensori Pos.1 / Pos.2 = Target da raggiungere

      #Ctrl_Part_Move_P1toP2(
         en := TRUE,
         Init := NOT (Ctrl.P1.PartMove_P1toP2_Init),
         TriggerNegPos := TRUE,
         S1 := Sts.P1.Fermi.Sens_Ing,
         S2 := Sts.P2.Fermi.Sens_Ing,
         V_Counter := Area0301_V_Counter.Value,
         DistanceToTravel := #A0301_Distanza_P1toP2,
         Tolerance_Reached := #A0301_Tollerance,
         Delta_TooEarly := 10.0,
         Delta_NotReached := 370.0,
         V_Counter_Save := Data.LastCounter_PartMove_P1toP2
      );

      IF (((((Sts.P2.Fermi.Some_Sens_Ing AND Sts.P2.Fermi.Some_Sens_Ing) AND NOT (Sts.P2.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP2.S2_Reached)) AND Ctrl_Part_Move_P1toP2.Err_S2_ON) OR ((((Sts.P2.Fermi.Some_Sens_Ing AND Sts.P2.Fermi.Some_Sens_Ing) AND NOT (Sts.P2.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP2.S2_Reached)) AND Ctrl_Part_Move_P1toP2.Err_S2_OFF)) THEN
         Alarm.P1toP2_NotReached := TRUE;
      END_IF;
      IF (((((Sts.P2.Fermi.Some_Sens_Ing AND Sts.P2.Fermi.Some_Sens_Ing) AND NOT (Sts.P2.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP2.S2_Reached)) AND Ctrl_Part_Move_P1toP2.Err_S2_ON) OR ((((Sts.P2.Fermi.Some_Sens_Ing AND Sts.P2.Fermi.Some_Sens_Ing) AND NOT (Sts.P2.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P1toP2.S2_Reached)) AND Ctrl_Part_Move_P1toP2.Err_S2_OFF)) THEN
         Ctrl.P1.PartMove_P1toP2_Init := FALSE;
      END_IF;
   END_REGION

   REGION "[P1] Movimento PTRK da Pos1 to Pos.2 ==a==> Pos2_Entry + gest. allarme"
      Sts.P2.Fermi.Some_Sens_Ing := (??? OR ??? OR ???);
      IF (((Sts.P2.Fermi.Some_Sens_Ing AND Sts.P2.Fermi.Sens_Ing) AND Ctrl_Part_Move_P1toP2.S2_Reached) OR ((Sts.P2.Fermi.Some_Sens_Ing AND Sts.P2.Fermi.Sens_Ing) AND Sys.Bit1)) THEN
         PTrk.A0301.P := PTrk.A0301.P;
      END_IF;
      IF PTrk.A0301.P THEN
         Ctrl.P1.PartMove_P1toP2_Init := FALSE;
      END_IF;
   END_REGION

   REGION "[P1] Fermi - Movimento operazione a lavoro / a riposo"
      Ctrl.P1.Fermi.Rest := (((??? OR ???) AND (BTrk.A0301.B.B_ID <> 0)) OR ((??? OR ???) AND (BTrk.A0301.B.B_ID <> 0)) OR ((??? OR ???) AND (BTrk.A0301.B.B_ID <> 0)) OR ((((??? OR ???) AND (BTrk.A0301.B.B_ID = 0)) AND (BTrk.A0301.B.B_ID = 0)) AND (BTrk.A0301.B.B_ID = 0)) OR ((??? OR ???) AND CIn.P2.Fermi.Work));
      Ctrl.P1.Fermi.Work := NOT (Ctrl.P1.Fermi.Rest);
   END_REGION

   REGION "[P1] Pareggiatore - Movimento operazione a lavoro / a riposo"
      Ctrl.P1.Pareggiatore.Work := ???;
      Ctrl.P1.Pareggiatore.Rest := ((((Ctrl.TRK.PTrk.Paregg_Pos1_to_Pos3 AND CIn.P1.Sfalsatore.Work) AND NOT (CIn.P1.Sfalsatore.Rest)) AND PTrk.A0301.P.ShiftDone) OR ??? OR Sys.Bit1);
   END_REGION

   REGION "[P1] Fermi / [P1] Pareggiatore - COut Manager"
      COut.P1.Fermi.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P1.Fermi.Rest);
      COut.P1.Fermi.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P1.Fermi.Work);
      COut.P1.Pareggiatore.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P1.Pareggiatore.Rest);
      COut.P1.Pareggiatore.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P1.Pareggiatore.Work);
      COut.P1.Fermi.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P1.Pareggiatore.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P1.Fermi.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P1.Pareggiatore.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P1.Fermi.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P1.Pareggiatore.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P1.Fermi.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
      COut.P1.Pareggiatore.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P2] Movimento PTRK da Pos2 Entry  ==a==>  Pos2 Solleva"
      Ctrl.TRK.PTrk.Pos2Entry_TO_Pos2Solleva := ???;
      IF (Ctrl.TRK.PTrk.Pos2Entry_TO_Pos2Solleva AND CIn.P2.Sollevatore.Work) THEN
         PTrk.A0301.P := PTrk.A0301.P;
      END_IF;
   END_REGION

   REGION "[P2] Fermi - Movimento operazione a lavoro / a riposo"
      Ctrl.P2.Fermi.Rest := (??? OR ??? OR ??? OR ??? OR ??? OR ??? OR ??? OR ??? OR ???);
      Ctrl.P2.Fermi.Work := NOT (Ctrl.P2.Fermi.Rest);
   END_REGION

   REGION "[P2] Fermi - COut Manager"
      COut.P2.Fermi.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P2.Fermi.Rest);
      COut.P2.Fermi.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P2.Fermi.Work);
      COut.P2.Fermi.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P2.Fermi.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P2.Fermi.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P2.Fermi.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P2] Sollevatore - Movimento operazione a lavoro / a riposo"
      Ctrl.P2.Sollevatore.EnableMove := ((Ctrl.TRK.PTrk.Pos2Entry_TO_Pos2Solleva AND Sts.P2.Fermi.Sens_Ing) OR (Ctrl.TRK.PTrk.Pos2Entry_TO_Pos2Solleva AND Ctrl.P2.Sollevatore.Work) OR ??? OR ???);
      Ctrl.P2.Sollevatore.Work := ((Ctrl.TRK.PTrk.Pos2Entry_TO_Pos2Solleva AND Sts.P2.Fermi.Sens_Ing) OR (Ctrl.TRK.PTrk.Pos2Entry_TO_Pos2Solleva AND Ctrl.P2.Sollevatore.Work) OR ??? OR ???);
      Ctrl.P2.Sollevatore.Rest := (NOT (Ctrl.P2.Sollevatore.Work) AND NOT (Ctrl.P2.Sollevatore.EnableMove));
   END_REGION

   REGION "[P2] Sollevatore - COut Manager"
      COut.P2.Sollevatore.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P2.Sollevatore.Rest);
      COut.P2.Sollevatore.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P2.Sollevatore.Work);
      COut.P2.Sollevatore.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P2.Sollevatore.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P2.Sollevatore.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P2.Sollevatore.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P3] Fermi - Movimento operazione a lavoro / a riposo"
      Ctrl.P3.Fermi.Rest := (((??? OR ??? OR ??? OR ??? OR ??? OR ???) AND CIn.P4.Fermi.Work) AND NOT (Ctrl.Ribaltatore.Solleva.Work));
      Ctrl.P3.Fermi.Work := NOT (Ctrl.P3.Fermi.Rest);
   END_REGION

   REGION "[P3] Fermi - COut Manager"
      COut.P3.Fermi.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P3.Fermi.Rest);
      COut.P3.Fermi.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P3.Fermi.Work);
      COut.P3.Fermi.Control_ON := NOT (((NOT (COut.P3.Fermi.Rest) AND NOT (COut.P3.Fermi.Work)) AND NOT (AreaInterface.Cycle)));
      COut.P3.Fermi.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P3.Fermi.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P3.Fermi.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "P [Solleva] Movimento solleva ribaltatore"
      Ctrl.Ribaltatore.Solleva.EnableMove := ???;
      Ctrl.Ribaltatore.Solleva.EnableMove := (??? OR ???);
   END_REGION

   REGION "[Ax] Movimento BTRK da Pos3 Ribalta ==a==>  Pos0 Ribalta"
      Ctrl.TRK.Ribaltatore.MoveToPos0 := ???;
      Ctrl.Ribaltatore.Solleva.Rest := FALSE;
   END_REGION

   REGION "[Ax] Movimento PTRK da Pos3 Entry  ==a==>  Pos1 Ribalta"
      Ctrl.Ribaltatore.Solleva.Work := Ctrl.Ribaltatore.Solleva.EnableMove;
      Ctrl.TRK.Ribaltatore.MoveToPos1 := ((((Ctrl.Ribaltatore.Solleva.EnableMove AND CIn.Ribaltatore.Sts_Ribaltatore.Pos0_Reached) OR ((Ctrl.Ribaltatore.Solleva.EnableMove AND NOT (CIn.Ribaltatore.Sts_Ribaltatore.Pos0_Reached)) AND CIn.Ribaltatore.Solleva_Rib.Work) OR ((Ctrl.Ribaltatore.Solleva.EnableMove AND Ctrl.TRK.Ribaltatore.MoveToPos1) AND NOT (CIn.Ribaltatore.Sts_Ribaltatore.Pos1_Reached))) AND CIn.P3.Fermi.Work) OR ???);
      PTrk.A0301.P := PTrk.A0301.P;
   END_REGION

   REGION "[Ax] Movimento PTRK da Pos1 Ribalta  + Tempo Assestamento ==a==>  Pos2 Ribalta"
      #TON.Delay_Pos1Ribalta(
         PT := PPrf_MAIN.ON_WORK.A0301_A0302.Ribaltatore.Pos_1_Delay
      );

      Ctrl.TRK.Ribaltatore.MoveToPos2 := ((((#TON.Delay_Pos1Ribalta.Q AND TON.Delay_Pos1Ribalta.Q) OR ???) AND NOT (CIn.Ribaltatore.Sts_Ribaltatore.Pos2_Reached)) OR (Ctrl.TRK.Ribaltatore.MoveToPos2 AND NOT (CIn.Ribaltatore.Sts_Ribaltatore.Pos2_Reached)));
      PTrk.A0301.P := PTrk.A0301.P;
   END_REGION

   REGION "[Ax] Movimento PTRK da Pos2 Ribalta  ==a==>  Pos3 Ribalta"
      Ctrl.TRK.Ribaltatore.MoveToPos3 := (??? OR ??? OR ???);
      PTrk.A0301.P := PTrk.A0301.P;
   END_REGION

   REGION "[Ax] Ribaltatore - COut Manager"
      COut.Ribaltatore.Ax.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      IF ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND COut.Ribaltatore.Ax.Control_ON) AND Ctrl.TRK.Ribaltatore.MoveToPos0) THEN
         COut.Ribaltatore.Ax.Pos := A0301_Ribaltatore_PERS.Par_Aut.Pos_0;
      END_IF;
      COut.Ribaltatore.Ax_Req.Pos0 := A0301_Ribaltatore_PERS.Par_Aut.Pos_0;
      COut.Ribaltatore.Ax_Req.Pos1 := A0301_Ribaltatore_PERS.Par_Aut.Pos_1;
      COut.Ribaltatore.Ax_Req.Pos2 := A0301_Ribaltatore_PERS.Par_Aut.Pos_2;
      COut.Ribaltatore.Ax_Req.Pos3 := A0301_Ribaltatore_PERS.Par_Aut.Pos_3;
      COut.Ribaltatore.Ax.MoveToPos := NOT ((((NOT (COut.Ribaltatore.Ax_Req.Pos0) AND NOT (COut.Ribaltatore.Ax_Req.Pos1)) AND NOT (COut.Ribaltatore.Ax_Req.Pos2)) AND NOT (COut.Ribaltatore.Ax_Req.Pos3)));
      COut.Ribaltatore.Ax.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Ribaltatore.Ax.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Ribaltatore.Ax.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[Ax] Ribaltatore - RIFERIMENTI Velocità"
      IF (Sts.SemiAut.ON AND NOT (AreaInterface.Cycle)) THEN
         COut.Ribaltatore.Ax.Vel := A0301_Ribaltatore_PERS.Par_Aut.SemiAut_Vel;
      END_IF;
   END_REGION

   REGION "P [Solleva] Ribaltatore - COut Manager"
      COut.Ribaltatore.Solleva_REST_Req := Ctrl.Ribaltatore.Solleva.Rest;
      COut.Ribaltatore.Solleva_WORK_Req := (Ctrl.Ribaltatore.Solleva.EnableMove AND Ctrl.Ribaltatore.Solleva.Work);
      COut.Ribaltatore.Solleva.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Ribaltatore.Solleva.Rest := ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.TRK.Ribaltatore.MoveToPos0) AND Ctrl.Ribaltatore.Solleva.Rest);
      COut.Ribaltatore.Solleva.Work := ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Ribaltatore.Solleva.EnableMove) AND Ctrl.Ribaltatore.Solleva.Work);
      COut.Ribaltatore.Solleva.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Ribaltatore.Solleva.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Ribaltatore.Solleva.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P2 + P3] UNIONE dei PTrk e SCRITTURA del BTrk - Move su P2 Lifter Up"
      #A0301_PTrk_To_BTrk_Create(
         en := TRUE,
         AreaInterface := AreaInterface,
         PTrk_P2 := PTrk.A0301.P,
         PTrk_P3 := PTrk.A0301.P,
         Status := Alarm.PTrk_TO_BTrk.Status
      );

      IF ((A0301_PTrk_To_BTrk_Create.Execute AND (A0301_PTrk_To_BTrk_Create.Alarm = 0)) AND (Alarm.PTrk_TO_BTrk.Status = 0)) THEN
         BTrk.A0301.B := A0301_PTrk_To_BTrk_Create.BTrk;
      END_IF;
   END_REGION

   REGION "[P4] Reset allarmi"
      IF AreaInterface.RstAlarms THEN
          Alarm.P2toP4_NotReached := FALSE;
      END_IF;

   END_REGION

   REGION "[P4] Movimento BTRK da Pos2 Up  ==a==>  Pos2 Down"
      Ctrl.TRK.BTrk.Pos2Up_TO_Pos2Down := ???;
      Ctrl.TRK.BTrk.Pos2Up_TO_Pos2Down := ((((??? OR ???) AND Ctrl.TRK.Ribaltatore.MoveToPos0) AND (CIn.Ribaltatore.Ax.ActualPosition < 40.0)) AND CIn.Ribaltatore.Solleva_Rib.Rest);
      IF Ctrl.TRK.BTrk.Pos2Up_TO_Pos2Down THEN
         BTrk.A0301.B := BTrk.A0301.B;
      END_IF;
      IF ??? THEN
         Ctrl.P2.PartMove_P2toP4_Init := TRUE;
      END_IF;
   END_REGION

   REGION "== Monitoraggio spazio di trasporto del movimento BTrk da Pos.2 Down a Pos.4 Entry =="
      // Controllo la posizione salvata da Pos.2 Lifter Down + Distanza sensori Pos.2 / Pos.4 = Target da raggiungere

      #Ctrl_Part_Move_P2toP4(
         en := TRUE,
         Init := NOT (Ctrl.P2.PartMove_P2toP4_Init),
         TriggerNegPos := TRUE,
         S1 := Sts.P2.Fermi.Sens_Ing,
         S2 := Sts.P4.Fermi.Sens_Ing,
         V_Counter := Area0301_V_Counter.Value,
         DistanceToTravel := #A0301_Distanza_P2toP4,
         Delta_TooEarly := #A0301_Tollerance,
         V_Counter_Save := A0301_PERS.Data_Mng.LastCounter_PartMove_P2toP4
      );

      IF ((((Sts.P4.Fermi.Some_Sens_Ing AND NOT (Sts.P4.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P2toP4.S2_Reached)) AND Ctrl_Part_Move_P2toP4.Err_S2_ON) OR (((Sts.P4.Fermi.Some_Sens_Ing AND NOT (Sts.P4.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P2toP4.S2_Reached)) AND Ctrl_Part_Move_P2toP4.Err_S2_OFF)) THEN
         Alarm.P2toP4_NotReached := TRUE;
      END_IF;
      IF ((((Sts.P4.Fermi.Some_Sens_Ing AND NOT (Sts.P4.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P2toP4.S2_Reached)) AND Ctrl_Part_Move_P2toP4.Err_S2_ON) OR (((Sts.P4.Fermi.Some_Sens_Ing AND NOT (Sts.P4.Fermi.Sens_Ing)) AND NOT (Ctrl_Part_Move_P2toP4.S2_Reached)) AND Ctrl_Part_Move_P2toP4.Err_S2_OFF)) THEN
         Ctrl.P2.PartMove_P2toP4_Init := FALSE;
      END_IF;
   END_REGION

   REGION "[P4] Movimento BTRK da P2 LifterDown ==> a ==> P2 to P3"
      Ctrl.TRK.BTrk.WritePos2Up_TO_Pos2Down := ???;
      IF Ctrl.TRK.BTrk.WritePos2Up_TO_Pos2Down THEN
         BTrk.A0301.B := BTrk.A0301.B;
      END_IF;
   END_REGION

   REGION "[P4] Movimento BTRK da P2 To Pos3==> a ==> P3 Entry"
      BTrk.A0301.B := BTrk.A0301.B;
   END_REGION

   REGION "[P4] Movimento BTRK da P3 Entry == a ==> P3 Exit == a ==> P3 to P4"
      BTrk.A0301.B := BTrk.A0301.B;
   END_REGION

   REGION "[P4] Movimento BTRK da P3 a P4 == a ==> P4 Entry"
      Sts.P4.Fermi.Some_Sens_Ing := (??? OR ??? OR ???);
      BTrk.A0301.B := BTrk.A0301.B;
      IF BTrk.A0301.B THEN
         Ctrl.P2.PartMove_P2toP4_Init := FALSE;
      END_IF;
   END_REGION

   REGION "[P5] Movimento BTRK da Pos4_Entry  ==a==>  Pos4_Exit"
      Ctrl.TRK.BTrk.Pos4_Entry_TO_Pos4_Exit := ???;
      Ctrl.TRK.BTrk.Pos4_Entry_Cndz_To_Exit := ((((((Ctrl.TRK.BTrk.Pos4_Entry_TO_Pos4_Exit AND CIn.SpintoreLong.Ax_Sts.PosAttesa_Reached) AND CIn.P5.Spintore_Lat.Spin_Lat1.Rest) AND CIn.P5.Spintore_Lat.Spin_Lat2.Rest) AND CIn.P5.Sollevatori.Rest) AND Sts.P4.Fermi.Sens_Ing) AND NOT (CIn.P5.SensUscitaBanco));
      Ctrl.TRK.BTrk.Pos4_Entry_TO_Pos4_Exit := ((((((((Ctrl.TRK.BTrk.Pos4_Entry_TO_Pos4_Exit AND CIn.SpintoreLong.Ax_Sts.PosAttesa_Reached) AND CIn.P5.Spintore_Lat.Spin_Lat1.Rest) AND CIn.P5.Spintore_Lat.Spin_Lat2.Rest) AND CIn.P5.Sollevatori.Rest) AND Sts.P4.Fermi.Sens_Ing) AND NOT (CIn.P5.SensUscitaBanco)) AND Sts.P4.Fermi.Sens_Out) AND CIn.P4.Fermi.Rest);
      IF Ctrl.TRK.BTrk.Pos4_Entry_TO_Pos4_Exit THEN
         BTrk.A0301.B := BTrk.A0301.B;
      END_IF;
   END_REGION

   REGION "[P5] Movimento BTRK da Pos.4 Exit  ==a==>  Pos4_to_Pos5"
      #TON.BTrk_MoveP4Exit(
         IN := ((Ctrl.TRK.BTrk.Pos4_Exit_TO_Pos4_to_Pos5 AND NOT (Sts.P4.Fermi.Sens_Ing)) AND NOT (Sts.P4.Fermi.Sens_Out)),
         PT := Par.TRK.BTrk_MoveP4Exit
      );

      Ctrl.TRK.BTrk.Pos4_Exit_TO_Pos4_to_Pos5 := ???;
      Ctrl.TRK.BTrk.Pos4_Exit_TO_Pos4_to_Pos5 := #TON.BTrk_MoveP4Exit.Q;
      IF Ctrl.TRK.BTrk.Pos4_Exit_TO_Pos4_to_Pos5 THEN
         BTrk.A0301.B := BTrk.A0301.B;
      END_IF;
   END_REGION

   REGION "[P4] Fermi - Movimento operazione a lavoro / a riposo"
      Ctrl.P4.Fermi.Work := ???;
      Ctrl.P4.Fermi.Rest := ((??? OR ???) AND NOT (Ctrl.P4.Fermi.Work));
   END_REGION

   REGION "[P4] Fermi - COut Manager"
      COut.P4.Fermi.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P4.Fermi.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P4.Fermi.Rest);
      COut.P4.Fermi.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P4.Fermi.Work);
      COut.P4.Fermi.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P4.Fermi.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P4.Fermi.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P5] Movimento BTRK da Pos4_to_Pos5 ==a==> Pos5_SpinLat1-2_Solleva"
      #TON.BTrk_MoveToP5(
         PT := Par.TRK.BTrk_MoveToP5
      );

      Ctrl.TRK.BTrk.Pos4_to_Pos5_TO_Pos5_Lat_Spin_Orz.Solleva := #TON.BTrk_MoveToP5.Q;
      IF Ctrl.TRK.BTrk.Pos4_to_Pos5_TO_Pos5_Lat_Spin_Orz.Solleva THEN
         BTrk.A0301.B := BTrk.A0301.B;
      END_IF;
   END_REGION

   REGION "[P5] Spintore Laterale  - Movimento operazione a lavoro / a riposo"
      Ctrl.P5.Spintore_Lat_1.Work := ((??? OR ??? OR ??? OR ??? OR ???) AND NOT (A0301_Spintore_Lat.Finestre.RestCnd_Vrt_1));
      Ctrl.P5.Spintore_Lat_2.Work := (((??? OR ??? OR ??? OR ??? OR ???) AND NOT (A0301_Spintore_Lat.Finestre.RestCnd_Vrt_2)) AND A0301_Spintore_Lat.Sts.En/Dis_SpinLat_2);
      Ctrl.P5.Spintore_Lat_1.Rest := NOT (Ctrl.P5.Spintore_Lat_1.Work);
      Ctrl.P5.Spintore_Lat_2.Rest := NOT (Ctrl.P5.Spintore_Lat_2.Work);
   END_REGION

   REGION "[P5] Spintore Laterale -  COut Manager"
      COut.P5.Spintore_Lat_1.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P5.Spintore_Lat_2.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P5.Spintore_Lat_1.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P5.Spintore_Lat_1.Rest);
      COut.P5.Spintore_Lat_2.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P5.Spintore_Lat_2.Rest);
      COut.P5.Spintore_Lat_1.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P5.Spintore_Lat_1.Work);
      COut.P5.Spintore_Lat_2.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P5.Spintore_Lat_2.Work);
      COut.P5.Spintore_Lat_1.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P5.Spintore_Lat_1.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P5.Spintore_Lat_1.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P5] Sollevatori - Movimento operazione a lavoro / a riposo"
      Ctrl.P5.Sollevatori.Work := (??? OR ??? OR ??? OR ??? OR ??? OR ??? OR ???);
      Ctrl.P5.Sollevatori.Rest := (NOT (Ctrl.P5.Sollevatori.Work) OR CIn.SpintoreLong.Ax_Sts.PosFineSpinta_Reached);
   END_REGION

   REGION "[P5] Sollevatori -  COut Manager"
      COut.P5.Sollevatori.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.P5.Sollevatori.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P5.Sollevatori.Rest);
      COut.P5.Sollevatori.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.P5.Sollevatori.Work);
      COut.P5.Sollevatori.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.P5.Sollevatori.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.P5.Sollevatori.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[P5]  Movimento Part da Pos.5 to Pos.5 (Spintore Longitudinale)"
      Ctrl.TRK.BTrk.Pos5_SpinLat_TO_Pos5_SpinLong := ???;
      IF ((((Ctrl.TRK.BTrk.Pos5_SpinLat_TO_Pos5_SpinLong AND A0301_Spintore_Lat.Sts.En/Dis_SpinLat_2) AND CIn.P5.Spintore_Lat.Spin_Lat2.Work) OR (Ctrl.TRK.BTrk.Pos5_SpinLat_TO_Pos5_SpinLong AND NOT (A0301_Spintore_Lat.Sts.En/Dis_SpinLat_2))) AND CIn.P5.Spintore_Lat.Spin_Lat1.Work) THEN
         BTrk.A0301.B := BTrk.A0301.B;
      END_IF;
   END_REGION

   REGION "[Ax] Spintore =  Movimento BTrk da Long Pos.Attesa  == a ==> Long WorkPos"
      BTrk.A0301.B := BTrk.A0301.B;
   END_REGION

   REGION "Stop Cycle"
      #TON_Stop(
         IN := ((AreaInterface.StopProgrammed OR CIn.ProdManager.STOP_FineTurno OR CIn.ProdManager.STOP_ControlloQualita OR AreaInterface.StopInPhase) AND Sts.IsStandstill),
         PT := T#1s
      );

      Ctrl.Stop := #TON_Stop.Q;
   END_REGION

   REGION "All motions standstill"
      Sts.IsStandstill := (CIn.Trasporto.Standstill AND CIn.Ribaltatore.Ax.Standstill);
   END_REGION

   REGION "Alarms / Warning presence"
      Sts.AlarmsPresence := (NOT (((NOT (Alarm.STOP_End_Of_Proroduction) AND NOT (Alarm.STOP_ControlloQualita)) AND NOT (Alarm.STOP_FineTurno))) AND NOT (AreaInterface.Man));
      Sts.WarningsPresence := (NOT (((NOT (Alarm.STOP_End_Of_Proroduction) AND NOT (Alarm.STOP_ControlloQualita)) AND NOT (Alarm.STOP_FineTurno))) AND AreaInterface.Man);
   END_REGION

   REGION "Collect machine to area interface"
      MachineInterface.AlarmsPresence := Sts.AlarmsPresence;

      MachineInterface.WarningPresence := Sts.WarningsPresence;

      MachineInterface.MotionsStandStill := Sts.IsStandstill;

      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmsPresence;


      MachineInterface.AckStopInPhase := AreaInterface.StopInPhase AND Ctrl.Stop;

      MachineInterface.AckStopProgrammed := AreaInterface.StopProgrammed AND Ctrl.Stop;


      MachineInterface.Aborting := AreaInterface.Aut AND Sts.AlarmsPresence;


   END_REGION


END_FUNCTION_BLOCK
