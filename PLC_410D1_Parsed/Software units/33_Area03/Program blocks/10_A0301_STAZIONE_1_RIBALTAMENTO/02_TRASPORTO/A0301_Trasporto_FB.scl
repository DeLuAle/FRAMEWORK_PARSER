// Block: A0301_Trasporto_FB
// Title:  == Riferimenti [Ax] - Speed Machine ==

FUNCTION_BLOCK "A0301_Trasporto_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
//  == Riferimenti [Ax] - Speed Machine ==
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI : udt_DeviceSafetyInterface;
      Drive : TAx_DriveInterface;
      DataIn : SpeedMachine_DataIn;
      CIn : Struct
         Drive : SpeedMachine_CIn;
         OP_SemiAut_PB : Bool;
      END_STRUCT;
      Config : SpeedMachine_Config;
      HWID_Ax_TEL1 : HW_SUBMODULE;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      COut : Struct
         Ax : SpeedMachine_COut;
         Ax_VelOveride : Struct
            Enable : Bool;
            Value : Real;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         Ax : SpeedMachine_Par;
         Ax_Aut : A0301_Mach_Speed_Par;
      END_STRUCT;
   END_VAR

   VAR
      Alarm : Struct
         Ax : SpeedMachine_Alr;
      END_STRUCT;
      Warning : Struct
         Ax : SpeedMachine_Wng;
         OP_REST_MissingCnd : Bool;
         OP_WORK_MissingCnd : Bool;
      END_STRUCT;
      Ax : SpeedMachine_FB;
      ValueVelOvr : Array[1..10] of Real;
      Sts : Struct
         OP_CanMoveFreely : Bool;
         OP_Bwd_Cnd : Bool;
         OP_Fwd_Cnd : Bool;
      END_STRUCT;
      Ctrl : Struct
         OP_Bwd_Man : Bool;
         OP_Fwd_Man : Bool;
         OP_Bwd_Aut : Bool;
         OP_Fwd_Aut : Bool;
         OP_Bwd_Run : Bool;
         OP_Fwd_Run : Bool;
      END_STRUCT;
      AUX : Struct
         OP_Bwd_PB : Bool;
         OP_Fwd_PB : Bool;
      END_STRUCT;
      TON_OP_REST_MissingCnd : TON_TIME;
      TON_OP_WORK_MissingCnd : TON_TIME;
   END_VAR

   VAR_TEMP
      PE : Struct
         OP_Bwd_PB : Bool;
         OP_Fwd_PB : Bool;
      END_STRUCT;
      VelOvr_Max : Real;
      i : Int;
      Check : Struct
         Cndz1_StartFwd : Bool;
         Cndz2_StartFwd : Bool;
      END_STRUCT;
   END_VAR


BEGIN
   REGION "== Riferimenti [Ax] - Speed Machine =="
      // ******************************************************************************************
      REGION // TRASFERIMENTO DELLE RAMPE
          
          // Rampe in Manuale
          IF AreaInterface.Man AND NOT CIn.OP_SemiAut_PB THEN
              Ax.CIn.Manager.Vel := Par.Ax.Man.VelFwdHigh;
              Ax.CIn.Manager.Acc := Par.Ax.Man.Acc;
              Ax.CIn.Manager.Dec := Par.Ax.Man.Dec;
          END_IF;
      END_REGION


      // ******************************************************************************************
      REGION // CALCOLO DELLA VELOCITA' TRASFERITA DALL'IMPIANTO IN BASE ALLA LUNGHEZZA DEL PEZZO 
          
          // Inizializzo variabile di appoggio controllo overide massimo a un valore basso rispetto setpoint
          IF Sys.AuxFirstPLCCycle THEN
              VelOvr_Max := 100.0;
          END_IF;
          
          // Trasferisco le varibili su un array
          ValueVelOvr[1] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_1000;
          ValueVelOvr[2] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_1500;
          ValueVelOvr[3] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_2000;
          ValueVelOvr[4] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_2500;
          ValueVelOvr[5] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_3000;
          ValueVelOvr[6] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_3500;
          ValueVelOvr[7] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_4000;
          ValueVelOvr[8] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_4500;
          ValueVelOvr[9] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_5000;
          ValueVelOvr[10] := PPrf_MAIN.ON_WORK.A0301_A0302.Trasporto.VelOvr_PLen_UpTo_5500;
          
          
          // Ciclo per verificare la variabile maggiore per prenderla in lavoro
          FOR i := 1 TO 10 DO
              IF ValueVelOvr[i] >= VelOvr_Max THEN
                  VelOvr_Max := ValueVelOvr[i];
              END_IF;
          END_FOR;
      END_REGION ;

      IF VelOvr_Max = 0.0 THEN
          VelOvr_Max := 100.0;
      END_IF;

      // ******************************************************************************************
      REGION // CALCOLO DELLA VELOCITA' E TRASFERIMENTO IN BASE ALLO STATO IMPIANTO
          Ax.CIn.Manager := CIn.Drive.Manager;
          
          IF Ax.CIn.Manager.Control_ON THEN
              // CALCOLO VELOCITA' IN BASE ALL'OVERIDE
              IF Ax.AreaInterface.Aut THEN
                  Ax.CIn.Manager.Vel := (Par.Ax_Aut.Aut_Vel * VelOvr_Max);
              END_IF;
              
              IF CIn.OP_SemiAut_PB AND NOT Ax.AreaInterface.Aut THEN
                  Ax.CIn.Manager.Vel := (Par.Ax_Aut.SemiAut_Vel* VelOvr_Max);
                  Ax.CIn.Manager.Acc := Par.Ax_Aut.Aut_Acc;
                  Ax.CIn.Manager.Dec := Par.Ax_Aut.Aut_Dec;
              END_IF;
          END_IF;
      END_REGION ;
      //


          COut.Ax_VelOveride.Enable := TRUE;
          COut.Ax_VelOveride.Value := VelOvr_Max;


   END_REGION

   REGION "Operazione può muoversi liberamente perchè non sposta nessun BEAM"
      Sts.OP_CanMoveFreely := TRUE;
   END_REGION

   REGION "Comando Operazione Avanti / Indietro (AUT)"
      Ctrl.OP_Bwd_Aut := (CIn.Drive.Manager.Control_ON AND CIn.Drive.Manager.Bwd);
      Ctrl.OP_Fwd_Aut := (CIn.Drive.Manager.Control_ON AND CIn.Drive.Manager.Fwd);
   END_REGION

   REGION "Comando Operazione Lavoro / Riposo (MAN)"
      PE.OP_Bwd_PB := PosEdge(DataIn.PB.Bwd_Minus);
      PE.OP_Fwd_PB := PosEdge(DataIn.PB.Fwd_Plus);
      Ctrl.OP_Bwd_Man := (((((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND PE.OP_Bwd_PB) OR ((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND Ctrl.OP_Bwd_Man)) AND DataIn.PB.Bwd_Minus) AND NOT (DataIn.PB.Fwd_Plus));
      Ctrl.OP_Fwd_Man := (((((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND PE.OP_Fwd_PB) OR ((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND Ctrl.OP_Fwd_Man)) AND DataIn.PB.Fwd_Plus) AND NOT (DataIn.PB.Bwd_Minus));
   END_REGION

   REGION "Cumulativo Operazione Lavoro / Riposo (ALL)"
      Ctrl.OP_Fwd_Run := NOT ((NOT (Ctrl.OP_Fwd_Man) AND NOT (Ctrl.OP_Fwd_Aut)));
      Ctrl.OP_Bwd_Run := NOT ((NOT (Ctrl.OP_Bwd_Man) AND NOT (Ctrl.OP_Bwd_Aut)));
   END_REGION

   REGION "Condizioni movimento Operazione a Lavoro / Riposo"
      Sts.OP_Bwd_Cnd := ((CIn.Drive.Manager.Control_ON AND CIn.Drive.Manager.Bwd) OR ((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
      Sts.OP_Fwd_Cnd := ((CIn.Drive.Manager.Control_ON AND CIn.Drive.Manager.Fwd) OR ((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "[Ax]  Cin Manager Comando arresto / lavoro"
      //
      Ax.CIn.Manager.Bwd := FALSE;
      //************************************
      Ax.CIn.Manager.Fwd := FALSE;
      //
      // CIn Manager  Control ON se ho un richiesta di comando attiva
      Ax.CIn.Manager.Control_ON := Ctrl.OP_Fwd_Run OR Ctrl.OP_Bwd_Run;

      // CIn Manager Frw se ho un richiesta di comando arresto attiva
      Ax.CIn.Manager.Fwd := Ctrl.OP_Fwd_Run AND Sts.OP_Fwd_Cnd ;

      // CIn Manager Brw se ho un richiesta di comando arresto attiva
      Ax.CIn.Manager.Bwd := Ctrl.OP_Bwd_Run AND Sts.OP_Bwd_Cnd;

   END_REGION

   REGION "[Ax] CIn Abilitazioni Stop Manager"
      // CIn Manager Stop per richiesta apertura safety
      // 
      Ax.CIn.Manager.EnableStopDoorOpeningReq := CIn.Drive.Manager.EnableStopDoorOpeningReq;

      // CIn Manager Stop in fase delle macchine precedenti
      // 
      Ax.CIn.Manager.EnableStopInPhase := CIn.Drive.Manager.EnableStopInPhase;
       
      // CIn Manager Stop programmato configurabile a piacere
      // 
      Ax.CIn.Manager.EnableStopProgrammed := CIn.Drive.Manager.EnableStopProgrammed;


   END_REGION

   REGION "Warning manacanza condizioni esecuzione Operazione RIPOSO / LAVORO"
      #TON_OP_REST_MissingCnd(
         IN := Ctrl.OP_Bwd_Run,
         PT := Config.DelayMissingCondition
      );

      #TON_OP_WORK_MissingCnd(
         IN := Ctrl.OP_Fwd_Run,
         PT := Config.DelayMissingCondition
      );

      IF (Sts.OP_Bwd_Cnd OR Ctrl.OP_Fwd_Run OR AreaInterface.RstAlarms) THEN
         Warning.OP_REST_MissingCnd := FALSE;
      ELSIF #TON_OP_REST_MissingCnd.Q THEN
         Warning.OP_REST_MissingCnd := TRUE;
      END_IF;
      IF (Sts.OP_Fwd_Cnd OR Ctrl.OP_Bwd_Run OR AreaInterface.RstAlarms) THEN
         Warning.OP_WORK_MissingCnd := FALSE;
      ELSIF #TON_OP_WORK_MissingCnd.Q THEN
         Warning.OP_WORK_MissingCnd := TRUE;
      END_IF;
   END_REGION

   REGION "[Ax] -  Cin Ext Enable"
      Ax.CIn.Bwd_ExtEnable := (((CIn.Drive.Manager.Control_ON AND COut.Ax.Standstill) OR Ax.COut.Bwd_Running OR ((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND Sts.OP_CanMoveFreely)) AND FALSE);
      Ax.CIn.Fwd_ExtEnable := ((CIn.Drive.Manager.Control_ON AND COut.Ax.Standstill) OR Ax.COut.Fwd_Running OR ((AreaInterface.Man AND NOT (CIn.Drive.Manager.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "[Ax] - CIn External alarm"
      Ax.CIn.ExternalAlarms := FALSE;
   END_REGION

   REGION "[Ax] - SpeedMachine"
      #Ax(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI,
         Drive := Drive,
         DataIn := DataIn,
         CIn := CIn.Drive,
         Config := Config,
         HW_ID_TEL1 := HWID_Ax_TEL1,
         Par := Par.Ax,
         Warning := Warning.Ax,
         Alarm := Alarm.Ax,
         COut => COut.Ax
      );

   END_REGION

   REGION "[Ax] -  COut"
      COut.Ax.Standstill := NOT (NOT (Ax.Sts.Standstill));
      COut.Ax.Bwd_CheckNext := Ctrl.OP_Bwd_Run;
      COut.Ax.Fwd_CheckNext := Ctrl.OP_Fwd_Run;
      COut.Ax.Bwd_Running := (Ctrl.OP_Bwd_Run AND Ax.COut.Bwd_Running);
      COut.Ax.Fwd_Running := (Ctrl.OP_Fwd_Run AND Ax.COut.Fwd_Running);
   END_REGION

   REGION "Machine interface"
   END_REGION


END_FUNCTION_BLOCK
