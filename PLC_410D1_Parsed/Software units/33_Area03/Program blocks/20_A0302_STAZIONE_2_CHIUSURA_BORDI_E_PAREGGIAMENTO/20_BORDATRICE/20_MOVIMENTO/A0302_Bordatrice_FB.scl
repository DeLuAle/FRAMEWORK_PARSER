// Block: A0302_Bordatrice_FB
// Title: Reset allarmi 

FUNCTION_BLOCK "A0302_Bordatrice_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// Reset allarmi 
   VAR_INPUT
      AreaInterface : AreaInterface;
      ZSI : udt_ZoneSafetyInterface;
      DSI : udt_DeviceSafetyInterface;
      Drive : TAx_DriveInterface;
      DataIn : Struct
         OP : Ax_PB;
         Sens : Struct
            FTC_Uscita : Bool;
         END_STRUCT;
         FdBack : Struct
            ConnMotori : Bool;
            ConnAux : Bool;
         END_STRUCT;
      END_STRUCT;
      CIn : Struct
         Manager : Struct
            Ax : Positioning_EPOS_Machine_Manager;
            Ax_Req : Struct
               Pos0 : Bool;
               Pos1 : Bool;
               Pos2 : Bool;
               Pos3 : Bool;
            END_STRUCT;
         END_STRUCT;
         SemiAut_Pb : Bool;
         P5 : Struct
            Sollevatori : ValveMachine_COut;
            SpintoreLong : ValveMachine_COut;
            Sens : Struct
               FTC_Ingombro_A0301 : Bool;
            END_STRUCT;
         END_STRUCT;
         Rulliera : Struct
            Ax_1 : SpeedMachine_COut;
            Centratori : ValveMachine_COut;
            Sollevatori : ValveMachine_COut;
            Coda : Struct
               Sens : Struct
                  FTC_Rall : Bool;
                  FTC_Prox_Ing : Bool;
               END_STRUCT;
            END_STRUCT;
            Centro : Struct
               Sens : Struct
                  FTC_Centrale : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         CarroPareggCoda : Struct
            Ax : Positioning_DOL_Machine_COut;
            Bloccaggio : ValveMachine_COut;
            BattutaVerticale : ValveMachine_COut;
            PareggiatoreLongitudinale : ValveMachine_COut;
            Sens : Struct
               FTC_Ingombro_In : Bool;
               FTC_Ingombro_Out : Bool;
               PresenzaMat : Bool;
               PosPareggLong : Struct
                  Value : LReal;
                  CheckMeasure : Bool;
                  Standstill : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         CarroPareggTesta : Struct
            Ax : Positioning_DOL_Machine_COut;
            Bloccaggio : ValveMachine_COut;
            Centraggio : ValveMachine_COut;
            Sollevatore : ValveMachine_COut;
            Sens : Struct
               FTC1_Rall : Bool;
               FTC2_Prox_Ls : Bool;
               PresenzaMat : Bool;
            END_STRUCT;
         END_STRUCT;
         Attrezzaggio : Struct
            CarriParegg : Struct
               Ready : Bool;
            END_STRUCT;
            BordRegFormato : Struct
               Ready : Bool;
            END_STRUCT;
         END_STRUCT;
      END_STRUCT;
      Config : Struct
         Ax : Positioning_EPOS_Machine_Config_NEW;
         Measure : Struct
            K1_CarroPost : LReal;
            K2_BancoIngresso : LReal;
         END_STRUCT;
      END_STRUCT;
      HWID_TEL111 : HW_SUBMODULE;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      DataOut : Positioning_EPOS_Machine_DataOut;
      COut : Struct
         Ax : Positioning_EPOS_Machine_COut;
         Ax_VelOveride : Struct
            Enable : Bool;
            Value : Real;
         END_STRUCT;
         Sts : Struct
            PosTargetEnable : Bool;
            PosTarget_Reached : Bool;
            In_W_Pos : Bool;
            AtRest : Bool;
         END_STRUCT;
         DataOut : Positioning_EPOS_Machine_DataOut;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         Ax_Man : Positioning_EPOS_Machine_Par;
         Ax_Aut : A0301_Mach_Speed_Par;
      END_STRUCT;
      Pers_Data : Struct
         EncoderAbsolute_Preset_OK : Bool;
         Persistent_ActualPosition : LReal;
      END_STRUCT;
   END_VAR

   VAR
      Alarm : Struct
         Ax : Positioning_EPOS_Machine_Alr;
         StopIngombroCarroCoda : Bool;
         ConnMotori_FdBack : Bool;
         ConnAux_FdBack : Bool;
      END_STRUCT;
      Warning : Struct
         Ax : Positioning_EPOS_Machine_Wng;
         OP_REST_MissingCnd : Bool;
         OP_WORK_MissingCnd : Bool;
      END_STRUCT;
      Ax : Positioning_EPOS_Machine_FB_NEW;
      ValueVelOvr : Array[1..10] of Real;
      Sts : Struct
         ReadyForMove : Bool;
         OP_CanMoveFreely : Bool;
         OP_MoveToPos_Cnd : Bool;
         OP_Bwd_Cnd : Bool;
         OP_Fwd_Cnd : Bool;
         Pz_UscitaBord : Bool;
         StopBordatrice : Bool;
         StandbyBordatrice : Bool;
      END_STRUCT;
      Ctrl : Struct
         Bordatrice : Struct
            OP_Bwd_Man : Bool;
            OP_Fwd_Man : Bool;
            OP_Bwd_Aut : Bool;
            OP_Fwd_Aut : Bool;
            OP_Bwd_Run : Bool;
            OP_Fwd_Run : Bool;
            OP_MoveToPos : Bool;
         END_STRUCT;
         Value : Struct
            Ax_TargetLongPos : LReal;
            QuotaInizioUscita : LReal;
            QuotaFineUscita : LReal;
            PosTarget : LReal;
            QuotaRimanenteRullieraCoda : LReal;
         END_STRUCT;
         PosTargetEnable : Bool;
      END_STRUCT;
      HMI : Struct
         Pos : LReal;
      END_STRUCT;
      AUX : Struct
         Bordatrice : Struct
            OP_Bwd_Minus_PB : Bool;
            OP_Fwd_Plus_PB : Bool;
            OP_MoveToPos_PB : Bool;
         END_STRUCT;
         Measure : Struct
            QuotaInizio : Bool;
            QuotaFine : Bool;
         END_STRUCT;
      END_STRUCT;
      IEC_FTC_UscitaBordatrice : Struct
         TON_Delay : IEC_TIMER;
         TOF_Delay : IEC_TIMER;
         FTC_On : Bool;
      END_STRUCT;
      IEC_StandbyBordatrice : IEC_TIMER;
      BTrk_Item : Struct
         BLean : Real;
         O_ID : DInt;
      END_STRUCT;
   END_VAR

   VAR_TEMP
      PE : Struct
         Bordatrice : Struct
            OP_Bwd_Minus_PB : Bool;
            OP_Fwd_Plus_PB : Bool;
            OP_MoveToPos_PB : Bool;
         END_STRUCT;
      END_STRUCT;
      VelOvr_Max : Real;
      i : Int;
      j : Int;
      CostB : LReal;
      Module : LReal;
      M_PosAPlusCostB : LReal;
      BTrk_GetData : Struct
         indx : Int;
         Sts : Int;
         Item : Prod_Item_small;
      END_STRUCT;
      PositioningStop : Bool;
      NoTrk_Bordatrice : Bool;
   END_VAR


BEGIN
   REGION "Reset allarmi"
      IF AreaInterface.RstAlarms THEN
          Alarm.StopIngombroCarroCoda := FALSE;
          
          IF DataIn.FdBack.ConnMotori AND Alarm.ConnMotori_FdBack THEN
              Alarm.ConnMotori_FdBack := FALSE;
          END_IF;
          
          IF DataIn.FdBack.ConnAux AND Alarm.ConnAux_FdBack THEN
              Alarm.ConnAux_FdBack := FALSE;
          END_IF;
      END_IF;
      //

   END_REGION

   REGION "Controllo FdBack connettori"
      IF (AreaInterface.Aut AND NOT (DataIn.FdBack.ConnMotori)) THEN
         Alarm.ConnMotori_FdBack := TRUE;
      END_IF;
      IF (AreaInterface.Aut AND NOT (DataIn.FdBack.ConnAux)) THEN
         Alarm.ConnAux_FdBack := TRUE;
      END_IF;
   END_REGION

   REGION "CONTROLLO MES lunghezza Beams"
   END_REGION

   REGION "CONTROLLO TRK lunghezza Beams"
      //
      FOR j:= 1 TO BTRK_A0302_ENTRY_ITEMS DO
          // 
          IF BTrk.A0302_ENTRY.B[j].BLen_Meas <> 0 THEN
              BTrk_Item.BLean := BTrk.A0302_ENTRY.B[j].BLen_Meas;
          END_IF;
          
      END_FOR;
              

   END_REGION

   REGION "DataIn - FTC Fuori uscita Bordatrice"
      #IEC_FTC_UscitaBordatrice.TON_Delay(
         IN := DataIn.Sens.FTC_Uscita,
         PT := T#300MS
      );

      #IEC_FTC_UscitaBordatrice.TOF_Delay(
         IN := IEC_FTC_UscitaBordatrice.TON_Delay.Q,
         PT := T#300MS
      );

      IEC_FTC_UscitaBordatrice.FTC_On := #IEC_FTC_UscitaBordatrice.TOF_Delay.Q;
   END_REGION

   REGION "SALVATAGGIO delle quote INIZIO USCITA da Bordatrice e FINE USCITA PEZZO"
      IF (((??? OR ??? OR ???) AND NOT (Sts.Pz_UscitaBord)) AND DataIn.Sens.FTC_Uscita) THEN
         Ctrl.Value.QuotaInizioUscita := Ax.COut.ActualPosition;
      END_IF;
      IF Ax.COut.ActualPosition THEN
         Sts.Pz_UscitaBord := TRUE;
      END_IF;
      IF NOT ((??? OR ??? OR ???)) THEN
         Sts.Pz_UscitaBord := FALSE;
      END_IF;
   END_REGION

   REGION "CALCOLO dello spazio rimanete rulliera di coda"
      //** Calcolo quota Target pezzo - Se ho il carro di coda basso il target è pari alla lunghezza del pezzo
      IF #Sts.Pz_UscitaBord THEN
          #Ctrl.Value.PosTarget := #Ctrl.Value.QuotaInizioUscita + #BTrk_Item.BLean;
       END_IF; **

      // Calcolo dello Spazio prima del Pareggiatore di coda quando è in posizione
      // 
      Ctrl.Value.QuotaRimanenteRullieraCoda := ((Config.Measure.K2_BancoIngresso - Config.Measure.K1_CarroPost) - CIn.CarroPareggCoda.Ax.ActualPosition - 200.0);
      //



   END_REGION

   REGION "CALCOLO Posizioni Target per lavoro Bordatrice"
      // ******************************************************************
      // Calcoli del modulo
      // 

      Module := Ax.Config.Ax.Modulo_S120_P2566 / 1000.0;
      CostB := (Module / 2) - 1000.0;

      // Calcolo quota Target pezzo
      // Se ho il carro di coda basso il target è pari alla lunghezza del pezzo
      // 
      IF Sts.Pz_UscitaBord THEN
          
          IF CIn.CarroPareggCoda.BattutaVerticale.Work OR NOT A0302_Manager.Ctrl.TRK.BTrk.RulliereVode THEN
              
              Ctrl.Value.PosTarget := M_PosAPlusCostB(PosA := Ctrl.Value.QuotaInizioUscita, CostB := Ctrl.Value.QuotaRimanenteRullieraCoda, MODULE := Module);
              
              COut.Sts.PosTargetEnable:=Ctrl.PosTargetEnable := TRUE;
              
              // Se ho il carro di coda alto il target è superiore alla lunghezza del pezzo per arrivare in fondo alla rulliera
          ELSE
              
              Ctrl.Value.PosTarget := Ctrl.Value.Ax_TargetLongPos;
              COut.Sts.PosTargetEnable := Ctrl.PosTargetEnable := FALSE;
            
          END_IF;
          
      ELSE
          Ctrl.Value.PosTarget := Ctrl.Value.Ax_TargetLongPos;
          COut.Sts.PosTargetEnable := Ctrl.PosTargetEnable := FALSE;
      END_IF;

   END_REGION

   REGION "CALCOLO Modulo - Target LongPos"
   END_REGION

   REGION "[Ax] Sts - Standby Bordatrice per mancanza prodotto da lavorare"
      #IEC_StandbyBordatrice(
         IN := Sts.StandbyBordatrice,
         PT := T#1M
      );

      NoTrk_Bordatrice := ((((((BTrk.A0301.B.B_ID = 0) AND (BTrk.A0302_ENTRY.B.B_ID = 0)) AND (BTrk.A0302_ENTRY.B.B_ID = 0)) AND (BTrk.A0302_ENTRY.B.B_ID = 0)) AND (BTrk.A0302_ENTRY.B.B_ID = 0)) AND (BTrk.A0302_ENTRY.B.B_ID = 0));
      Sts.StandbyBordatrice := (((NOT (CIn.P5.Sens.FTC_Ingombro_A0301) AND NOT (IEC_FTC_UscitaBordatrice.FTC_On)) AND NoTrk_Bordatrice) OR ((NOT (CIn.P5.Sens.FTC_Ingombro_A0301) AND NOT (IEC_FTC_UscitaBordatrice.FTC_On)) AND NOT (CIn.Attrezzaggio.CarriParegg.Ready)));
   END_REGION

   REGION "[Ax] Sts - Stop Bordatrice"
      Sts.StopBordatrice := ((((??? OR ??? OR ???) AND IEC_FTC_UscitaBordatrice.FTC_On) AND CIn.CarroPareggCoda.BattutaVerticale.Work) AND CIn.CarroPareggCoda.Sens.FTC_Ingombro_In);
   END_REGION

   REGION "Operazione può muoversi liberamente perchè non sposta nessun BEAM"
      Sts.OP_CanMoveFreely := ???;
   END_REGION

   REGION "Comando Operazione Lavoro  (AUT)"
      Ctrl.Bordatrice.OP_MoveToPos := ((CIn.Manager.Ax.Control_ON AND CIn.Manager.Ax.MoveToPos) AND Ax.CIn.Plus_ExtEnable);
   END_REGION

   REGION "Comando Operazione Lavoro / Riposo (MAN)"
      PE.Bordatrice.OP_MoveToPos_PB := PosEdge(DataIn.OP.MoveToPos);
      Ctrl.Bordatrice.OP_MoveToPos := (((((AreaInterface.Man AND NOT (CIn.Manager.Ax.Control_ON)) AND PE.Bordatrice.OP_MoveToPos_PB) OR ((AreaInterface.Man AND NOT (CIn.Manager.Ax.Control_ON)) AND Ctrl.Bordatrice.OP_MoveToPos)) AND NOT (Ax.COut.InPosition)) AND Sts.OP_MoveToPos_Cnd);
   END_REGION

   REGION "Condizioni movimento Operazione a Lavoro / Riposo"
      Sts.OP_MoveToPos_Cnd := ((((((Ctrl.Bordatrice.OP_MoveToPos AND CIn.CarroPareggCoda.BattutaVerticale.Work) OR (Ctrl.Bordatrice.OP_MoveToPos AND CIn.CarroPareggCoda.BattutaVerticale.Rest)) AND NOT (Sts.StopBordatrice)) AND CIn.Rulliera.Centratori.Rest) AND CIn.Rulliera.Sollevatori.Rest) OR ((AreaInterface.Man AND NOT (CIn.Manager.Ax.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "RIFERIMENTI [AX] - Positioning Manager"
      // ******************************************************************************************
      REGION // TRASFERIMENTO DELLE RAMPE
          
          // Rampe in Manuale
          IF AreaInterface.Man AND NOT CIn.SemiAut_Pb THEN
              Ax.Ctrl.Vel := Par.Ax_Man.Man_Vel;
              Ax.CIn.Manager.Acc := Par.Ax_Man.Man_Acc;
              Ax.CIn.Manager.Dec := Par.Ax_Man.Man_Dec;
          END_IF;
      END_REGION

      // ******************************************************************************************
      REGION // // CALCOLO DELLA VELOCITA' TRASFERITA DALL'IMPIANTO IN BASE ALLA LUNGHEZZA DEL PEZZO
          
          // Inizializzo variabile di appoggio controllo overide massimo a un valore basso rispetto setpoint
          IF Sys.AuxFirstPLCCycle THEN
              VelOvr_Max := 100.0;
          END_IF;
          
          // Rallentamento Bordatrice con sensori
         // 
          // Trasferisco velocità di rallentamento se ho posizionamento corto su pareggiatore di coda e raggiungo i sensori di rallentamento
          IF #Ax.#CIn.Manager.Control_ON AND #CIn.Manager.Ax.MoveToPos AND #CIn.CarroPareggCoda.BattutaVerticale.Work
              AND (#CIn.Rulliera.Coda.Sens.FTC_Rall OR #CIn.Rulliera.Coda.Sens.FTC_Prox_Ing) THEN
              #VelOvr_Max := 500.0;
          END_IF;
          
          // Trasferisco velocità di rallentamento se ho posizionamento lungo su pareggiatore di testa e raggiungo i sensori di rallentamento
          IF #CIn.Manager.Ax.MoveToPos AND #CIn.CarroPareggCoda.BattutaVerticale.Rest AND #CIn.Rulliera.Centro.Sens.FTC_Centrale
              AND (#CIn.CarroPareggTesta.Sens.FTC1_Rall OR #CIn.CarroPareggTesta.Sens.FTC2_Prox_Ls) THEN
              #VelOvr_Max := 500.0;
          END_IF;
          
          
          // Trasferisco le varibili su un array
          ValueVelOvr[1] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_1000;
          ValueVelOvr[2] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_1500;
          ValueVelOvr[3] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_2000;
          ValueVelOvr[4] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_2500;
          ValueVelOvr[5] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_3000;
          ValueVelOvr[6] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_3500;
          ValueVelOvr[7] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_4000;
          ValueVelOvr[8] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_4500;
          ValueVelOvr[9] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_5000;
          ValueVelOvr[10] := PPrf_MAIN.ON_WORK.A0301_A0302.Bordatrice.VelOvr_PLen_UpTo_5500;
          
          // Ciclo per verificare la variabile maggiore per prenderla in lavoro
          FOR i := 1 TO 10 DO
              IF ValueVelOvr[i] >= VelOvr_Max THEN
                  VelOvr_Max := ValueVelOvr[i];
              END_IF;
          END_FOR;// 
      END_REGION ;

      IF VelOvr_Max = 0.0 THEN
          VelOvr_Max := 100.0;
      END_IF;

      // *****************************************************************************************
      REGION // CALCOLO DELLA VELOCITA' E TRASFERIMENTO IN BASE ALLO STATO IMPIANTO
          
          Ax.CIn.VelocityOverride.Enable := TRUE;
          //
          IF Ax.CIn.Manager.Control_ON THEN
              
              IF Ax.CIn.Manager.Control_ON THEN
                  // CALCOLO VELOCITA' IN BASE ALL'OVERIDE
                  Ax.CIn.VelocityOverride.Value := VelOvr_Max;
              ELSE
                  Ax.CIn.VelocityOverride.Value := 100.0;
              END_IF;

          END_IF;
      END_REGION ;


   END_REGION

   REGION "[Ax] -  CIn Manger"
      // TRASFERIMENTO CIn MANAGER ALLA MACCHINA
      Ax.CIn.Manager := CIn.Manager.Ax;

      IF NOT Ctrl.PosTargetEnable THEN
          Ax.CIn.Manager.Pos := Ctrl.Value.Ax_TargetLongPos;
      ELSE
          Ax.CIn.Manager.Pos := Ctrl.Value.PosTarget;
      END_IF;

   END_REGION

   REGION "[Ax] -  Cin External alarm"
      Ax.CIn.ExternalAlarms := FALSE;
   END_REGION

   REGION "[Ax] -  Cin Ext Enable"
      Ax.CIn.Minus_ExtEnable := TRUE;
      Ax.CIn.Plus_ExtEnable := (CIn.CarroPareggCoda.BattutaVerticale.Rest OR ((CIn.CarroPareggCoda.BattutaVerticale.Work AND NOT (PositioningStop)) AND Ctrl.PosTargetEnable) OR (CIn.CarroPareggCoda.BattutaVerticale.Work AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_In)) OR ((AreaInterface.Man AND NOT (CIn.Manager.Ax.Control_ON)) AND Sts.OP_CanMoveFreely));
   END_REGION

   REGION "[Ax] - Positioning Manager"
      #Ax(
         en := TRUE,
         AreaInterface := AreaInterface,
         ZSI := ZSI,
         DSI := DSI,
         Drive := Drive,
         Config := Config.Ax,
         HW_ID_TEL111 := HWID_TEL111,
         Par := Par.Ax_Man,
         Pers_Data := Pers_Data,
         Warning := Warning.Ax,
         Alarm := Alarm.Ax,
         DataOut => COut.DataOut,
         COut => COut.Ax
      );

   END_REGION

   REGION "Bordatrice = Status / Control - Pos.Target Carro Alto / Pos.Target Carro Basso"
      IF TRUE THEN
         Ax.CIn.Manager.MoveToPos := FALSE;
      END_IF;
      IF ((CIn.Manager.Ax.MoveToPos OR Ctrl.Bordatrice.OP_MoveToPos) AND NOT (Ctrl.PosTargetEnable)) THEN
         Ax.CIn.Manager.Pos := Ctrl.Value.Ax_TargetLongPos;
      END_IF;
      IF Ctrl.Value.Ax_TargetLongPos THEN
         Ax.CIn.Manager.MoveToPos := TRUE;
      END_IF;
      IF (Ctrl.Value.PosTarget AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_In)) THEN
         Ax.CIn.Manager.MoveToPos := TRUE;
      END_IF;
      IF (Ctrl.Value.PosTarget AND CIn.CarroPareggCoda.Sens.FTC_Ingombro_In) THEN
         Alarm.StopIngombroCarroCoda := TRUE;
      END_IF;
   END_REGION

   REGION "Network 32"
      COut.Sts.PosTarget_Reached := ((COut.Ax.ActualPosition = Ax.CIn.Manager.Pos) AND COut.Sts.In_W_Pos);
   END_REGION

   REGION "Machine interface"
   END_REGION


END_FUNCTION_BLOCK
