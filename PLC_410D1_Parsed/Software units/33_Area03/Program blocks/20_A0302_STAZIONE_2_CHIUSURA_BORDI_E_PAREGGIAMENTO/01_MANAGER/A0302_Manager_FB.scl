// Block: A0302_Manager_FB
// Title: = Area - Rst =

FUNCTION_BLOCK "A0302_Manager_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
// = Area - Rst =
   VAR_INPUT
      AreaInterface : AreaInterface;
      DataIn : Struct
         SemiAut_Pb : Bool;
      END_STRUCT;
      CIn : Struct
         P5 : Struct
            Sollevatori : ValveMachine_COut;
            Spintore_Lat : Struct
               Spin_Lat1 : Struct
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Rest : Bool;
                  Work : Bool;
               END_STRUCT;
               Spin_Lat2 : Struct
                  Standstill : Bool;
                  Rest_CheckNext : Bool;
                  Work_CheckNext : Bool;
                  Rest : Bool;
                  Work : Bool;
               END_STRUCT;
            END_STRUCT;
            SpintoreLong : Struct
               Ax : Positioning_EPOS_Machine_COut;
               Ax_Sts : Struct
                  PosAttesa_Reached : Bool;
                  PosFineSpinta_Reached : Bool;
               END_STRUCT;
               Spintore : ValveMachine_COut;
               Vrt : ValveMachine_COut;
               Orz : ValveMachine_COut;
               Sens : Struct
                  FTC_FuoriIngombro : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         Bordatrice : Struct
            Ax : Positioning_EPOS_Machine_COut;
            Sts : Struct
               PosTargetEnable : Bool;
               PosTarget_Reached : Bool;
               In_W_Pos : Bool;
               AtRest : Bool;
            END_STRUCT;
            Sens : Struct
               FTC_Ingresso : Bool;
               FTC_Uscita : Bool;
            END_STRUCT;
         END_STRUCT;
         Rulliera : Struct
            Ax_1 : SpeedMachine_COut;
            Ax_2 : SpeedMachine_COut;
            Centraggio : ValveMachine_COut;
            Sollevamento : ValveMachine_COut;
            Coda : Struct
               Sens : Struct
                  FTC_Rall : Bool;
                  FTC_Prox_Ing : Bool;
               END_STRUCT;
            END_STRUCT;
            Centro : Struct
               Sens : Struct
                  FTC_Centrale : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         CarroPareggCoda : Struct
            Ax_InWPos : Bool;
            Ax : Positioning_DOL_Machine_COut;
            Bloccaggio : ValveMachine_COut;
            BattutaVerticale : ValveMachine_COut;
            PareggiatoreLong : ValveMachine_COut;
            Sens : Struct
               FTC_Ingombro_Ing : Bool;
               FTC_Ingombro_Out : Bool;
               PresenzaMat : Bool;
               PosPareggLong : Struct
                  Value : LReal;
                  CheckMeasure : Bool;
                  Standstill : Bool;
               END_STRUCT;
            END_STRUCT;
         END_STRUCT;
         CarroPareggTesta : Struct
            Ax_InWPos : Bool;
            Ax : Positioning_DOL_Machine_COut;
            Bloccaggio : ValveMachine_COut;
            Centraggio : ValveMachine_COut;
            Sollevatore : ValveMachine_COut;
            Sens : Struct
               FTC_Ingombro_Ing : Bool;
               FTC_Prox_Ls : Bool;
               PresenzaMat : Bool;
            END_STRUCT;
         END_STRUCT;
         Manipolatori : Struct
            Testa : Struct
               Ax : Positioning_EPOS_Machine_COut;
               Sollevatore : ValveMachine_COut;
               Magnete : ValveMachine_COut;
            END_STRUCT;
            Coda : Struct
               Ax : Positioning_EPOS_Machine_COut;
               Sollevatore : ValveMachine_COut;
               Magnete : ValveMachine_COut;
            END_STRUCT;
            InPos_Prelievo : Bool;
            InPos_BancoScarto : Bool;
            InPos_BancoA0303 : Bool;
         END_STRUCT;
         Spalle : Struct
            Coda : Struct
               Ax : Positioning_DOL_Machine_COut;
            END_STRUCT;
            Testa : Struct
               Ax : Positioning_DOL_Machine_COut;
            END_STRUCT;
         END_STRUCT;
         Banco_A0303 : Struct
            ReadyToRecive : Bool;
         END_STRUCT;
         ProdManager : Prod_Beam_Ctrl;
      END_STRUCT;
   END_VAR

   VAR_OUTPUT
      MachineInterface : MachineInterface;
      COut : Struct
         HU : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            Rest : Bool;
            Work : Bool;
         END_STRUCT;
         SpintoreLong : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            REST_Req : Bool;
            WORK_Req : Bool;
            Rest : Bool;
            Work : Bool;
         END_STRUCT;
         Bordatrice : Struct
            Ax : Positioning_EPOS_Machine_Manager;
            Sts : Struct
               PosTarget_Reached : Bool;
               AtRest : Bool;
            END_STRUCT;
            DataOut : Positioning_EPOS_Machine_DataOut;
            Rest_Req : Bool;
            Work_Req : Bool;
         END_STRUCT;
         Rulliera : Struct
            Ax_1 : SpeedMachine_CIn_Manager;
            Ax_2 : SpeedMachine_CIn_Manager;
            Centratori : Struct
               Sollevamento : ValveMachine_Manager;
               Centraggio : ValveMachine_Manager;
            END_STRUCT;
            Ax_1_Frw_Req : Bool;
            Ax_1_Brw_Req : Bool;
            Ax_2_Frw_Req : Bool;
            Ax_2_Brw_Req : Bool;
         END_STRUCT;
         CarroPareggCoda : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            MoveToPos : Bool;
            Pos : LReal;
            Speed : LReal;
            Bloccaggio : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            BattutaVrt : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            PareggLong : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
         CarroPareggTesta : Struct
            EnableStopDoorOpeningReq : Bool;
            EnableStopInPhase : Bool;
            EnableStopProgrammed : Bool;
            Control_ON : Bool;
            MoveToPos : Bool;
            Pos : LReal;
            Speed : LReal;
            Bloccaggio : OP_PB;
            Sollevamento : OP_PB;
            Centraggio : OP_PB;
         END_STRUCT;
         Manipolatori : Struct
            Ax : Struct
               EnableStopDoorOpeningReq : Bool;
               EnableStopInPhase : Bool;
               EnableStopProgrammed : Bool;
               Control_ON : Bool;
               MoveToPos : Bool;
               Pos : LReal;
               Vel : LReal;
               Acc : LReal;
               Dec : LReal;
            END_STRUCT;
            Sollevatori : OP_PB;
            Magneti : OP_PB;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR_IN_OUT
      Par : Struct
         CarroPareggCoda : Struct
            Delay_StartMove : Time;
            Preset : LReal;
         END_STRUCT;
         CarroPareggTesta : Struct
            Delay_StartMove : Time;
            Preset : LReal;
         END_STRUCT;
         Cremaliera : Struct
            Modulo : LReal;
            Passo : LReal;
         END_STRUCT;
      END_STRUCT;
   END_VAR

   VAR
      Alarm : Struct
         Qlty_Unknow : Bool;
         ToCheckList_Full : Bool;
         WrongReadPz_ManipBasso : Bool;
         Pz_NonPareggiabile : Bool;
         STOP_FineTurno : Bool;
         STOP_End_Of_Proroduction : Bool;
         STOP_ControlloQualita : Bool;
      END_STRUCT;
      Warning : Struct
         CheckBancoAccumulo : Bool;
      END_STRUCT;
      Sts : Struct
         SemiAut : Struct
            ON : Bool;
            Request : Bool;
            MaterialFrw : Bool;
         END_STRUCT;
         CarroPareggTesta : Struct
            InCyclePos : Bool;
         END_STRUCT;
         CarroPareggCoda : Struct
            InCyclePos : Bool;
         END_STRUCT;
         Attrezzamento : Struct
            Ready : Bool;
            FindNewID : Bool;
            RequestNewPosition : Bool;
            OLD_OID : DInt;
         END_STRUCT;
         BTrk : Struct
            A0302Exit_Actual_O_ID : DInt;
            BLen_Paregg : Real;
            Last_Misure1Paregg : Real;
            Last_Misure2Paregg : Real;
            A0302Entry_Absence : Bool;
            A0302Exit_Absence : Bool;
            ZoneA0302Entry_Empty : Bool;
            ZoneA0302Exit_Empty : Bool;
            A0302_CheckBancoAccumulo : Bool;
            Waiting_A0302_Recive : Bool;
         END_STRUCT;
         AlarmsPresence : Bool;
         WarningsPresence : Bool;
         IsStandstill : Bool;
      END_STRUCT;
      Ctrl : Struct
         Stop : Bool;
         TRK : Struct
            BTrk : Struct
               "P5.1_To_LongPosAttesa" : Bool;
               "P5.2_LongPosAttesa_TO_Spintore" : Bool;
               "P5.2_Spintore_TO_ExitA031" : Bool;
               "P5.2_ExitA031_To_IngBord" : Bool;
               "P5.2_Ax_MoveToPosAttesa" : Bool;
               "P5.2_Ax_PreparingPosAttesa" : Bool;
               "P5.2_Ax_MoveToPosSpinta" : Bool;
               SpinBord_In_To_Bord_In : Bool;
               Bordatrice_In_To_Out : Bool;
               Bordatrice_Out_To_PareggCodaUp : Bool;
               Bordatrice_Out_To_PareggCodaDown : Bool;
               Rulliera_Start_Brw : Bool;
               Rulliera_Ax_1_Start_Frw : Bool;
               Rulliera_Ax_2_Start_Frw : Bool;
               RulliereVode : Bool;
               PCodaDown_TO_Rulli_PCodaDown : Bool;
               PCodaDown_TO_RALL_Rulli_PCodaDown : Bool;
               PCodaDown_TO_STOP_PCodaDown : Bool;
               STOP_PCodaDown_TO_PCoda_Up : Bool;
               "PareggCodaUp_To_Rull-PrimaPareggCodaAltro" : Bool;
               PCoda_Up_TO_PCoda_UP_S3 : Bool;
               PCoda_UP_S3_TO_PCoda_UP_S4 : Bool;
               PCoda_UP_S4_TO_PCoda_DownCnd : Bool;
               PCoda_Beam_TO_PTesta : Bool;
               Beam_TO_Stop_PTesta : Bool;
               "Stop_PTesta_TO_Rull-Centratori" : Bool;
               "Rull-Centratori_TO_Cnd_PareggCoda" : Bool;
               Cnd_PareggCoda_TO_Pareggiato : Bool;
               Check_Tolleranza_BLen_Qlty : Bool;
               Pareggiato_TO_PresaBasso : Bool;
               PresaBasso_TO_PresaAlto : Bool;
               PresaAlto_To_CheckOut_BadQlty : Bool;
               CheckOut_BadQlty_UP_MoveToPos : Bool;
               PresaAlto_To_CheckOut_GoodQlty : Bool;
               CheckOut_GoodQlty_UP_MoveToPos : Bool;
               CheckOut_BadQlty_UP_To_DOWN : Bool;
               CheckOut_BadQlty_DOWN_To_Sgancia : Bool;
               CheckOut_GoodQlty_UP_To_DOWN : Bool;
               CheckOut_GoodQlty_DOWN_To_Sgancia : Bool;
               Manipolatori_Return_ToPrelievo : Bool;
            END_STRUCT;
            BTrk_ToCheck : Struct
               ClearList : Bool;
               QtyClear_RetVal : Bool;
               Prelievo_RecondGood : Bool;
               RecG_InPos_Centraggio : Bool;
               RegG_InPos_ReadyPickUp : Bool;
            END_STRUCT;
         END_STRUCT;
         SpintoreLong : Struct
            Rest : Bool;
            Work : Bool;
            MoveAttesaDisable : Bool;
         END_STRUCT;
         Bordatrice : Struct
            Run : Bool;
         END_STRUCT;
         Rulliera : Struct
            Ax_1_Vel_Bord : Bool;
            Ax_2_Vel_Bord : Bool;
            Ax_1_Lenta_CarroCoda : Bool;
            Ax_1_2_Vel_CarroTesta : Bool;
            Ax_1_2_Vel_ZeroTesta : Bool;
            Ax_1_2_Vel_Appoggio : Bool;
            Ax_1_2_End_VelZero : Bool;
            Ax_2_MemoRall : Bool;
            SP_TimeMemoRall : Time;
            TON_RitardoRallenta : IEC_TIMER;
            Centraggio : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Sollevamento : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
         CarroPareggCoda : Struct
            Ax : Struct
               MoveToPos : Bool;
               Pos : LReal;
            END_STRUCT;
            Bloccaggio : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            BattutaVerticale : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            PareggiatoreLong : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            MisuraPzPareggiato : Bool;
         END_STRUCT;
         CarroPareggTesta : Struct
            Ax : Struct
               MoveToPos : Bool;
               Pos : LReal;
            END_STRUCT;
            Bloccaggio : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Sollevatore : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Centraggio : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
         Manipolatori : Struct
            Ax : Struct
               MoveToPos : Bool;
               Pos : LReal;
            END_STRUCT;
            Sollevatori : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
            Magneti : Struct
               Rest : Bool;
               Work : Bool;
            END_STRUCT;
         END_STRUCT;
      END_STRUCT;
      HMI : Struct
         PlsClear_ListToCheck : Bool;
      END_STRUCT;
      BTrk_A0302_Exit_Item : Struct
         BLean : Real;
         W_A : Real;
         Tol_Max : Real;
         Tol_Min : Real;
         Good : Bool;
         ToCheckLen : Bool;
      END_STRUCT;
      BTrk_ListToCheck : Struct
         Recond : Struct
            Found : Bool;
            Nr_B : Int;
         END_STRUCT;
      END_STRUCT;
      OffsetCarri : Struct
         DaSpallaTesta : LReal;
         DaSpallaCoda : LReal;
      END_STRUCT;
      CarroTesta : Struct
         RimanenzaPos : LReal;
         PassoReq : LReal;
         PosBattutePz : LReal;
         SemiBeamLen : LReal;
         NrPassiReq : LReal;
      END_STRUCT;
      CarroCoda : Struct
         RimanenzaPos : LReal;
         PassoReq : LReal;
         PosBattutePz : LReal;
         SemiBeamLen : LReal;
         NrPassiReq : LReal;
      END_STRUCT;
      TON_AlarmWrongReadPz_Manip : IEC_TIMER;
      TON_Alarm_FTC_CarroCodaOut : IEC_TIMER;
      TON_Stop : IEC_TIMER;
   END_VAR

   VAR_TEMP
      AUX : Struct
         SemiAut_Pb : Bool;
      END_STRUCT;
      i : Int;
      BTrk_A0302_EXIT_GetData : Struct
         indx : Int;
         Sts : Int;
         Item : Prod_Item_small;
      END_STRUCT;
      DisableA0302 : Bool;
      PieceToCheck_Presence : Bool;
      CarroTestaCentraggio_Disable : Bool;
   END_VAR

   VAR CONSTANT
      OffsetGioco : Real;
   END_VAR


BEGIN
   REGION "= Area - Rst ="
      IF AreaInterface.RstAlarms THEN
          Alarm.Qlty_Unknow := FALSE;
          Alarm.ToCheckList_Full := FALSE;
          Alarm.STOP_ControlloQualita := FALSE;
          Alarm.STOP_FineTurno := FALSE;
          Alarm.STOP_End_Of_Proroduction := FALSE;
      END_IF;

      IF AreaInterface.RstAlarms AND CIn.CarroPareggCoda.Sens.PresenzaMat AND CIn.CarroPareggTesta.Sens.PresenzaMat
          AND CIn.Manipolatori.Testa.Magnete.Work AND CIn.Manipolatori.Coda.Magnete.Work THEN
          Alarm.WrongReadPz_ManipBasso := FALSE;
      END_IF;

      IF AreaInterface.RstAlarms AND NOT CIn.CarroPareggCoda.Sens.FTC_Ingombro_Out THEN
          Alarm.Pz_NonPareggiabile := FALSE;
      END_IF;

   END_REGION

   REGION "********  CLEAR TRACKING ARRIVATO ********"
      IF A03_DEBUG.A0302_Manager.BTrk_EXIT_Clear THEN
         BTrk.A0302_EXIT.B[17] := BTrk.Empty;
      END_IF;
   END_REGION

   REGION "Semiautomatico Pb"
      Sts.SemiAut.MaterialFrw := ((NOT (NOT (DataIn.SemiAut_Pb)) AND DataIn.SemiAut_Pb) OR (NOT (NOT (DataIn.SemiAut_Pb)) AND Sts.SemiAut.ON));
      Sts.SemiAut.ON := ((PosEdge(DataIn.SemiAut_Pb) OR Sts.SemiAut.ON) AND Sts.SemiAut.MaterialFrw);
   END_REGION

   REGION "== Cerco order ID nelle macchine precedenti e leggo i dati dal MES=="
      Sts.Attrezzamento.FindNewID := Sts.BTrk.ZoneA0302Exit_Empty;
   END_REGION

   REGION "== Richiesta nuovo posizionamento carri Testa/Coda per cambio Traking =="

      //Se ho O_ID <> e non sono vuoto attivo avviso di attesa zona A0302 vuota
      IF (Sts.BTrk.A0302Exit_Actual_O_ID <> Sts.Attrezzamento.OLD_OID) OR (NOT Sts.BTrk.ZoneA0302Exit_Empty OR NOT Sts.BTrk.ZoneA0302Entry_Empty)THEN
          Sts.BTrk.Waiting_A0302_Recive := TRUE;
          
      ELSIF (Sts.BTrk.A0302Exit_Actual_O_ID = Sts.Attrezzamento.OLD_OID) OR ( Sts.BTrk.ZoneA0302Exit_Empty AND Sts.BTrk.ZoneA0302Entry_Empty) THEN
          Sts.BTrk.Waiting_A0302_Recive := FALSE;
          
      END_IF;

      //Se ho O_ID <> e sono vuoto aggiorno vecchio O_ID 
      IF (Sts.BTrk.A0302Exit_Actual_O_ID <> Sts.Attrezzamento.OLD_OID) AND Sts.BTrk.ZoneA0302Exit_Empty AND Sts.BTrk.ZoneA0302Entry_Empty THEN
          Sts.Attrezzamento.OLD_OID := Sts.BTrk.A0302Exit_Actual_O_ID;
      END_IF;


   END_REGION

   REGION "== Compilo i dati del btrk in base all'order ID in arrivo =="

      IF BTrk_A0302_EXIT_GetData.Sts >= 0 THEN
          
          BTrk.A0302_EXIT.O_ID:=BTrk.A0302_ENTRY.O_ID := Sts.Attrezzamento.OLD_OID;
          BTrk.A0302_EXIT.Beam_Len := BTrk.A0302_ENTRY.Beam_Len := BTrk_A0302_EXIT_GetData.Item.Beams_Len;
          BTrk.A0302_EXIT.Beam_W_A := BTrk.A0302_ENTRY.Beam_W_A := BTrk_A0302_EXIT_GetData.Item.Beams_W_A;
          BTrk.A0302_EXIT.Beam_H_B := BTrk.A0302_ENTRY.Beam_H_B := BTrk_A0302_EXIT_GetData.Item.Beams_H_B;
          
      ELSE
              BTrk.A0302_EXIT.O_ID := BTrk.A0302_ENTRY.O_ID := BTrk.A0301.O_ID := -1;
              BTrk.A0302_EXIT.Beam_Len := BTrk.A0302_ENTRY.Beam_Len := -1.0;
              BTrk.A0302_EXIT.Beam_W_A := BTrk.A0302_ENTRY.Beam_W_A := -1.0;
              BTrk.A0302_EXIT.Beam_H_B := BTrk.A0302_ENTRY.Beam_H_B := -1.0;
      END_IF;

   END_REGION

   REGION "== Richiesta nuovo posizionamento x cambio Order ID =="

      Sts.Attrezzamento.RequestNewPosition := (BTrk.A0302_EXIT.O_ID <> -1)
      AND (BTrk_A0302_EXIT_GetData.Sts >= 0)
      AND (BTrk_A0302_EXIT_GetData.Item.Beam_Code = 1)
      AND Sts.Attrezzamento.FindNewID
      AND NOT Sts.Attrezzamento.Ready
      AND NOT BTrk_ListToCheck.Recond.Found
      AND (NOT CIn.CarroPareggCoda.Ax_InWPos OR NOT CIn.CarroPareggTesta.Ax_InWPos);

   END_REGION

   REGION "[Ax]  Pos5.1 Long Work Pos  == a ==> Posiz. Attesa Spintore Long."
      Ctrl.TRK.BTrk.P5.1_To_LongPosAttesa := ???;
      IF ??? THEN
         Ctrl.TRK.BTrk.P5.1_To_LongPosAttesa := TRUE;
      END_IF;
      Ctrl.TRK.BTrk.P5.2_LongPosAttesa_TO_Spintore := ???;
      IF ??? THEN
         Ctrl.TRK.BTrk.P5.1_To_LongPosAttesa := FALSE;
      END_IF;
   END_REGION

   REGION "[Ax]  Movimento BTrk da Pos5.1 Long Pos.Attesa  == a ==> Spintore"
      IF Ctrl.TRK.BTrk.P5.2_LongPosAttesa_TO_Spintore THEN
         BTrk.A0302_ENTRY.B := BTrk.A0301.B;
      END_IF;
   END_REGION

   REGION "[Ax]  Movimento BTrk da A3202 Spintore ==a==> Uscita Trasporto A031"
      Ctrl.TRK.BTrk.P5.2_Spintore_TO_ExitA031 := ???;
      IF ((((Ctrl.TRK.BTrk.P5.2_Spintore_TO_ExitA031 AND CIn.P5.SpintoreLong.Spintore.Work) AND CIn.P5.SpintoreLong.Sens.FTC_FuoriIngombro) AND (A0302_Bordatrice.Ax.COut.ActualVelocity > A0302_Spintore_PERS.Par_Ax_Auto.Aut_Vel)) OR (((Ctrl.TRK.BTrk.P5.2_Spintore_TO_ExitA031 AND CIn.P5.SpintoreLong.Spintore.Work) AND CIn.P5.SpintoreLong.Sens.FTC_FuoriIngombro) AND Sys.Bit1)) THEN
         BTrk.A0302_ENTRY.B := BTrk.A0302_ENTRY.B;
      END_IF;
   END_REGION

   REGION "[Ax] Movimento BTrk  Uscita Trasporto A031 ==a==> Spin Ingresso Bordatrice"
      Ctrl.TRK.BTrk.P5.2_ExitA031_To_IngBord := ???;
      IF Ctrl.TRK.BTrk.P5.2_ExitA031_To_IngBord THEN
         BTrk.A0302_ENTRY.B := BTrk.A0302_ENTRY.B;
      END_IF;
   END_REGION

   REGION "[Ax] Spintore - Control - Pos. Fine Spinta"
      Ctrl.SpintoreLong.MoveAttesaDisable := ???;
      Ctrl.TRK.BTrk.P5.2_Ax_MoveToPosSpinta := ((((((Ctrl.SpintoreLong.MoveAttesaDisable AND CIn.P5.Sollevatori.Work) AND NOT (A0301_Spintore_Lat.Warning.Finestre.SpinLat2_SpinLong_Stop)) AND NOT (A0301_Spintore_Lat.Warning.Finestre.SpinLat1_SpinLong_Stop)) OR ((Ctrl.SpintoreLong.MoveAttesaDisable AND CIn.P5.Sollevatori.Work) AND Sys.Bit1)) AND (A0302_Bordatrice.Ax.COut.ActualVelocity > A0302_Spintore_PERS.Par_Ax_Auto.Aut_Vel)) OR (((((Ctrl.SpintoreLong.MoveAttesaDisable AND CIn.P5.Sollevatori.Work) AND NOT (A0301_Spintore_Lat.Warning.Finestre.SpinLat2_SpinLong_Stop)) AND NOT (A0301_Spintore_Lat.Warning.Finestre.SpinLat1_SpinLong_Stop)) OR ((Ctrl.SpintoreLong.MoveAttesaDisable AND CIn.P5.Sollevatori.Work) AND Sys.Bit1)) AND Sys.Bit1));
   END_REGION

   REGION "[Ax] Spintore - Control - Pos. Attesa"
      Ctrl.TRK.BTrk.P5.2_Ax_PreparingPosAttesa := ((NOT (Ctrl.SpintoreLong.MoveAttesaDisable) AND NOT (Ctrl.TRK.BTrk.P5.2_Ax_MoveToPosSpinta)) AND NOT (CIn.P5.SpintoreLong.Ax_Sts.PosAttesa_Reached));
      Ctrl.TRK.BTrk.P5.2_Ax_MoveToPosAttesa := ((NOT (Ctrl.SpintoreLong.MoveAttesaDisable) AND NOT (CIn.P5.SpintoreLong.Ax_Sts.PosAttesa_Reached)) OR (NOT (Ctrl.SpintoreLong.MoveAttesaDisable) AND NOT (Sys.ByPass)));
   END_REGION

   REGION "[Ax] Spintore Longitudinale - COut Manager"
      COut.SpintoreLong.REST_Req := Ctrl.TRK.BTrk.P5.2_Ax_PreparingPosAttesa;
      COut.SpintoreLong.WORK_Req := ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND CIn.P5.SpintoreLong.Ax_Sts.PosAttesa_Reached) OR ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.TRK.BTrk.P5.2_Ax_MoveToPosSpinta) AND NOT (CIn.P5.SpintoreLong.Ax_Sts.PosFineSpinta_Reached)));
      COut.SpintoreLong.Rest := ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND CIn.P5.SpintoreLong.Ax_Sts.PosFineSpinta_Reached) OR ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.TRK.BTrk.P5.2_Ax_MoveToPosAttesa) AND NOT (CIn.P5.SpintoreLong.Ax_Sts.PosAttesa_Reached)));
      COut.SpintoreLong.Work := ((NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.TRK.BTrk.P5.2_Ax_MoveToPosSpinta) AND NOT (CIn.P5.SpintoreLong.Ax_Sts.PosFineSpinta_Reached));
      COut.SpintoreLong.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.SpintoreLong.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.SpintoreLong.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.SpintoreLong.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[Ax]  Movimento BTrk Spin Ingresso Bordatrice ==a==> Ingresso Bordatrice"
      Ctrl.TRK.BTrk.SpinBord_In_To_Bord_In := ???;
      Ctrl.TRK.BTrk.SpinBord_In_To_Bord_In := (??? OR ???);
      IF Ctrl.TRK.BTrk.SpinBord_In_To_Bord_In THEN
         BTrk.A0302_ENTRY.B := BTrk.A0302_ENTRY.B;
      END_IF;
   END_REGION

   REGION "[Ax]  Movimento BTrk da Ingresso Bordatrice ==a==> Uscita Bordatrice"
      Ctrl.TRK.BTrk.Bordatrice_In_To_Out := ???;
      IF Ctrl.TRK.BTrk.Bordatrice_In_To_Out THEN
         BTrk.A0302_ENTRY.B := BTrk.A0302_ENTRY.B;
      END_IF;
      Ctrl.TRK.BTrk.RulliereVode := (((((((((((((BTrk.A0302_EXIT.B.B_ID = 0) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0));
   END_REGION

   REGION "[Ax]  Movimento BTrk da Uscita Bordatrice ==a==> Uscita Bord. Pareggiatore Coda Basso"
      Ctrl.TRK.BTrk.Bordatrice_Out_To_PareggCodaDown := ???;
      IF Ctrl.TRK.BTrk.Bordatrice_Out_To_PareggCodaDown THEN
         BTrk.A0302_ENTRY.B := BTrk.A0302_ENTRY.B;
      END_IF;
   END_REGION

   REGION "Bordatrice = Controllo condizioni di START - Fwd"
      Ctrl.Bordatrice.Run := (??? OR ??? OR ??? OR ??? OR ??? OR ((((((((BTrk.A0302_ENTRY.B.B_ID <> 0) OR (BTrk.A0302_ENTRY.B.B_ID <> 0) OR (BTrk.A0302_ENTRY.B.B_ID <> 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND CIn.CarroPareggCoda.BattutaVerticale.Work) AND CIn.Bordatrice.Sts.PosTargetEnable) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Ing)) OR (((((((BTrk.A0302_ENTRY.B.B_ID <> 0) OR (BTrk.A0302_ENTRY.B.B_ID <> 0) OR (BTrk.A0302_ENTRY.B.B_ID <> 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND (BTrk.A0302_EXIT.B.B_ID = 0)) AND CIn.CarroPareggCoda.BattutaVerticale.Rest) AND NOT (CIn.Bordatrice.Sts.PosTargetEnable)));
   END_REGION

   REGION "[Ax] Bordatrice = COut Manager"
      COut.Bordatrice.Ax.MoveToPos := (Ctrl.Bordatrice.Run AND NOT (A0302_Bordatrice.Sts.StandbyBordatrice));
      COut.Bordatrice.Ax.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Bordatrice.Ax.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Bordatrice.Ax.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Bordatrice.Ax.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[Ax] Bordatrice - RIFERIMENTI"
      IF (Sts.SemiAut.ON AND NOT (AreaInterface.Cycle)) THEN
         COut.Bordatrice.Ax.Vel := A0302_Bordatrice_PERS.Par.Ax_Aut.SemiAut_Vel;
      END_IF;
   END_REGION

   REGION "Rulliera - Move BTrk da Uscita Bord. Pareggiatore Coda Basso =a=> Uscita Bord. Pareggiatore Coda Alto"
      Ctrl.TRK.BTrk.PCodaDown_TO_Rulli_PCodaDown := ???;
      Ctrl.TRK.BTrk.Bordatrice_Out_To_PareggCodaUp := ???;
      IF Ctrl.TRK.BTrk.PCodaDown_TO_Rulli_PCodaDown THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_ENTRY.B;
      END_IF;
   END_REGION

   REGION "Rulliera - Movimento BTrk da Bordatrice-Paregg Rulliera Prima Paregg Basso => Rallenta Rulliera"
      Ctrl.TRK.BTrk.PCodaDown_TO_RALL_Rulli_PCodaDown := ???;
      IF Ctrl.TRK.BTrk.PCodaDown_TO_RALL_Rulli_PCodaDown THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Rulliera - Movimento BTrk da Rallentamento Rulliera Paregg Basso  ==a==>  STOP Rulliera Paregg Basso"
      Ctrl.TRK.BTrk.PCodaDown_TO_STOP_PCodaDown := (??? OR ???);
      IF Ctrl.TRK.BTrk.PCodaDown_TO_STOP_PCodaDown THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Rulliera - Movimento BTrk da Uscita Bord. Coda Alto  ==a==> Rulliera Prima Paregg Alto"
      Ctrl.TRK.BTrk.PareggCodaUp_To_Rull-PrimaPareggCodaAltro := ???;
      IF Ctrl.TRK.BTrk.PareggCodaUp_To_Rull-PrimaPareggCodaAltro THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_ENTRY.B;
      END_IF;
   END_REGION

   REGION "########### [Ax] Rulliera - Controllo condizioni di START - Fwd ################"
      Ctrl.TRK.BTrk.Rulliera_Ax_2_Start_Frw := ((??? OR ??? OR ??? OR ???) AND Sys.ByPass);
      Ctrl.TRK.BTrk.Rulliera_Ax_1_Start_Frw := ((??? OR ??? OR ??? OR ??? OR ((??? OR ??? OR ??? OR ???) AND Sys.ByPass) OR ??? OR ??? OR ??? OR (((??? OR ???) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Ing)) AND NOT (CIn.Rulliera.Coda.Sens.FTC_Prox_Ing)) OR ((((??? OR ???) AND Ctrl.TRK.BTrk.RulliereVode) AND CIn.CarroPareggCoda.BattutaVerticale.Rest) AND NOT (CIn.CarroPareggTesta.Sens.FTC_Prox_Ls)) OR ((((??? OR ???) AND NOT (CIn.Rulliera.Coda.Sens.FTC_Rall)) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Ing)) AND CIn.Rulliera.Coda.Sens.FTC_Prox_Ing) OR ((((??? OR ???) AND CIn.Rulliera.Coda.Sens.FTC_Rall) AND CIn.Rulliera.Coda.Sens.FTC_Prox_Ing) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Ing)) OR ((((??? OR ???) AND CIn.Rulliera.Coda.Sens.FTC_Rall) AND NOT (CIn.Rulliera.Coda.Sens.FTC_Prox_Ing)) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Ing))) AND Sys.ByPass);
   END_REGION

   REGION "[Ax] Rulliera - Controllo condizioni di START - Fwd a velocità Bordatrice"
      Ctrl.Rulliera.Ax_1_Vel_Bord := (??? OR ??? OR ??? OR ???);
      Ctrl.Rulliera.Ax_2_Vel_Bord := (Ctrl.Rulliera.Ax_1_Vel_Bord AND Ctrl.TRK.BTrk.RulliereVode);
   END_REGION

   REGION "[Ax] Rulliera - Controllo condizioni di START - Fwd a velocità LENTA CARRO CODA"
      Ctrl.Rulliera.Ax_1_Lenta_CarroCoda := (??? OR ???);
   END_REGION

   REGION "[Ax] Rulliera - Controllo condizioni di START - Fwd Velocità CARRO TESTA"
      Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta := (??? OR ??? OR ??? OR ??? OR ??? OR ???);
   END_REGION

   REGION "[Ax] Rulliera - Rallentamento Rulliera Calcolato"
      #Ctrl.Rulliera.TON_RitardoRallenta(
         IN := Ctrl.Rulliera.Ax_2_MemoRall,
         PT := Ctrl.Rulliera.SP_TimeMemoRall
      );

      IF (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta AND CIn.CarroPareggTesta.Sens.FTC_Ingombro_Ing) THEN
         Ctrl.Rulliera.Ax_2_MemoRall := TRUE;
      END_IF;
      IF (#Ctrl.Rulliera.TON_RitardoRallenta.Q AND (A0302_Rulliera.COut.Ax_2.ActualVelocity > 100.0)) THEN
         Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta := TRUE;
      END_IF;
      IF (Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta AND (A0302_Rulliera.COut.Ax_2.ActualVelocity < 100.0)) THEN
         Ctrl.Rulliera.Ax_1_2_End_VelZero := TRUE;
      END_IF;
      IF ((Ctrl.Rulliera.Ax_1_2_End_VelZero AND NOT (CIn.CarroPareggTesta.Sens.FTC_Prox_Ls)) OR (Ctrl.Rulliera.Ax_1_2_End_VelZero AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Out))) THEN
         Ctrl.Rulliera.Ax_1_2_Vel_Appoggio := TRUE;
      END_IF;
      IF NOT (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta) THEN
         Ctrl.Rulliera.Ax_2_MemoRall := FALSE;
      END_IF;
      IF NOT (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta) THEN
         Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta := FALSE;
      END_IF;
      IF NOT (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta) THEN
         Ctrl.Rulliera.Ax_1_2_End_VelZero := FALSE;
      END_IF;
      IF NOT (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta) THEN
         Ctrl.Rulliera.Ax_1_2_Vel_Appoggio := FALSE;
      END_IF;
   END_REGION

   REGION "[Ax] Rulliera - COut Manager"
      COut.Rulliera.Ax_1_Brw_Req := (Ctrl.TRK.BTrk.Rulliera_Start_Brw AND FALSE);
      COut.Rulliera.Ax_2_Brw_Req := (Ctrl.TRK.BTrk.Rulliera_Start_Brw AND FALSE);
      COut.Rulliera.Ax_1.Bwd := (Ctrl.TRK.BTrk.Rulliera_Start_Brw AND FALSE);
      COut.Rulliera.Ax_2.Bwd := (Ctrl.TRK.BTrk.Rulliera_Start_Brw AND FALSE);
      COut.Rulliera.Ax_1.Fwd := NOT ((((((NOT (Ctrl.Rulliera.Ax_1_Vel_Bord) AND NOT (Ctrl.Rulliera.Ax_1_Lenta_CarroCoda)) AND NOT (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta)) AND NOT (Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta)) AND NOT (Ctrl.Rulliera.Ax_1_2_Vel_Appoggio)) AND NOT (Ctrl.Rulliera.Ax_1_2_End_VelZero)));
      COut.Rulliera.Ax_2.Fwd := NOT (((((NOT (Ctrl.Rulliera.Ax_2_Vel_Bord) AND NOT (Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta)) AND NOT (Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta)) AND NOT (Ctrl.Rulliera.Ax_1_2_Vel_Appoggio)) AND NOT (Ctrl.Rulliera.Ax_1_2_End_VelZero)));
      COut.Rulliera.Ax_1.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Rulliera.Ax_2.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Rulliera.Ax_1.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Rulliera.Ax_2.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Rulliera.Ax_1.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Rulliera.Ax_2.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Rulliera.Ax_1.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
      COut.Rulliera.Ax_2.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[Ax] Rulliera - RIFERIMENTI Acc / Dec"
      IF NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) THEN
         COut.Rulliera.Ax_1.Acc := A0302_Rulliera_PERS.Par.Ax_Aut.Aut_Acc;
      END_IF;
   END_REGION

   REGION "[Ax] Rulliera - RIFERIMENTI Velocità"
      COut.Rulliera.Ax_1.Vel := 0.0;
      COut.Rulliera.Ax_2.Vel := 0.0;

      // RIFERIMENTI VELOCITà
      IF Ctrl.Rulliera.Ax_1_2_Vel_Appoggio THEN
          COut.Rulliera.Ax_1.Vel := COut.Rulliera.Ax_2.Vel := 5000.0;
          
      ELSIF Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta AND NOT Ctrl.Rulliera.Ax_1_2_End_VelZero THEN
          COut.Rulliera.Ax_1.Vel := COut.Rulliera.Ax_2.Vel := 0.0;
          
      ELSIF Ctrl.Rulliera.Ax_1_2_Vel_CarroTesta THEN
          COut.Rulliera.Ax_1.Vel :=   COut.Rulliera.Ax_2.Vel := A0302_Rulliera_PERS.Par.Ax_Aut.Aut_Vel;
          
      ELSIF Ctrl.Rulliera.Ax_1_Lenta_CarroCoda THEN
          COut.Rulliera.Ax_1.Vel := 2000.0;
          
      ELSIF Ctrl.Rulliera.Ax_1_Vel_Bord THEN
          COut.Rulliera.Ax_1.Vel := A0302_Bordatrice.COut.Ax.ActualVelocity;

          IF Ctrl.Rulliera.Ax_2_Vel_Bord THEN
              COut.Rulliera.Ax_2.Vel := A0302_Bordatrice.COut.Ax.ActualVelocity;
          END_IF;
      END_IF;


   END_REGION

   REGION "== Zona Pareggiatori Vuota =="
      REGION CONTROLLO CHE CI SIANO LE CONDIZIONI PER MUOVERSI IN ENTRATA A0302 (TRK EMPTY)
          // Controllo zona libera dai traking e sensori non in lettura su Spintore e Bordatrice in uscita su rulliera
          // 
          FOR i := 1 TO BTRK_A0302_ENTRY_ITEMS DO
              IF BTrk.A0302_ENTRY.B[i].B_ID = 0 THEN
                  Sts.BTrk.A0302Entry_Absence := TRUE;
              ELSE
                  Sts.BTrk.A0302Entry_Absence := FALSE;
                  EXIT;
              END_IF;
          END_FOR;
          
          // Verifica se BTrk assente e sensori su rulliera di coda non in lettura
          Sts.BTrk.ZoneA0302Entry_Empty := (Sts.BTrk.A0302Entry_Absence AND NOT CIn.Rulliera.Coda.Sens.FTC_Rall
          AND NOT CIn.Bordatrice.Sens.FTC_Ingresso AND NOT CIn.Bordatrice.Sens.FTC_Uscita);
          
      END_REGION


      REGION CONTROLLO CHE CI SIANO LE CONDIZIONI PER MUOVERSI IN USCITA A0302 (TRK EMPTY)
          // Controllo zona libera dai traking e sensori non in lettura su rulliera per movimento Carri Pareggiatori
          // 
          FOR i := 1 TO BTRK_A0302_EXIT_ITEMS DO
              IF BTrk.A0302_EXIT.B[i].B_ID = 0 THEN
                  Sts.BTrk.A0302Exit_Absence := TRUE;
              ELSE
                  Sts.BTrk.A0302Exit_Absence := FALSE;
                  EXIT;
              END_IF;
          END_FOR;
          
          // Verifica se BTrk assente e sensori su rulliera di centro + dei carri pareggiatori di testa e coda non in lettura
          Sts.BTrk.ZoneA0302Exit_Empty := (Sts.BTrk.A0302Exit_Absence
          AND NOT CIn.Rulliera.Centro.Sens.FTC_Centrale                                                                   // Sensori rulliera avanzamento Beams
          AND NOT CIn.CarroPareggCoda.Sens.PresenzaMat AND NOT CIn.CarroPareggTesta.Sens.PresenzaMat                     // Sensori presenza Beams su manipolatori
          AND NOT CIn.CarroPareggTesta.Sens.FTC_Ingombro_Ing AND NOT CIn.CarroPareggTesta.Sens.FTC_Prox_Ls               // Sensori presenza Beams su carro di testa
          AND NOT CIn.CarroPareggCoda.Sens.FTC_Ingombro_Ing AND NOT CIn.CarroPareggCoda.Sens.FTC_Ingombro_Out);          // Sensori presenza Beams su carro di coda
          
      END_REGION

   END_REGION

   REGION "== Calcolo setpoint posizione carri in funzione della cremaliera =="
      // Foglio di calcolo posizione Cremaliera fornito
      // 

      CarroTesta.PosBattutePz := 348.56;



      IF BTrk.A0302_EXIT.Beam_Len > 0 THEN
          // *****  Calcolo CARRO di TESTA ******
          CarroTesta.SemiBeamLen := (BTrk.A0302_EXIT.Beam_Len / 2.0);
          CarroTesta.PosBattutePz := Par.CarroPareggTesta.Preset;
          CarroTesta.RimanenzaPos := (CarroTesta.SemiBeamLen - CarroTesta.PosBattutePz);
          CarroTesta.NrPassiReq := (CarroTesta.RimanenzaPos / Par.Cremaliera.Passo);
          
          // Calcolo i numeri di passi cremaliera richiesti per spostarmi della rimanenza
          CarroTesta.PassoReq := (CarroTesta.NrPassiReq);
          
          // ***** Calcolo CARRO di CODA *****
          CarroCoda.SemiBeamLen := (BTrk.A0302_EXIT.Beam_Len / 2.0);
          CarroCoda.PosBattutePz := (Par.CarroPareggCoda.Preset - A0302_PareggiatoreCoda_PERS.Par_Sens.AI.RangeLow);
          CarroCoda.RimanenzaPos := (BTrk.A0302_EXIT.Beam_Len - Ctrl.CarroPareggTesta.Ax.Pos - CarroCoda.PosBattutePz) + (A0302_PareggiatoreCoda_PERS.Par_Sens.AI.RangeLow +2.0);
          CarroCoda.NrPassiReq := (CarroCoda.RimanenzaPos / Par.Cremaliera.Passo);
          
          // Calcolo i numeri di passi cremaliera richiesti per spostarmi della rimanenza
          CarroCoda.PassoReq := (CarroCoda.NrPassiReq);
          
          // Calcolo del setpoint di posizione dei 2 carri in funzione della misura calcolata - Se cambia il Beam Len viene richiesto il nuovo riposizionamento
          Ctrl.CarroPareggTesta.Ax.Pos := (CarroTesta.PassoReq * Par.Cremaliera.Passo) + CarroTesta.PosBattutePz;
          Ctrl.CarroPareggCoda.Ax.Pos := (CarroCoda.PassoReq * Par.Cremaliera.Passo) + CarroCoda.PosBattutePz + A0302_PareggiatoreCoda_PERS.Par_Sens.AI.RangeLow;
      END_IF;

   END_REGION

   REGION "== Controllo posizionamento dei carri rispetto alle spalle =="
      //

      REGION ********* Carro di TESTA ***********
          //Controllo che ci sia sempre la distanza minima tra il pareggiatore e la spalla di Testa quando muovo in direzione FRW(Apertura)
          //
          IF NOT CIn.CarroPareggTesta.Ax_InWPos AND NOT Sts.Attrezzamento.Ready THEN
              
              Ctrl.CarroPareggTesta.Ax.MoveToPos := Sts.Attrezzamento.RequestNewPosition AND Sts.BTrk.ZoneA0302Exit_Empty;
              
          ELSIF Sts.Attrezzamento.Ready THEN
              
              Ctrl.CarroPareggTesta.Ax.MoveToPos := FALSE;
          END_IF;
      END_REGION


      REGION ********* Carro di CODA ***********
          //Controllo che ci sia sempre la distanza minima tra il pareggiatore e la spalla di Coda quando muovo in direzione FRW(Apertura)
          IF NOT CIn.CarroPareggCoda.Ax_InWPos AND NOT Sts.Attrezzamento.Ready THEN
              
              Ctrl.CarroPareggCoda.Ax.MoveToPos := Sts.Attrezzamento.RequestNewPosition AND Sts.BTrk.ZoneA0302Exit_Empty;
              
          ELSIF Sts.Attrezzamento.Ready THEN
              
              Ctrl.CarroPareggCoda.Ax.MoveToPos := FALSE;
          END_IF;
      END_REGION

      // Controllo Attrezzaggio pronto 
      // Se sono con tutti e 2 i carri in finestra resetto la richiesta di nuova posizione
      IF CIn.CarroPareggCoda.Ax_InWPos AND CIn.CarroPareggTesta.Ax_InWPos  AND CIn.CarroPareggCoda.Bloccaggio.Work AND CIn.CarroPareggTesta.Bloccaggio.Work THEN
          Sts.Attrezzamento.Ready := TRUE;
      ELSE
          Sts.Attrezzamento.Ready := FALSE;
      END_IF;

   END_REGION

   REGION "Paregg. Testa - [Sollevatore] - Movimento operazione a lavoro / a riposo"
      // Sollevatore del Centraggio - Scende quando è in posizione e sta attendendo il pezzo

      CarroTestaCentraggio_Disable := ((A0302_Centratori.HMI.Selection.Centraggio[1] AND A0302_Centratori.HMI.Selection.Sollevamento[1]) OR (A0302_Centratori.HMI.Selection.Centraggio[3] AND A0302_Centratori.HMI.Selection.Sollevamento[3]));
      Ctrl.CarroPareggTesta.Sollevatore.Work := (((??? OR ??? OR ??? OR ??? OR ???) AND CIn.CarroPareggTesta.Bloccaggio.Work) AND NOT (CarroTestaCentraggio_Disable));
      Ctrl.CarroPareggTesta.Sollevatore.Rest := (NOT (Ctrl.CarroPareggTesta.Sollevatore.Work) AND CIn.CarroPareggTesta.Centraggio.Rest);
   END_REGION

   REGION "Paregg. Testa - [Centraggio] - Movimento operazione a lavoro / a riposo"
      Ctrl.CarroPareggTesta.Centraggio.Work := ((Ctrl.CarroPareggTesta.Sollevatore.Work AND CIn.CarroPareggTesta.Sollevatore.Work) AND CIn.CarroPareggTesta.Sens.FTC_Prox_Ls);
      Ctrl.CarroPareggTesta.Centraggio.Rest := NOT (Ctrl.CarroPareggTesta.Centraggio.Work);
   END_REGION

   REGION "Paregg. Testa - [Ax - Sollevatore + Centraggio] -  COut Manager"
      COut.CarroPareggTesta.Sollevamento.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.CarroPareggTesta.Sollevatore.Rest);
      COut.CarroPareggTesta.Sollevamento.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.CarroPareggTesta.Sollevatore.Work);
      COut.CarroPareggTesta.Centraggio.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.CarroPareggTesta.Centraggio.Rest);
      COut.CarroPareggTesta.Centraggio.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.CarroPareggTesta.Centraggio.Work);
      COut.CarroPareggTesta.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.CarroPareggTesta.MoveToPos := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.CarroPareggTesta.Ax.MoveToPos);
      IF (Sts.SemiAut.ON AND NOT (AreaInterface.Cycle)) THEN
         COut.CarroPareggTesta.Pos := Ctrl.CarroPareggTesta.Ax.Pos;
      END_IF;
      COut.CarroPareggTesta.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.CarroPareggTesta.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.CarroPareggTesta.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Paregg. Testa [Bloccaggio] - Movimento operazione a lavoro / a riposo"
      COut.CarroPareggTesta.Bloccaggio.Rest := (((COut.CarroPareggTesta.Control_ON AND Sts.Attrezzamento.RequestNewPosition) AND COut.CarroPareggTesta.MoveToPos) AND NOT (CIn.CarroPareggTesta.Bloccaggio.Rest));
      COut.CarroPareggTesta.Bloccaggio.Work := (((COut.CarroPareggTesta.Control_ON AND NOT (Sts.Attrezzamento.RequestNewPosition)) AND CIn.CarroPareggTesta.Ax_InWPos) AND NOT (CIn.CarroPareggTesta.Bloccaggio.Work));
   END_REGION

   REGION "Centratori - Movimento BTrk da Rull - PTesta ==a==> Rull - Centrato"
      // Pezzo su rulliera (1/2) tra i pareggiatori  + centratori  a lavoro

      Ctrl.TRK.BTrk.Stop_PTesta_TO_Rull-Centratori := ???;
      IF Ctrl.TRK.BTrk.Stop_PTesta_TO_Rull-Centratori THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Centratori - Movimento BTrk da Rull - Centrato ==a==> Pareggiamento Coda basso"
      // Pezzo su rulliera (1/2) tra i pareggiatori (quello di coda è basso)  + centratori  a lavoro

      Ctrl.TRK.BTrk.Rull-Centratori_TO_Cnd_PareggCoda := ???;
      IF Ctrl.TRK.BTrk.Rull-Centratori_TO_Cnd_PareggCoda THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Centratori - Movimento BTrk da Pareggiamento Coda basso ==a==> Pareggiato"
      // Pezzo su rulliera (1/2) tra i pareggiatori e paregiatura di coda eseguito lavoro cilindro idraulico (ora si sa la misura del pezzo, si può mettere utenze in attesa del prossimo pezzo)

      BTrk.A0302_EXIT.B.Quality := #UNKNOW;
      Ctrl.CarroPareggCoda.MisuraPzPareggiato := ???;
      Ctrl.TRK.BTrk.Cnd_PareggCoda_TO_Pareggiato := ((??? OR ???) AND CIn.CarroPareggCoda.Sens.PosPareggLong.Standstill);
      Ctrl.TRK.BTrk.Cnd_PareggCoda_TO_Pareggiato := Ctrl.TRK.BTrk.Cnd_PareggCoda_TO_Pareggiato;
   END_REGION

   REGION "[Sollevamento] -  Rulliera -  Movimento operazione a lavoro / a riposo"
      Ctrl.Rulliera.Sollevamento.Work := (??? OR ??? OR ??? OR ??? OR ??? OR ??? OR ??? OR ???);
      Ctrl.Rulliera.Sollevamento.Rest := (NOT (Ctrl.Rulliera.Sollevamento.Work) AND COut.Rulliera.Centratori.Centraggio.Rest);
   END_REGION

   REGION "[Centraggio] -  Rulliera -  Movimento operazione a lavoro / a riposo"
      Ctrl.Rulliera.Centraggio.Work := (??? OR ??? OR ??? OR ((CIn.Rulliera.Sollevamento.Work AND Ctrl.Rulliera.Ax_1_2_Vel_ZeroTesta) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Out)));
      Ctrl.Rulliera.Centraggio.Rest := NOT (Ctrl.Rulliera.Centraggio.Work);
   END_REGION

   REGION "[Centratori + Sollevamento] - Rulliera - COut Manager"
      COut.Rulliera.Centratori.Sollevamento.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Rulliera.Centratori.Centraggio.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Rulliera.Centratori.Sollevamento.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Rulliera.Sollevamento.Rest);
      COut.Rulliera.Centratori.Sollevamento.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Rulliera.Sollevamento.Work);
      COut.Rulliera.Centratori.Centraggio.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Rulliera.Centraggio.Rest);
      COut.Rulliera.Centratori.Centraggio.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Rulliera.Centraggio.Work);
      COut.Rulliera.Centratori.Sollevamento.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Rulliera.Centratori.Centraggio.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Rulliera.Centratori.Sollevamento.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Rulliera.Centratori.Centraggio.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Rulliera.Centratori.Sollevamento.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
      COut.Rulliera.Centratori.Centraggio.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "Paregg. Coda - Movimento BTrk da  STOP Rull Paregg Coda Basso  ==a==>  Paregg Coda Alto"
      // Pezzo su rulliera (1) + pareggiatore coda alto quindi può muoversi liberamente

      Ctrl.TRK.BTrk.STOP_PCodaDown_TO_PCoda_Up := ???;
      BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
   END_REGION

   REGION "Paregg. Coda - Movimento BTrk Rull prima P Coda Alto ==a==>  Paregg Coda Alto e Beams in Sens S3"
      // Pezzo su rulliera (1) + pareggiatore coda alto ed ha incontrato il sensore 3 (in ingresso al pareg.)

      Ctrl.TRK.BTrk.PCoda_Up_TO_PCoda_UP_S3 := ???;
      IF Ctrl.TRK.BTrk.PCoda_Up_TO_PCoda_UP_S3 THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Paregg. Coda - Movimento BTrk da Paregg Coda Alto  Rull Sens S3 ==a==>  Paregg Coda Alto - Sens S4"
      // Pezzo su rulliera (1) + pareggiatore coda alto ed ha incontrato il sensore 4 (in uscita al pareg.)

      Ctrl.TRK.BTrk.PCoda_UP_S3_TO_PCoda_UP_S4 := ???;
      IF Ctrl.TRK.BTrk.PCoda_UP_S3_TO_PCoda_UP_S4 THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Paregg. Coda - Movimento BTrk da Paregg Coda Alto - Rull Sens S4 ==a==>Rull tra PCoda e PTesta"
      // Pezzo su rulliera (1/2) + pareggiatore coda che è alto ed ha liberato il sensore 4-> Pareg. può andare basso (posizione di lavoro)

      Ctrl.TRK.BTrk.PCoda_Beam_TO_PTesta := ???;
      IF Ctrl.TRK.BTrk.PCoda_Beam_TO_PTesta THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Paregg. Coda - Movimento BTrk tra Rull PCoda e PTesta  => Rull dopo PCoda alto"
      Ctrl.TRK.BTrk.PCoda_UP_S4_TO_PCoda_DownCnd := ???;
      IF Ctrl.TRK.BTrk.PCoda_UP_S4_TO_PCoda_DownCnd THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Paregg. Coda - Movimento BTrk dopo PCoda alto ==a==> Rull su PTesta"
      // Pezzo su rulliera (1/2) + ha incontrato il sensore 5 su pareggiatore di testa

      Ctrl.TRK.BTrk.Beam_TO_Stop_PTesta := ???;
      IF Ctrl.TRK.BTrk.Beam_TO_Stop_PTesta THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Paregg. Coda - Allarme pezzo NON Pareggiabile per ingombro CarroCoda"
      #TON_Alarm_FTC_CarroCodaOut(
         PT := T#2S
      );

      IF #TON_Alarm_FTC_CarroCodaOut.Q THEN
         Alarm.Pz_NonPareggiabile := TRUE;
      END_IF;
   END_REGION

   REGION "Paregg. Coda [Battuta Vrt] - Movimento operazione a lavoro / a riposo"
      Ctrl.CarroPareggCoda.BattutaVerticale.Work := (((??? OR ??? OR ???) AND NOT (CIn.CarroPareggCoda.Sens.FTC_Ingombro_Out)) OR ???);
      Ctrl.CarroPareggCoda.BattutaVerticale.Rest := (??? OR (NOT (Ctrl.CarroPareggCoda.BattutaVerticale.Work) AND CIn.CarroPareggCoda.PareggiatoreLong.Rest));
   END_REGION

   REGION "Paregg. Coda [Pareggiatore Orz] - Movimento operazione a lavoro / a riposo"
      Ctrl.CarroPareggCoda.PareggiatoreLong.Work := ???;
      Ctrl.CarroPareggCoda.PareggiatoreLong.Rest := NOT (Ctrl.CarroPareggCoda.PareggiatoreLong.Work);
   END_REGION

   REGION "Paregg. Coda [Bloccaggio] - Movimento operazione a lavoro / a riposo"
      COut.CarroPareggCoda.Bloccaggio.Rest := (((COut.CarroPareggCoda.Control_ON AND Sts.Attrezzamento.RequestNewPosition) AND COut.CarroPareggCoda.MoveToPos) AND NOT (CIn.CarroPareggCoda.Bloccaggio.Rest));
      COut.CarroPareggCoda.Bloccaggio.Work := (((COut.CarroPareggCoda.Control_ON AND NOT (Sts.Attrezzamento.RequestNewPosition)) AND CIn.CarroPareggCoda.Ax_InWPos) AND NOT (CIn.CarroPareggCoda.Bloccaggio.Work));
   END_REGION

   REGION "Carro Pareggiatore Coda - COut Manager"
      COut.CarroPareggCoda.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.CarroPareggCoda.MoveToPos := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.CarroPareggCoda.Ax.MoveToPos);
      IF (Sts.SemiAut.ON AND NOT (AreaInterface.Cycle)) THEN
         COut.CarroPareggCoda.Pos := Ctrl.CarroPareggCoda.Ax.Pos;
      END_IF;
      COut.CarroPareggCoda.BattutaVrt.Rest := (COut.CarroPareggCoda.Control_ON AND Ctrl.CarroPareggCoda.BattutaVerticale.Rest);
      COut.CarroPareggCoda.BattutaVrt.Work := (COut.CarroPareggCoda.Control_ON AND Ctrl.CarroPareggCoda.BattutaVerticale.Work);
      COut.CarroPareggCoda.PareggLong.Rest := (COut.CarroPareggCoda.Control_ON AND Ctrl.CarroPareggCoda.PareggiatoreLong.Rest);
      COut.CarroPareggCoda.PareggLong.Work := (COut.CarroPareggCoda.Control_ON AND Ctrl.CarroPareggCoda.PareggiatoreLong.Work);
   END_REGION

   REGION "Carro Pareggiatore Coda -  COut stop Manager"
      COut.CarroPareggCoda.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.CarroPareggCoda.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.CarroPareggCoda.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "HU Cytropack - COut Manager"
      COut.HU.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.HU.Work := ((COut.CarroPareggCoda.Control_ON AND Ctrl.CarroPareggCoda.Ax.MoveToPos) OR (COut.CarroPareggTesta.Control_ON AND Ctrl.CarroPareggTesta.Ax.MoveToPos) OR (NOT ((((((NOT (COut.CarroPareggCoda.PareggLong.Rest) AND NOT (COut.CarroPareggCoda.PareggLong.Work)) AND NOT (COut.CarroPareggTesta.Bloccaggio.Work)) AND NOT (COut.CarroPareggCoda.Bloccaggio.Work)) AND NOT (COut.CarroPareggTesta.Bloccaggio.Rest)) AND NOT (COut.CarroPareggCoda.Bloccaggio.Rest))) AND COut.HU.Control_ON));
   END_REGION

   REGION "== Lettura del Beam pareggiato =="
      // Controllo della misura del beam misurata


      IF NOT Ctrl.TRK.BTrk_ToCheck.Prelievo_RecondGood THEN
          
          // Salvo misura con Offset gioco
          IF CIn.CarroPareggTesta.Ax_InWPos AND CIn.CarroPareggCoda.Ax_InWPos
              AND (Ctrl.TRK.BTrk.Cnd_PareggCoda_TO_Pareggiato OR A03_DEBUG.A0302_Manager.PareggiaRead) THEN
              BTrk.A0302_EXIT.B[BTRK_A0302_RULL_CENTRATO_PAREG_CODA_BASSO].BLen_Meas :=
              (IN := (CIn.CarroPareggCoda.Ax.ActualPosition + CIn.CarroPareggTesta.Ax.ActualPosition) - CIn.CarroPareggCoda.Sens.PosPareggLong.Value) - OffsetGioco;
          END_IF;
          
          // Salvo misura senza Offset gioco
          IF CIn.CarroPareggTesta.Ax_InWPos AND CIn.CarroPareggCoda.Ax_InWPos
              AND (Ctrl.TRK.BTrk.Cnd_PareggCoda_TO_Pareggiato OR A03_DEBUG.A0302_Manager.PareggiaRead) THEN
              Sts.BTrk.BLen_Paregg :=(IN := (CIn.CarroPareggCoda.Ax.ActualPosition + CIn.CarroPareggTesta.Ax.ActualPosition) - CIn.CarroPareggCoda.Sens.PosPareggLong.Value);
          END_IF;
      END_IF;

   END_REGION

   REGION "== Controllo della misura se è buona o da scartare =="
      Ctrl.TRK.BTrk.Check_Tolleranza_BLen_Qlty := ???;
      IF (BTrk_A0302_EXIT_GetData.Sts >= 0) THEN
         BTrk_A0302_Exit_Item.Tol_Min := BTrk_A0302_EXIT_GetData.Item.Beams_Len_Min;
      END_IF;
      BTrk_A0302_Exit_Item.Good := IN_RANGE(PRE:=(((Ctrl.TRK.BTrk.Check_Tolleranza_BLen_Qlty AND CIn.CarroPareggTesta.Ax_InWPos) AND CIn.CarroPareggCoda.Ax_InWPos) AND CIn.CarroPareggCoda.Sens.PosPareggLong.Standstill), MIN:=BTrk_A0302_Exit_Item.Tol_Min, IN:=BTrk.A0302_EXIT.B.BLen_Meas, MAX:=BTrk_A0302_Exit_Item.Tol_Max);
      BTrk_A0302_Exit_Item.ToCheckLen := ((((Ctrl.TRK.BTrk.Check_Tolleranza_BLen_Qlty AND CIn.CarroPareggTesta.Ax_InWPos) AND CIn.CarroPareggCoda.Ax_InWPos) AND CIn.CarroPareggCoda.Sens.PosPareggLong.Standstill) AND NOT (BTrk_A0302_Exit_Item.Good));
   END_REGION

   REGION "CONTROLLO QUALITA' - Determinazione della Qualità"
      // In base alla misura del pezzo determino se il pezzo è buono o cattivo
      // 
      IF  BTrk.A0302_EXIT.B[BTRK_A0302_RULL_PAREGGIATO].BLen_Meas > 0.0 AND BTrk.A0302_EXIT.B[BTRK_A0302_RULL_PAREGGIATO].Quality = UNKNOW THEN
          // Pezzo misurato buono - In tolleranza
          IF BTrk_A0302_Exit_Item.Good AND NOT BTrk_A0302_Exit_Item.ToCheckLen THEN
              BTrk.A0302_EXIT.B[BTRK_A0302_RULL_PAREGGIATO].Quality := BEAM_GOOD_N;
              
          // Pezzo misurato da controllare - Fuori tolleranza 
          ELSIF NOT BTrk_A0302_Exit_Item.Good AND BTrk_A0302_Exit_Item.ToCheckLen THEN
              BTrk.A0302_EXIT.B[BTRK_A0302_RULL_PAREGGIATO].Quality := BEAM_TO_CHECK_N;
              
          END_IF;

      END_IF;


   END_REGION

   REGION "Manipolatori - Movimento BTrk da  Pareggiato ==a==> Presa in Basso"
      // Pezzo su magneti del manipolatore basso in posizione di presa.
// Quando faccio la presa

      Ctrl.TRK.BTrk.Pareggiato_TO_PresaBasso := ???;
      Ctrl.TRK.BTrk.Pareggiato_TO_PresaBasso := ((((((((Ctrl.TRK.BTrk.Pareggiato_TO_PresaBasso AND CIn.Manipolatori.Coda.Sollevatore.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.Manipolatori.Testa.Sollevatore.Work) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat) AND (BTrk.A0302_EXIT.B.Quality = #GOOD)) OR (((((((Ctrl.TRK.BTrk.Pareggiato_TO_PresaBasso AND CIn.Manipolatori.Coda.Sollevatore.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.Manipolatori.Testa.Sollevatore.Work) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat) AND (BTrk.A0302_EXIT.B.Quality = #GOOD_R)) OR (((((((Ctrl.TRK.BTrk.Pareggiato_TO_PresaBasso AND CIn.Manipolatori.Coda.Sollevatore.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.Manipolatori.Testa.Sollevatore.Work) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat) AND (BTrk.A0302_EXIT.B.Quality = #TO_CHECK)));
      IF Ctrl.TRK.BTrk.Pareggiato_TO_PresaBasso THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Manipolatori - Movimento BTrk da Presa in Basso ==a==> Presa in Alto"
      // Pezzo su magneti del manipolatore alto in posizione di presa.

      Ctrl.TRK.BTrk.PresaBasso_TO_PresaAlto := ???;
      Ctrl.TRK.BTrk.PresaBasso_TO_PresaAlto := (((((((Ctrl.TRK.BTrk.PresaBasso_TO_PresaAlto AND CIn.Manipolatori.Coda.Sollevatore.Rest) AND CIn.Manipolatori.Testa.Sollevatore.Rest) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.CarroPareggTesta.Sollevatore.Rest) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat);
      IF Ctrl.TRK.BTrk.PresaBasso_TO_PresaAlto THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
      IF BTrk.Empty THEN
         Ctrl.TRK.BTrk_ToCheck.Prelievo_RecondGood := FALSE;
      END_IF;
   END_REGION

   REGION "Manipolatori - Movimento BTrk da Presa in Alto Vs USCITA SCARTO alto"
      Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_BadQlty := ???;
      Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_BadQlty := ((((Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_BadQlty AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat);
      Ctrl.TRK.BTrk.CheckOut_BadQlty_UP_MoveToPos := ((((Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_BadQlty AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat);
      IF (Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_BadQlty AND CIn.Manipolatori.InPos_BancoScarto) THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Manipolatori - Movimento BTrk da Uscita Scarto alto Vs Uscita Scarto basso"
      Ctrl.TRK.BTrk.CheckOut_BadQlty_UP_To_DOWN := ???;
      IF Ctrl.TRK.BTrk.CheckOut_BadQlty_UP_To_DOWN THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Manipolatori - Movimento BTrk  Uscita Scarto basso == a ==> Rilascia Beam"
      Ctrl.TRK.BTrk.CheckOut_BadQlty_DOWN_To_Sgancia := ???;
      IF (((Ctrl.TRK.BTrk.CheckOut_BadQlty_DOWN_To_Sgancia AND CIn.Manipolatori.InPos_BancoScarto) AND CIn.Manipolatori.Testa.Magnete.Rest) AND CIn.Manipolatori.Coda.Magnete.Rest) THEN
         BTrk.A03_EXIT_TOCHECK.B[1] := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "== TRASFERISCI  BTrk su elenco Tracking TO_CHECK =="
      #A0302_Mng_BtrkListToCheck(
         en := (??? OR NOT (Sys.ByPass) OR Ctrl.TRK.BTrk_ToCheck.ClearList),
         BTrk := BTrk.A03_EXIT_TOCHECK.B,
         FullList := Alarm.ToCheckList_Full
      );

   END_REGION

   REGION "== Reset List - Controllo Qualità Banco Scarto =="
      // // Se tutti i Beam presenti sul banco sono Qlty: NG_R allora posso cancellare tutta la lista
// //

      Sts.BTrk.A0302_CheckBancoAccumulo := (NOT (Ctrl.TRK.BTrk_ToCheck.QtyClear_RetVal) AND (BTrk.A03_EXIT_TOCHECK.Beam_Qty <> 0));
      Warning.CheckBancoAccumulo := (NOT (Ctrl.TRK.BTrk_ToCheck.QtyClear_RetVal) AND (BTrk.A03_EXIT_TOCHECK.Beam_Qty <> 0));
      A0302_Mng_BtrkListToCheck.Control.Pls_ClearArchive := (Ctrl.TRK.BTrk_ToCheck.ClearList AND HMI.PlsClear_ListToCheck);
   END_REGION

   REGION "= Movimento BTrk (RECOND_GOOD)  Da banco accumulo ToChech == a ==> Centrori & Pareggiatori ="
      IF (((((((A0302_Manager.Sts.BTrk.ZoneA0302Entry_Empty AND A0302_Manager.Sts.BTrk.ZoneA0302Exit_Empty) AND Sts.Attrezzamento.Ready) AND BTrk_ListToCheck.Recond.Found) AND (BTrk_ListToCheck.Recond.Nr_B <> -1)) AND CIn.Rulliera.Centraggio.Rest) AND CIn.Rulliera.Sollevamento.Rest) AND A0302_Manipolatore.COut.InPos_Prelievo) THEN
         Ctrl.TRK.BTrk_ToCheck.Prelievo_RecondGood := TRUE;
      END_IF;
      Ctrl.TRK.BTrk_ToCheck.RecG_InPos_Centraggio := ((((((((A0302_Manager.Sts.BTrk.ZoneA0302Entry_Empty AND A0302_Manager.Sts.BTrk.ZoneA0302Exit_Empty) AND Sts.Attrezzamento.Ready) AND BTrk_ListToCheck.Recond.Found) AND (BTrk_ListToCheck.Recond.Nr_B <> -1)) AND CIn.Rulliera.Centraggio.Rest) AND CIn.Rulliera.Sollevamento.Rest) AND CIn.CarroPareggTesta.Sens.FTC_Prox_Ls) AND CIn.Rulliera.Centro.Sens.FTC_Centrale);
      BTrk.A0302_EXIT.B := BTrk.A03_EXIT_TOCHECK.B;
      Ctrl.TRK.BTrk_ToCheck.RegG_InPos_ReadyPickUp := ???;
   END_REGION

   REGION "Manipolatori - Movimento BTrk da Presa in Alto Vs USCITA DEPOSITO A0303"
      Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty := ???;
      Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty := ((((((Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty AND CIn.Manipolatori.Testa.Sollevatore.Rest) AND CIn.Manipolatori.Coda.Sollevatore.Rest) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat);
      Ctrl.TRK.BTrk.CheckOut_GoodQlty_UP_MoveToPos := ((((((Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty AND CIn.Manipolatori.Testa.Sollevatore.Rest) AND CIn.Manipolatori.Coda.Sollevatore.Rest) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND CIn.CarroPareggTesta.Sens.PresenzaMat);
      IF (Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty AND CIn.Manipolatori.InPos_BancoA0303) THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Manipolatori - Movimento BTrk da Uscita Deposito A0303 alto Vs Uscita deposito A0303 basso"
      Ctrl.TRK.BTrk.CheckOut_GoodQlty_UP_To_DOWN := (??? OR ???);
      IF ((Ctrl.TRK.BTrk.CheckOut_GoodQlty_UP_To_DOWN AND CIn.Manipolatori.Testa.Sollevatore.Work) AND CIn.Manipolatori.Coda.Sollevatore.Work) THEN
         BTrk.A0302_EXIT.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "Manipolatori - Movimento BTrk  Uscita deposito A0303 basso == a ==> Rilascia Beam"
      Ctrl.TRK.BTrk.CheckOut_GoodQlty_DOWN_To_Sgancia := ???;
      IF ((((Ctrl.TRK.BTrk.CheckOut_GoodQlty_DOWN_To_Sgancia AND CIn.Manipolatori.Testa.Magnete.Rest) AND CIn.Manipolatori.Coda.Magnete.Rest) AND NOT (CIn.CarroPareggTesta.Sens.PresenzaMat)) AND NOT (CIn.CarroPareggCoda.Sens.PresenzaMat)) THEN
         BTrk.A0303.Preparation.B := BTrk.A0302_EXIT.B;
      END_IF;
   END_REGION

   REGION "[Ax] Manipolatore - Control - Pos. PRELIEVO su carri pareggiatori"
      Ctrl.TRK.BTrk.Manipolatori_Return_ToPrelievo := ???;
   END_REGION

   REGION "Manipolatori - Controllo del pezzo sui Magneti - Allarme grave se perdo i sensori presenza"
      #TON_AlarmWrongReadPz_Manip(
         IN := ((((((((??? OR ??? OR ???) AND CIn.Manipolatori.Testa.Sollevatore.Rest) AND CIn.Manipolatori.Coda.Sollevatore.Rest) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND NOT (CIn.CarroPareggCoda.Sens.PresenzaMat)) AND CIn.CarroPareggTesta.Sens.PresenzaMat) OR (((((((??? OR ??? OR ???) AND CIn.Manipolatori.Testa.Sollevatore.Rest) AND CIn.Manipolatori.Coda.Sollevatore.Rest) AND CIn.Manipolatori.Testa.Magnete.Work) AND CIn.Manipolatori.Coda.Magnete.Work) AND CIn.CarroPareggCoda.Sens.PresenzaMat) AND NOT (CIn.CarroPareggTesta.Sens.PresenzaMat))),
         PT := T#2S
      );

      IF #TON_AlarmWrongReadPz_Manip.Q THEN
         Alarm.WrongReadPz_ManipBasso := TRUE;
      END_IF;
   END_REGION

   REGION "[Sollevatori] - Manipolatori Testa/Coda - Movimento operazione a lavoro / a riposo"
      Ctrl.Manipolatori.Sollevatori.Work := (((??? OR ??? OR ???) AND CIn.Manipolatori.InPos_Prelievo) OR ??? OR ???);
      IF ((NOT (CIn.Manipolatori.InPos_BancoA0303) AND NOT (CIn.Manipolatori.InPos_Prelievo)) AND NOT (CIn.Manipolatori.InPos_BancoScarto)) THEN
         Ctrl.Manipolatori.Sollevatori.Work := FALSE;
      END_IF;
      Ctrl.Manipolatori.Sollevatori.Rest := NOT (Ctrl.Manipolatori.Sollevatori.Work);
   END_REGION

   REGION "[Magneti] - Manipolatori Testa/Coda - Movimento operazione a lavoro / a riposo"
      Ctrl.Manipolatori.Magneti.Work := (((((??? OR ???) AND CIn.Manipolatori.InPos_Prelievo) AND CIn.Manipolatori.Testa.Sollevatore.Work) AND CIn.Manipolatori.Coda.Sollevatore.Work) OR ??? OR ??? OR ??? OR ??? OR ???);
      Ctrl.Manipolatori.Magneti.Rest := NOT (Ctrl.Manipolatori.Magneti.Work);
   END_REGION

   REGION "[Sollevatori + Magneti + Ax] - Manipolatori Testa/Coda - COut Manager"
      COut.Manipolatori.Ax.Control_ON := NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle)));
      COut.Manipolatori.Sollevatori.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Manipolatori.Sollevatori.Rest);
      COut.Manipolatori.Sollevatori.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Manipolatori.Sollevatori.Work);
      COut.Manipolatori.Magneti.Rest := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Manipolatori.Magneti.Rest);
      COut.Manipolatori.Magneti.Work := (NOT ((NOT (Sts.SemiAut.ON) AND NOT (AreaInterface.Cycle))) AND Ctrl.Manipolatori.Magneti.Work);
      COut.Manipolatori.Ax.MoveToPos := ((((COut.Manipolatori.Ax.Control_ON AND Ctrl.TRK.BTrk.CheckOut_BadQlty_UP_MoveToPos) AND NOT (CIn.Manipolatori.InPos_BancoScarto)) OR ((COut.Manipolatori.Ax.Control_ON AND Ctrl.TRK.BTrk.CheckOut_GoodQlty_UP_MoveToPos) AND NOT (CIn.Manipolatori.InPos_BancoA0303)) OR ((COut.Manipolatori.Ax.Control_ON AND Ctrl.TRK.BTrk.Manipolatori_Return_ToPrelievo) AND NOT (CIn.Manipolatori.InPos_Prelievo))) AND NOT (Alarm.WrongReadPz_ManipBasso));
      IF CIn.Manipolatori.InPos_BancoScarto THEN
         Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_BadQlty := FALSE;
      END_IF;
      IF CIn.Manipolatori.InPos_BancoA0303 THEN
         Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty := FALSE;
      END_IF;
      IF CIn.Manipolatori.InPos_Prelievo THEN
         Ctrl.TRK.BTrk.Manipolatori_Return_ToPrelievo := FALSE;
      END_IF;
      COut.Manipolatori.Ax.EnableStopDoorOpeningReq := MachineInterface.MotionsStandStill;
      COut.Manipolatori.Ax.EnableStopInPhase := MachineInterface.AckStopInPhase;
      COut.Manipolatori.Ax.EnableStopProgrammed := MachineInterface.AckStopProgrammed;
   END_REGION

   REGION "[Ax] - Manipolatori Testa/Coda - RIFERIMENTI"
      IF Ctrl.TRK.BTrk.PresaAlto_To_CheckOut_GoodQlty THEN
         COut.Manipolatori.Ax.Pos := A0302_Manipolatore_PERS.Par.Ax_Pos.BancoA0303;
      END_IF;
   END_REGION

   REGION "Stop Cycle"
      #TON_Stop(
         IN := ((AreaInterface.StopProgrammed OR CIn.ProdManager.STOP_FineTurno OR CIn.ProdManager.STOP_ControlloQualita OR AreaInterface.StopInPhase) AND Sts.IsStandstill),
         PT := T#1s
      );

      Ctrl.Stop := #TON_Stop.Q;
      IF (#TON_Stop.Q AND CIn.ProdManager.STOP_FineTurno) THEN
         Alarm.STOP_FineTurno := TRUE;
      END_IF;
      IF (#TON_Stop.Q AND CIn.ProdManager.STOP_ControlloQualita) THEN
         Alarm.STOP_ControlloQualita := TRUE;
      END_IF;
      IF CIn.ProdManager.STOP_End_Of_Production THEN
         Alarm.STOP_End_Of_Proroduction := TRUE;
      END_IF;
   END_REGION

   REGION "All motions standstill"
      Sts.IsStandstill := ((((((((CIn.P5.SpintoreLong.Ax.Standstill AND CIn.Bordatrice.Ax.Standstill) AND A0302_Bordatrice_RegolazioneFormato.AX_D[1].COut.Standstill) AND CIn.Rulliera.Ax_1.Standstill) AND CIn.Rulliera.Ax_2.Standstill) AND CIn.CarroPareggCoda.Ax.Standstill) AND CIn.CarroPareggTesta.Ax.Standstill) AND CIn.Manipolatori.Testa.Ax.Standstill) AND CIn.Manipolatori.Coda.Ax.Standstill);
   END_REGION

   REGION "Alarms / Warning presence"
      Sts.AlarmsPresence := (NOT ((((NOT (Alarm.WrongReadPz_ManipBasso) AND NOT (Alarm.STOP_End_Of_Proroduction)) AND NOT (Alarm.STOP_ControlloQualita)) AND NOT (Alarm.STOP_FineTurno))) AND NOT (AreaInterface.Man));
      Sts.WarningsPresence := (NOT ((((NOT (Alarm.WrongReadPz_ManipBasso) AND NOT (Alarm.STOP_End_Of_Proroduction)) AND NOT (Alarm.STOP_ControlloQualita)) AND NOT (Alarm.STOP_FineTurno))) AND AreaInterface.Man);
   END_REGION

   REGION "Collect machine to area interface"
      MachineInterface.AlarmsPresence := Sts.AlarmsPresence;

      MachineInterface.WarningPresence := Sts.WarningsPresence;

      MachineInterface.MotionsStandStill := Sts.IsStandstill;

      MachineInterface.AutReady := AreaInterface.Aut AND NOT Sts.AlarmsPresence;


      MachineInterface.AckStopInPhase := AreaInterface.StopInPhase AND Ctrl.Stop;

      MachineInterface.AckStopProgrammed := AreaInterface.StopProgrammed AND Ctrl.Stop;


      MachineInterface.Aborting := AreaInterface.Aut AND Sts.AlarmsPresence;


   END_REGION


END_FUNCTION_BLOCK
